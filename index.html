<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chaos‑Kugel – erweiterte Kontrolle</title>
  <style>
    :root {
      --panel: rgba(0,0,0,.6);
      --fg: #ddd;
      --sheet-compact-height: 32vh;
      --sheet-expanded-height: 84vh;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: var(--fg); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #panel {
      position: absolute;
      top: 56px;
      right: 10px;
      z-index: 10;
      width: 330px;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
      background: var(--panel);
      border-radius: 10px;
      padding: 12px;
      backdrop-filter: blur(2px);
      transition: opacity .25s ease, transform .25s ease;
    }
    #panel.is-hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-12px);
    }
    #panel h3 { margin: .25rem 0 .5rem; font-size: .95rem; }
    .accordion {
      background: rgba(20, 20, 20, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      margin: 0 0 .75rem;
      overflow: hidden;
    }
    .accordion + .accordion { margin-top: .5rem; }
    .accordion__trigger {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .65rem;
      padding: .6rem .85rem;
      background: transparent;
      color: inherit;
      border: none;
      font-size: .85rem;
      font-weight: 600;
      letter-spacing: .01em;
      cursor: pointer;
      position: relative;
      transition: background .2s ease, color .2s ease;
    }
    .accordion__trigger::after {
      content: '▾';
      font-size: .9rem;
      transition: transform .2s ease;
    }
    .accordion__trigger[aria-expanded="false"]::after {
      transform: rotate(-90deg);
    }
    .accordion__trigger[aria-expanded="true"] {
      background: rgba(70, 70, 70, 0.25);
    }
    .accordion__trigger[aria-expanded="false"] {
      background: rgba(0, 0, 0, 0.05);
    }
    .accordion__trigger:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 2px;
    }
    .accordion__panel {
      padding: .5rem .85rem .55rem;
      display: grid;
      gap: .2rem;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }
    .accordion__panel.is-open {
      background: rgba(255, 255, 255, 0.04);
    }
    .accordion__panel[hidden] {
      display: none;
    }
    .row { margin: .35rem 0 .8rem; }
    .row label { display: block; font-size: .8rem; margin-bottom: .25rem; opacity: .95; }
    .row button {
      padding: .35rem .6rem;
      font-size: .8rem;
      background: rgba(255, 255, 255, 0.08);
      color: var(--fg);
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, opacity .2s ease;
    }
    .row button[aria-pressed="true"] {
      background: rgba(40, 160, 220, 0.35);
      border-color: rgba(90, 190, 255, 0.7);
    }
    .row button:disabled,
    .row button[aria-disabled="true"] {
      opacity: 0.55;
      cursor: default;
    }
    .file-row { display: flex; flex-direction: column; gap: .35rem; }
    .file-meta { font-size: .75rem; opacity: .75; word-break: break-word; }
    .audio-controls { display: flex; flex-wrap: wrap; gap: .5rem; }
    .audio-controls button { flex: 1 1 140px; }
    .status-row { display: flex; align-items: center; gap: .5rem; font-size: .78rem; min-height: 1.4em; }
    .status-indicator { width: 10px; height: 10px; border-radius: 50%; background: rgba(255, 255, 255, 0.35); box-shadow: 0 0 6px rgba(0, 0, 0, 0.45); flex-shrink: 0; transition: background .2s ease, box-shadow .2s ease; }
    .status-text { flex: 1; }
    .status-text[data-state="idle"] { color: rgba(255, 255, 255, 0.65); }
    .status-text[data-state="waiting"] { color: #ffd166; }
    .status-text[data-state="active"] { color: #7fffd4; }
    .status-text[data-state="error"] { color: #ff8a80; }
    .status-indicator[data-state="waiting"] { background: #ffd166; box-shadow: 0 0 12px rgba(255, 209, 102, 0.6); }
    .status-indicator[data-state="active"] { background: #7fffd4; box-shadow: 0 0 12px rgba(127, 255, 212, 0.65); }
    .status-indicator[data-state="error"] { background: #ff8a80; box-shadow: 0 0 12px rgba(255, 138, 128, 0.75); }
    .wrap { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
    .bound-input {
      width: 64px;
      padding: .25rem .35rem;
      font-size: .75rem;
      color: var(--fg);
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      flex: 0 0 64px;
    }
    .bound-input:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 1px;
    }
    .stack { display: flex; flex-direction: column; gap: .4rem; }
    .tag { min-width: 64px; font-size: .75rem; letter-spacing: .02em; text-transform: uppercase; opacity: .7; }
    input[type=range],
    input[type=number] { flex: 1; width: 100%; }
    .val { min-width: 66px; text-align: right; font-variant-numeric: tabular-nums; }
    select { flex: 1; }
    #bar { position: absolute; top: 10px; left: 10px; z-index: 12; display: flex; gap: 8px; }
    #bar button {
      padding: .45rem .65rem;
      font-size: .85rem;
      background: var(--panel);
      color: #fff;
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(2px);
      transition: background .2s ease, border-color .2s ease;
    }
    #bar button[aria-pressed="true"] {
      background: rgba(40, 160, 220, 0.65);
      border-color: rgba(90, 190, 255, 0.9);
    }
    @media (hover:hover) {
      #bar button:hover {
        background: rgba(80, 80, 80, 0.7);
      }
    }
    .sheet-handle {
      display: none;
    }
    .sheet-handle-label {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    @media (max-width: 768px) {
      #panel {
        position: fixed;
        top: auto;
        bottom: 0;
        right: auto;
        left: 0;
        width: 100%;
        max-width: none;
        border-radius: 18px 18px 0 0;
        padding: 18px 18px 24px;
        max-height: min(var(--sheet-expanded-height), calc(100vh - 56px));
        transform: translateY(var(--sheet-offset, 0px));
        transition: opacity .25s ease, transform .35s ease;
        box-shadow: 0 -12px 28px rgba(0, 0, 0, 0.4);
      }
      #panel.is-hidden {
        transform: translateY(calc(var(--sheet-expanded-height, 80vh) + 40px));
      }
      #panel.is-dragging {
        transition: none;
      }
      .sheet-handle {
        display: flex;
        justify-content: center;
        margin: -6px auto 10px;
      }
      .sheet-handle button {
        appearance: none;
        border: none;
        background: transparent;
        padding: 10px 24px;
        border-radius: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        cursor: grab;
        touch-action: none;
      }
      .sheet-handle button:active {
        cursor: grabbing;
      }
      .sheet-handle-bar {
        width: 44px;
        height: 5px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      .sheet-handle button:focus-visible .sheet-handle-bar {
        outline: 2px solid rgba(90, 190, 255, 0.95);
        outline-offset: 4px;
      }
      #bar {
        left: 50%;
        transform: translateX(-50%);
        flex-wrap: wrap;
        justify-content: center;
        width: calc(100% - 20px);
      }
      #bar button {
        flex: 1 1 140px;
        text-align: center;
      }
    }
    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
    canvas.locked { cursor: not-allowed; }
    canvas.locked:active { cursor: not-allowed; }
  </style>
  <!-- Load Three.js and OrbitControls from local files -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.js"></script>
</head>
<body>
<div id="bar">
  <button id="toggle" aria-expanded="true">↕ Panel ausblenden</button>
  <button id="lock" aria-pressed="false">🔓 Kamera frei</button>
  <button id="random">🎲 Random</button>
</div>
<div id="panel">
  <div class="sheet-handle">
    <button id="sheetHandle" type="button" aria-expanded="false" aria-controls="panel">
      <span class="sheet-handle-bar" aria-hidden="true"></span>
      <span class="sheet-handle-label">Panel vergrößern</span>
    </button>
  </div>
  <h3>Parameter</h3>
  <section class="accordion" id="acc-points">
    <button type="button" class="accordion__trigger" id="acc-points-trigger" aria-expanded="true" aria-controls="acc-points-panel">
      Punkte
    </button>
    <div class="accordion__panel" id="acc-points-panel" role="region" aria-labelledby="acc-points-trigger">
      <div class="row">
        <label for="pCount">Anzahl Punkte (Summe)</label>
        <div class="wrap">
          <input id="pCount" type="number" min="0" step="1" readonly />
          <div class="val" id="vCount"></div>
        </div>
      </div>
      <div class="row">
        <label for="pRadius">Radius</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pRadius" data-bound="min" />
          <input id="pRadius" type="range" min="40" max="260" step="1" />
          <input class="bound-input" type="number" data-target="pRadius" data-bound="max" />
          <div class="val" id="vRadius"></div>
        </div>
      </div>
      <div class="row">
        <label for="pDistribution">Verteilungsalgorithmus</label>
        <select id="pDistribution">
          <option value="random">Zufall (Sphäre)</option>
          <option value="fibonacci">Fibonacci-Sphäre</option>
          <option value="spiral">Galaxie-Spirale</option>
        </select>
      </div>
      <div class="row">
        <label for="pSizeVar">Größenvariation (Δ)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeVar" data-bound="min" />
          <input id="pSizeVar" type="range" min="0" max="10" step="0.1" />
          <input class="bound-input" type="number" data-target="pSizeVar" data-bound="max" />
          <div class="val" id="vSizeVar"></div>
        </div>
      </div>
      <div class="row">
        <label for="pCluster">Clustering</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pCluster" data-bound="min" />
          <input id="pCluster" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pCluster" data-bound="max" />
          <div class="val" id="vCluster"></div>
        </div>
      </div>
      <div class="row">
        <label for="pPointAlpha">Deckkraft Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pPointAlpha" data-bound="min" />
          <input id="pPointAlpha" type="range" min="0.3" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pPointAlpha" data-bound="max" />
          <div class="val" id="vPointAlpha"></div>
        </div>
      </div>
      <div class="row">
        <label for="pHue">Punktfarbe (Farbton)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pHue" data-bound="min" />
          <input id="pHue" type="range" min="0" max="360" step="1" />
          <input class="bound-input" type="number" data-target="pHue" data-bound="max" />
          <div class="val" id="vHue"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSaturation">Punktfarbe (Sättigung)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSaturation" data-bound="min" />
          <input id="pSaturation" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pSaturation" data-bound="max" />
          <div class="val" id="vSaturation"></div>
        </div>
      </div>
      <div class="row">
        <label for="pValue">Punktfarbe (Helligkeit)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pValue" data-bound="min" />
          <input id="pValue" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pValue" data-bound="max" />
          <div class="val" id="vValue"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSeedStars">Seed Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSeedStars" data-bound="min" />
          <input id="pSeedStars" type="range" min="1" max="9999" step="1" />
          <input class="bound-input" type="number" data-target="pSeedStars" data-bound="max" />
          <div class="val" id="vSeedStars"></div>
        </div>
      </div>
      <div class="row">
        <label>Punktkategorien (Anzahl)</label>
        <div class="stack">
          <div class="wrap">
            <span class="tag">Klein</span>
            <input id="pCatSmallCount" type="number" min="0" step="1" />
            <div class="val" id="vCatSmallCount"></div>
          </div>
          <div class="wrap">
            <span class="tag">Mittel</span>
            <input id="pCatMediumCount" type="number" min="0" step="1" />
            <div class="val" id="vCatMediumCount"></div>
          </div>
          <div class="wrap">
            <span class="tag">Groß</span>
            <input id="pCatLargeCount" type="number" min="0" step="1" />
            <div class="val" id="vCatLargeCount"></div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-size">
    <button type="button" class="accordion__trigger" id="acc-size-trigger" aria-expanded="false" aria-controls="acc-size-panel">
      Größe
    </button>
    <div class="accordion__panel" id="acc-size-panel" role="region" aria-labelledby="acc-size-trigger" hidden>
      <div class="row">
        <label for="pSizeTiny">Größe winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeTiny" data-bound="min" />
          <input id="pSizeTiny" type="range" min="0.05" max="3" step="0.01" />
          <input class="bound-input" type="number" data-target="pSizeTiny" data-bound="max" />
          <div class="val" id="vSizeTiny"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeSmall">Größe kleine Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeSmall" data-bound="min" />
          <input id="pSizeSmall" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeSmall" data-bound="max" />
          <div class="val" id="vSizeSmall"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeMedium">Größe mittlere Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeMedium" data-bound="min" />
          <input id="pSizeMedium" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeMedium" data-bound="max" />
          <div class="val" id="vSizeMedium"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeLarge">Größe große Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeLarge" data-bound="min" />
          <input id="pSizeLarge" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeLarge" data-bound="max" />
          <div class="val" id="vSizeLarge"></div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-connections">
    <button type="button" class="accordion__trigger" id="acc-connections-trigger" aria-expanded="false" aria-controls="acc-connections-panel">
      Verbindungen
    </button>
    <div class="accordion__panel" id="acc-connections-panel" role="region" aria-labelledby="acc-connections-trigger" hidden>
      <div class="row">
        <label for="pTinyCount">Menge winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pTinyCount" data-bound="min" />
          <input id="pTinyCount" type="range" min="0" max="5000" step="10" />
          <input class="bound-input" type="number" data-target="pTinyCount" data-bound="max" />
          <div class="val" id="vTinyCount"></div>
        </div>
      </div>
      <div class="row">
        <label for="pConnPercent">Prozent Verbindungen</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pConnPercent" data-bound="min" />
          <input id="pConnPercent" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pConnPercent" data-bound="max" />
          <div class="val" id="vConnPercent"></div>
        </div>
      </div>
      <div class="row">
        <label for="pTinyAlpha">Deckkraft winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pTinyAlpha" data-bound="min" />
          <input id="pTinyAlpha" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pTinyAlpha" data-bound="max" />
          <div class="val" id="vTinyAlpha"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSeedTiny">Seed winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSeedTiny" data-bound="min" />
          <input id="pSeedTiny" type="range" min="1" max="9999" step="1" />
          <input class="bound-input" type="number" data-target="pSeedTiny" data-bound="max" />
          <div class="val" id="vSeedTiny"></div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-display">
    <button type="button" class="accordion__trigger" id="acc-display-trigger" aria-expanded="false" aria-controls="acc-display-panel">
      Darstellung
    </button>
    <div class="accordion__panel" id="acc-display-panel" role="region" aria-labelledby="acc-display-trigger" hidden>
      <div class="row">
        <label for="pEdgeSoft">Randweichheit</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pEdgeSoft" data-bound="min" />
          <input id="pEdgeSoft" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pEdgeSoft" data-bound="max" />
          <div class="val" id="vEdgeSoft"></div>
        </div>
      </div>
      <div class="row">
        <label for="pBlending">Blending-Modus</label>
        <select id="pBlending">
          <option value="Normal">Normal</option>
          <option value="Additive">Additiv</option>
        </select>
      </div>
      <div class="row">
        <label><input id="pFilled" type="checkbox" /> Gefüllt (harte Kreise)</label>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-dynamics">
    <button type="button" class="accordion__trigger" id="acc-dynamics-trigger" aria-expanded="true" aria-controls="acc-dynamics-panel">
      Dynamik
    </button>
    <div class="accordion__panel" id="acc-dynamics-panel" role="region" aria-labelledby="acc-dynamics-trigger">
      <div class="row">
        <label for="pMotionMode">Bewegungsmodus</label>
        <select id="pMotionMode">
          <option value="static">Statisch</option>
          <option value="sine">Sinuswellen</option>
          <option value="noise">Noise</option>
          <option value="orbit">Orbit</option>
        </select>
      </div>
      <div class="row">
        <label for="pMotionSpeed">Bewegungsgeschwindigkeit</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionSpeed" data-bound="min" />
          <input id="pMotionSpeed" type="range" min="0" max="3" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionSpeed" data-bound="max" />
          <div class="val" id="vMotionSpeed"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionAmplitude">Amplitude</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionAmplitude" data-bound="min" />
          <input id="pMotionAmplitude" type="range" min="0" max="40" step="0.1" />
          <input class="bound-input" type="number" data-target="pMotionAmplitude" data-bound="max" />
          <div class="val" id="vMotionAmplitude"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionNoiseStrength">Noise-Intensität</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionNoiseStrength" data-bound="min" />
          <input id="pMotionNoiseStrength" type="range" min="0" max="2.5" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionNoiseStrength" data-bound="max" />
          <div class="val" id="vMotionNoiseStrength"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionNoiseScale">Noise-Skala</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionNoiseScale" data-bound="min" />
          <input id="pMotionNoiseScale" type="range" min="0.1" max="4" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionNoiseScale" data-bound="max" />
          <div class="val" id="vMotionNoiseScale"></div>
        </div>
      </div>
      <div class="row">
        <label>Rotation</label>
        <div class="wrap">
          <button id="autoSpin" aria-pressed="false">🌀 Auto-Rotation aus</button>
          <button id="spinStop" aria-disabled="true" disabled>⏹️ Stoppen</button>
        </div>
      </div>
      <div class="row">
        <label>Winkelgeschwindigkeit (rad/s)</label>
        <div class="stack">
          <div class="wrap">
            <span class="tag">X</span>
            <input class="bound-input" type="number" data-target="spinVelX" data-bound="min" />
            <input id="spinVelX" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelX" data-bound="max" />
            <div class="val" id="vSpinX"></div>
          </div>
          <div class="wrap">
            <span class="tag">Y</span>
            <input class="bound-input" type="number" data-target="spinVelY" data-bound="min" />
            <input id="spinVelY" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelY" data-bound="max" />
            <div class="val" id="vSpinY"></div>
          </div>
          <div class="wrap">
            <span class="tag">Z</span>
            <input class="bound-input" type="number" data-target="spinVelZ" data-bound="min" />
            <input id="spinVelZ" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelZ" data-bound="max" />
            <div class="val" id="vSpinZ"></div>
          </div>
        </div>
      </div>
      <div class="row">
        <label for="spinSpeed">Geschwindigkeitsfaktor</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="spinSpeed" data-bound="min" />
          <input id="spinSpeed" type="range" min="0" max="3" step="0.01" />
          <input class="bound-input" type="number" data-target="spinSpeed" data-bound="max" />
          <div class="val" id="vSpinSpeed"></div>
        </div>
      </div>
      <div class="row">
        <label>Trägheit</label>
        <div class="wrap">
          <button id="spinInertia" aria-pressed="true">🪁 Trägheit an</button>
          <div class="val" id="vInertia"></div>
        </div>
      </div>
      <div class="row">
        <label for="spinDecay">Abklingzeit (s)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="spinDecay" data-bound="min" />
          <input id="spinDecay" type="range" min="1" max="30" step="1" />
          <input class="bound-input" type="number" data-target="spinDecay" data-bound="max" />
          <div class="val" id="vSpinDecay"></div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-audio">
    <button type="button" class="accordion__trigger" id="acc-audio-trigger" aria-expanded="false" aria-controls="acc-audio-panel">
      Audio
    </button>
    <div class="accordion__panel" id="acc-audio-panel" role="region" aria-labelledby="acc-audio-trigger" hidden>
      <div class="row file-row">
        <label for="audioFile">Audio-Datei</label>
        <input id="audioFile" type="file" accept="audio/*" />
        <div class="file-meta" id="audioFileMeta">Kein Upload ausgewählt</div>
      </div>
      <div class="row">
        <div class="audio-controls">
          <button type="button" id="audioPlay" disabled>▶️ Abspielen</button>
          <button type="button" id="audioStop" disabled>⏹️ Stop</button>
        </div>
      </div>
      <div class="row">
        <label for="audioMicStart">Mikrofon</label>
        <div class="audio-controls">
          <button type="button" id="audioMicStart">🎙️ Start</button>
          <button type="button" id="audioMicStop" disabled>⏹️ Stop</button>
        </div>
      </div>
      <div class="row status-row" role="status" aria-live="polite">
        <span class="status-indicator" id="audioStatusDot" data-state="idle" aria-hidden="true"></span>
        <span class="status-text" id="audioStatus" data-state="idle">Audio-Reaktivität inaktiv</span>
      </div>
    </div>
  </section>
</div>
<script>
/* Utility: HSV→RGB (for potential future color variations) */
function hsv2rgb(h, s, v) {
  let c = v * s;
  let hp = h / 60;
  let x = c * (1 - Math.abs((hp % 2) - 1));
  let m = v - c;
  let r=0,g=0,b=0;
  if(hp < 1){r=c; g=x;} else
  if(hp < 2){r=x; g=c;} else
  if(hp < 3){g=c; b=x;} else
  if(hp < 4){g=x; b=c;} else
  if(hp < 5){r=x; b=c;} else{r=c; b=x;}
  return new THREE.Color(r+m,g+m,b+m);
}

/* PRNG: Mulberry32 for reproducible random */
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), 1 | t);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function damp(current, target, rate, delta) {
  const clampedRate = Math.max(0, rate);
  const frame = Math.max(0, delta);
  if (clampedRate === 0 || frame === 0) return current;
  const factor = 1 - Math.exp(-clampedRate * frame);
  return current + (target - current) * factor;
}

/* Renderer/Scene/Camera */
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0, 480);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.6;
controls.zoomSpeed = 0.6;

const clusterGroup = new THREE.Group();
scene.add(clusterGroup);

/* Parameters */
const params = {
  count: 2500,
  radius: 140,
  distribution: 'random',
  sizeVar: 4.0,
  cluster: 0.65,
  pointAlpha: 0.95,
  pointHue: 210,
  pointSaturation: 0.75,
  pointValue: 1.0,
  seedStars: 1,
  catSmallCount: 1125,
  catMediumCount: 875,
  catLargeCount: 500,
  // Size factors
  sizeFactorTiny: 0.15,
  sizeFactorSmall: 1.0,
  sizeFactorMedium: 1.5,
  sizeFactorLarge: 2.0,
  // Tiny points / connections
  tinyCount: 2000,
  connPercent: 0.5,
  tinyAlpha: 0.5,
  seedTiny: 1,
  // Edge & blending
  edgeSoftness: 0.6,
  blending: 'Normal',
  filled: false,
  // Motion
  motionMode: 'static',
  motionSpeed: 1.0,
  motionAmplitude: 8.0,
  motionNoiseStrength: 1.0,
  motionNoiseScale: 1.0
};

function clampTotalCount(value) {
  const numeric = Math.floor(Number(value) || 0);
  return Math.max(0, numeric);
}

const colorState = { point: new THREE.Color() };
const MOTION_MODES = ['static', 'sine', 'noise', 'orbit'];
const motionState = { time: 0 };

function getMotionModeIndex() {
  const idx = MOTION_MODES.indexOf(params.motionMode);
  return idx >= 0 ? idx : 0;
}

const AudioContextClass = window.AudioContext || window.webkitAudioContext || null;

const audioState = {
  context: null,
  analyser: null,
  freqData: null,
  timeData: null,
  source: null,
  micStream: null,
  playing: false,
  usingMic: false,
  selectedFile: null,
  fileName: '',
  status: 'idle',
  metrics: { energy: 0, bass: 0, mid: 0, treble: 0, wave: 0 },
  visual: { motion: 0, size: 1, hue: 0, alpha: 0, scale: 1 },
  color: new THREE.Color(),
  needsResume: false
};

const audioUI = {
  fileInput: null,
  fileMeta: null,
  playBtn: null,
  stopBtn: null,
  micStartBtn: null,
  micStopBtn: null,
  statusText: null,
  statusDot: null
};

const audioBandVector = new THREE.Vector3();

function isAudioSupported() {
  return !!AudioContextClass;
}

function isMicSupported() {
  return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
}

function ensureAudioContext() {
  if (!AudioContextClass) {
    throw new Error('Web Audio API nicht verfügbar');
  }
  if (!audioState.context) {
    audioState.context = new AudioContextClass();
  }
  return audioState.context;
}

function ensureAnalyser(context) {
  if (!audioState.analyser) {
    const analyser = context.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;
    audioState.analyser = analyser;
    audioState.freqData = new Uint8Array(analyser.frequencyBinCount);
    audioState.timeData = new Uint8Array(analyser.fftSize);
  }
  return audioState.analyser;
}

function decodeAudioBuffer(context, arrayBuffer) {
  return new Promise((resolve, reject) => {
    const maybePromise = context.decodeAudioData(arrayBuffer, resolve, reject);
    if (maybePromise && typeof maybePromise.then === 'function') {
      maybePromise.then(resolve, reject);
    }
  });
}

function resetAudioMetrics() {
  audioState.metrics.energy = 0;
  audioState.metrics.bass = 0;
  audioState.metrics.mid = 0;
  audioState.metrics.treble = 0;
  audioState.metrics.wave = 0;
  audioState.visual.motion = 0;
  audioState.visual.size = 1;
  audioState.visual.hue = 0;
  audioState.visual.alpha = 0;
  audioState.visual.scale = 1;
}

function disconnectAnalyser() {
  if (audioState.analyser) {
    try { audioState.analyser.disconnect(); } catch (err) { /* ignore */ }
  }
}

function stopAudioPlayback({ suspendContext = false } = {}) {
  if (audioState.source) {
    try { audioState.source.disconnect(); } catch (err) { /* ignore */ }
    if (typeof audioState.source.stop === 'function') {
      try { audioState.source.stop(); } catch (err) { /* ignore */ }
    }
  }
  audioState.source = null;
  if (audioState.micStream) {
    audioState.micStream.getTracks().forEach(track => track.stop());
  }
  audioState.micStream = null;
  audioState.playing = false;
  audioState.usingMic = false;
  disconnectAnalyser();
  if (audioState.context && suspendContext && typeof audioState.context.suspend === 'function') {
    audioState.context.suspend().catch(() => {});
  }
}

function setAudioStatus(message, state = 'idle') {
  audioState.status = state;
  if (audioUI.statusText) {
    audioUI.statusText.textContent = message;
    audioUI.statusText.dataset.state = state;
  }
  if (audioUI.statusDot) {
    audioUI.statusDot.dataset.state = state;
  }
}

function refreshAudioUI() {
  if (!audioUI.playBtn) return;
  const supportedAudio = isAudioSupported();
  const supportedMic = isMicSupported();
  if (audioUI.fileInput) {
    audioUI.fileInput.disabled = !supportedAudio;
  }
  audioUI.playBtn.disabled = !supportedAudio || !audioState.selectedFile || audioState.playing;
  if (audioUI.stopBtn) {
    audioUI.stopBtn.disabled = !supportedAudio || !audioState.playing;
  }
  if (audioUI.micStartBtn) {
    audioUI.micStartBtn.disabled = !supportedAudio || !supportedMic || audioState.playing;
  }
  if (audioUI.micStopBtn) {
    audioUI.micStopBtn.disabled = !supportedAudio || !audioState.playing || !audioState.usingMic;
  }
  if (!supportedAudio) {
    setAudioStatus('Web Audio API wird nicht unterstützt.', 'error');
  } else if (!supportedMic) {
    // only show info if mic UI exists and audio supported
    if (audioUI.micStartBtn) {
      audioUI.micStartBtn.title = 'Kein Mikrofonzugriff verfügbar';
    }
  } else if (audioUI.micStartBtn) {
    audioUI.micStartBtn.removeAttribute('title');
  }
}

function updateAudioFileMeta(file) {
  if (!audioUI.fileMeta) return;
  if (!file) {
    audioUI.fileMeta.textContent = 'Kein Upload ausgewählt';
    return;
  }
  const size = file.size || 0;
  let humanSize = '';
  if (size <= 0) {
    humanSize = '';
  } else if (size < 1024 * 1024) {
    humanSize = `${(size / 1024).toFixed(1)} KB`;
  } else {
    humanSize = `${(size / (1024 * 1024)).toFixed(2)} MB`;
  }
  const parts = [file.name || 'Audio'];
  if (humanSize) parts.push(humanSize);
  audioUI.fileMeta.textContent = parts.join(' · ');
}

async function playSelectedFile() {
  if (!audioState.selectedFile) {
    setAudioStatus('Bitte eine Audio-Datei auswählen.', 'waiting');
    return;
  }
  if (!isAudioSupported()) {
    setAudioStatus('Web Audio API wird nicht unterstützt.', 'error');
    return;
  }
  try {
    setAudioStatus('Lade Audio...', 'waiting');
    if (audioUI.playBtn) {
      audioUI.playBtn.disabled = true;
    }
    const context = ensureAudioContext();
    await context.resume();
    const analyser = ensureAnalyser(context);
    stopAudioPlayback();
    disconnectAnalyser();
    const arrayBuffer = await audioState.selectedFile.arrayBuffer();
    const buffer = await decodeAudioBuffer(context, arrayBuffer);
    const source = context.createBufferSource();
    source.buffer = buffer;
    source.onended = () => {
      if (audioState.source === source) {
        audioState.source = null;
        disconnectAnalyser();
        audioState.playing = false;
        setAudioStatus('Wiedergabe beendet', 'idle');
        refreshAudioUI();
      }
    };
    source.connect(analyser);
    analyser.connect(context.destination);
    source.start();
    audioState.source = source;
    audioState.playing = true;
    audioState.usingMic = false;
    audioState.fileName = audioState.selectedFile.name || 'Audio';
    setAudioStatus(`Wiedergabe läuft – ${audioState.fileName}`, 'active');
    refreshAudioUI();
  } catch (error) {
    console.error('Audio playback failed:', error);
    setAudioStatus('Fehler beim Laden der Datei.', 'error');
    stopAudioPlayback();
    refreshAudioUI();
  }
}

async function startMicrophone() {
  if (!isAudioSupported()) {
    setAudioStatus('Web Audio API wird nicht unterstützt.', 'error');
    return;
  }
  if (!isMicSupported()) {
    setAudioStatus('Mikrofon wird nicht unterstützt.', 'error');
    return;
  }
  try {
    setAudioStatus('Mikrofon wird gestartet…', 'waiting');
    if (audioUI.micStartBtn) {
      audioUI.micStartBtn.disabled = true;
    }
    const context = ensureAudioContext();
    await context.resume();
    const analyser = ensureAnalyser(context);
    stopAudioPlayback();
    disconnectAnalyser();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    const source = context.createMediaStreamSource(stream);
    source.connect(analyser);
    audioState.source = source;
    audioState.micStream = stream;
    audioState.playing = true;
    audioState.usingMic = true;
    setAudioStatus('Mikrofon aktiv – Live-Reaktion', 'active');
    refreshAudioUI();
  } catch (error) {
    console.error('Microphone start failed:', error);
    const denied = error && (error.name === 'NotAllowedError' || error.name === 'SecurityError');
    const msg = denied ? 'Mikrofon erfordert Freigabe.' : 'Mikrofon konnte nicht gestartet werden.';
    setAudioStatus(msg, 'error');
    stopAudioPlayback();
    refreshAudioUI();
  }
}

function stopAudioFromUser() {
  if (!audioState.playing && !audioState.micStream) {
    setAudioStatus('Audio-Reaktivität inaktiv', 'idle');
    refreshAudioUI();
    return;
  }
  stopAudioPlayback();
  setAudioStatus('Audio-Reaktivität inaktiv', 'idle');
  refreshAudioUI();
}

function updateAudioReactive(delta) {
  let energyTarget = 0;
  let bassTarget = 0;
  let midTarget = 0;
  let trebleTarget = 0;
  let waveTarget = 0;

  if (audioState.analyser && audioState.freqData && audioState.timeData) {
    const freqData = audioState.freqData;
    const len = freqData.length;
    if (len > 0) {
      let energySum = 0;
      for (let i = 0; i < len; i++) {
        const norm = freqData[i] / 255;
        energySum += norm * norm;
      }
      energyTarget = Math.min(1, Math.sqrt(energySum / len));
      const bassBins = Math.max(1, Math.round(len * 0.08));
      const midBins = Math.max(1, Math.round(len * 0.32));
      const trebleBins = Math.max(1, len - bassBins - midBins);
      const avgRange = (start, count) => {
        const available = Math.max(0, Math.min(len - start, count));
        if (available <= 0) return 0;
        let sum = 0;
        for (let i = 0; i < available; i++) {
          sum += freqData[start + i];
        }
        return (sum / (available * 255)) || 0;
      };
      bassTarget = avgRange(0, bassBins);
      midTarget = avgRange(bassBins, midBins);
      trebleTarget = avgRange(bassBins + midBins, trebleBins);
    }
    const timeData = audioState.timeData;
    const tLen = timeData.length;
    if (tLen > 0) {
      let waveSum = 0;
      for (let i = 0; i < tLen; i++) {
        const centered = (timeData[i] - 128) / 128;
        waveSum += Math.abs(centered);
      }
      waveTarget = Math.min(1, waveSum / tLen);
    }
  }

  const metricRate = audioState.playing ? 14 : 6;
  audioState.metrics.energy = damp(audioState.metrics.energy, energyTarget, metricRate, delta);
  audioState.metrics.bass = damp(audioState.metrics.bass, bassTarget, metricRate, delta);
  audioState.metrics.mid = damp(audioState.metrics.mid, midTarget, metricRate, delta);
  audioState.metrics.treble = damp(audioState.metrics.treble, trebleTarget, metricRate, delta);
  audioState.metrics.wave = damp(audioState.metrics.wave, waveTarget, metricRate, delta);

  const targetMotion = Math.min(2.4, audioState.metrics.energy * 1.1 + audioState.metrics.bass * 1.7);
  const targetSize = Math.min(1.9, 1 + audioState.metrics.mid * 1.1 + audioState.metrics.wave * 0.45);
  const targetScale = Math.min(2.2, 1 + audioState.metrics.energy * 0.45 + audioState.metrics.wave * 0.35 + audioState.metrics.bass * 0.25);
  const targetHue = audioState.metrics.treble * 90;
  const targetAlpha = Math.min(0.5, audioState.metrics.energy * 0.35 + audioState.metrics.wave * 0.2);

  audioState.visual.motion = damp(audioState.visual.motion, targetMotion, 6, delta);
  audioState.visual.size = damp(audioState.visual.size, targetSize, 7, delta);
  audioState.visual.scale = damp(audioState.visual.scale, targetScale, 5, delta);
  audioState.visual.hue = damp(audioState.visual.hue, targetHue, 3, delta);
  audioState.visual.alpha = damp(audioState.visual.alpha, targetAlpha, 6, delta);
}

function applyAudioVisuals(delta) {
  updateAudioReactive(delta);
  const sizeBoost = audioState.visual.size;
  const hue = (params.pointHue + audioState.visual.hue) % 360;
  const saturation = Math.min(1, params.pointSaturation + audioState.metrics.treble * 0.18);
  const brightness = Math.min(1.1, params.pointValue + audioState.metrics.energy * 0.25);
  const reactiveColor = hsv2rgb(hue, saturation, brightness);
  audioState.color.copy(reactiveColor);

  const sphereScale = Math.max(0.35, Math.min(2.2, audioState.visual.scale));
  if (Number.isFinite(sphereScale)) {
    if (Math.abs(clusterGroup.scale.x - sphereScale) > 1e-4 ||
        Math.abs(clusterGroup.scale.y - sphereScale) > 1e-4 ||
        Math.abs(clusterGroup.scale.z - sphereScale) > 1e-4) {
      clusterGroup.scale.setScalar(sphereScale);
    }
  }

  audioBandVector.set(audioState.metrics.bass, audioState.metrics.mid, audioState.metrics.treble);

  if (starMaterial && starMaterial.uniforms) {
    if (starMaterial.uniforms.uAudioBands && starMaterial.uniforms.uAudioBands.value) {
      starMaterial.uniforms.uAudioBands.value.copy(audioBandVector);
    }
    if (starMaterial.uniforms.uAudioEnergy) {
      starMaterial.uniforms.uAudioEnergy.value = audioState.metrics.energy;
    }
    if (starMaterial.uniforms.uAudioWave) {
      starMaterial.uniforms.uAudioWave.value = audioState.metrics.wave;
    }
    if (starMaterial.uniforms.uSizeFactorSmall) {
      starMaterial.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall * sizeBoost;
    }
    if (starMaterial.uniforms.uSizeFactorMedium) {
      starMaterial.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium * sizeBoost;
    }
    if (starMaterial.uniforms.uSizeFactorLarge) {
      starMaterial.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge * sizeBoost;
    }
    if (starMaterial.uniforms.uAlpha) {
      const baseAlpha = params.pointAlpha;
      const boostedAlpha = Math.max(0.05, Math.min(1, baseAlpha + audioState.visual.alpha));
      starMaterial.uniforms.uAlpha.value = boostedAlpha;
    }
    if (starMaterial.uniforms.uColor) {
      starMaterial.uniforms.uColor.value.copy(audioState.color);
    }
  }

  if (tinyMaterial && tinyMaterial.uniforms) {
    if (tinyMaterial.uniforms.uAudioBands && tinyMaterial.uniforms.uAudioBands.value) {
      tinyMaterial.uniforms.uAudioBands.value.copy(audioBandVector);
    }
    if (tinyMaterial.uniforms.uAudioEnergy) {
      tinyMaterial.uniforms.uAudioEnergy.value = audioState.metrics.energy;
    }
    if (tinyMaterial.uniforms.uAudioWave) {
      tinyMaterial.uniforms.uAudioWave.value = audioState.metrics.wave;
    }
    const tinySize = params.sizeFactorTiny * Math.max(0.05, 0.8 + sizeBoost * 0.2 + audioState.metrics.wave * 0.35);
    if (tinyMaterial.uniforms.uSize) {
      tinyMaterial.uniforms.uSize.value = tinySize;
    }
    if (tinyMaterial.uniforms.uAlpha) {
      const baseTinyAlpha = params.tinyAlpha;
      const boostedTinyAlpha = Math.min(1, baseTinyAlpha + audioState.visual.alpha * 0.4);
      tinyMaterial.uniforms.uAlpha.value = boostedTinyAlpha;
    }
    if (tinyMaterial.uniforms.uColor) {
      tinyMaterial.uniforms.uColor.value.copy(audioState.color);
    }
  }

  const extraRotation = audioState.visual.motion;
  if (extraRotation > 1e-4) {
    const yaw = extraRotation * delta * 0.85;
    const pitch = audioState.metrics.wave * delta * 0.35;
    if (Number.isFinite(yaw) && Math.abs(yaw) < Math.PI) {
      clusterGroup.rotateY(yaw);
    }
    if (Number.isFinite(pitch) && Math.abs(pitch) < Math.PI) {
      clusterGroup.rotateX(pitch);
    }
  }
}

/* Globals for stars and tiny connections */
let starPoints, starGeometry, starMaterial;
let tinyPoints, tinyGeometry, tinyMaterial;

function disposeTinyResources() {
  if (tinyPoints) {
    clusterGroup.remove(tinyPoints);
    tinyPoints = undefined;
  }
  if (tinyGeometry) {
    tinyGeometry.dispose();
    tinyGeometry = undefined;
  }
  if (tinyMaterial) {
    tinyMaterial.dispose();
    tinyMaterial = undefined;
  }
}

function updatePointColor(applyUniforms = true) {
  const hue = ((params.pointHue % 360) + 360) % 360;
  const saturation = Math.max(0, Math.min(1, params.pointSaturation));
  const value = Math.max(0, Math.min(1, params.pointValue));
  const next = hsv2rgb(hue, saturation, value);
  colorState.point.copy(next);
  if (!applyUniforms) return;
  if (starMaterial && starMaterial.uniforms && starMaterial.uniforms.uColor) {
    starMaterial.uniforms.uColor.value.copy(colorState.point);
    starMaterial.needsUpdate = true;
  }
  if (tinyMaterial && tinyMaterial.uniforms && tinyMaterial.uniforms.uColor) {
    tinyMaterial.uniforms.uColor.value.copy(colorState.point);
    tinyMaterial.needsUpdate = true;
  }
}

/* Create stars geometry and material */
function makeStars() {
  if (starPoints) {
    starGeometry.dispose();
    starMaterial.dispose();
    clusterGroup.remove(starPoints);
  }
  const smallCount = Math.max(0, Math.floor(Number(params.catSmallCount) || 0));
  const mediumCount = Math.max(0, Math.floor(Number(params.catMediumCount) || 0));
  const largeCount = Math.max(0, Math.floor(Number(params.catLargeCount) || 0));
  const total = clampTotalCount(smallCount + mediumCount + largeCount);
  params.count = total;
  if (total <= 0) {
    starGeometry = new THREE.BufferGeometry();
    starMaterial = null;
    starPoints = null;
    return;
  }
  starGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(total * 3);
  const basePositions = new Float32Array(total * 3);
  const phases = new Float32Array(total);
  const sizes = new Float32Array(total);
  const cats  = new Float32Array(total);
  // thresholds for categories based on counts
  const smallShare = total > 0 ? smallCount / total : 0;
  const mediumShare = total > 0 ? mediumCount / total : 0;
  const mediumThreshold = Math.min(1, smallShare + mediumShare);
  const minSize = Math.max(0.05, 1 - params.sizeVar * 0.5);
  const maxSize = 1 + params.sizeVar * 0.5;
  const span = Math.max(0.0001, maxSize - minSize);
  const smallEnd = minSize + span * smallShare;
  const mediumEnd = minSize + span * mediumThreshold;
  // seeded random for star distribution
  const rand = mulberry32(params.seedStars);
  const phaseRand = mulberry32((params.seedStars ^ 0x51f32a95) >>> 0);
  const catRand = mulberry32(params.seedStars + 0x9e3779b9);
  const categoryPool = [];
  for (let i = 0; i < smallCount; i++) categoryPool.push(0);
  for (let i = 0; i < mediumCount; i++) categoryPool.push(1);
  for (let i = 0; i < largeCount; i++) categoryPool.push(2);
  for (let i = categoryPool.length - 1; i > 0; i--) {
    const j = Math.floor(catRand() * (i + 1));
    const tmp = categoryPool[i];
    categoryPool[i] = categoryPool[j];
    categoryPool[j] = tmp;
  }
  const orientation = new THREE.Matrix4();
  const orientEuler = new THREE.Euler(rand() * Math.PI * 2, rand() * Math.PI * 2, rand() * Math.PI * 2);
  orientation.makeRotationFromEuler(orientEuler);
  const tmpVec = new THREE.Vector3();
  const fibOffset = (params.distribution === 'fibonacci' && total > 0) ? (2 / total) : 0;
  const fibIncrement = Math.PI * (3 - Math.sqrt(5));
  const spiralArms = 4;
  for (let i = 0; i < total; i++) {
    let x = 0, y = 0, z = 0;
    const radius = params.radius;
    if (params.distribution === 'fibonacci') {
      const yv = ((i + 0.5) * fibOffset) - 1;
      const clampedY = Math.max(-1, Math.min(1, yv));
      const rCircle = Math.sqrt(Math.max(0, 1 - clampedY * clampedY));
      const phi = i * fibIncrement;
      const bias = params.cluster > 0 ? Math.pow(rand(), 1 + params.cluster * 2.2) : rand();
      const radial = radius * (0.35 + 0.65 * bias);
      x = Math.cos(phi) * rCircle * radial;
      y = clampedY * radial;
      z = Math.sin(phi) * rCircle * radial;
      x += (rand() - 0.5) * radius * 0.04;
      y += (rand() - 0.5) * radius * 0.04;
      z += (rand() - 0.5) * radius * 0.04;
      tmpVec.set(x, y, z).applyMatrix4(orientation);
      x = tmpVec.x; y = tmpVec.y; z = tmpVec.z;
    } else if (params.distribution === 'spiral') {
      const t = total > 0 ? (i / total) : 0;
      const arm = i % spiralArms;
      const baseAngle = t * Math.PI * 6 + arm * (Math.PI * 2 / spiralArms);
      const spread = radius * Math.pow(rand(), 0.55 + params.cluster * 0.9);
      x = Math.cos(baseAngle) * spread;
      z = Math.sin(baseAngle) * spread;
      y = (rand() - 0.5) * radius * (0.2 + 0.4 * (1 - params.cluster));
      x += (rand() - 0.5) * radius * 0.08;
      y += (rand() - 0.5) * radius * 0.08;
      z += (rand() - 0.5) * radius * 0.08;
      tmpVec.set(x, y, z).applyMatrix4(orientation);
      x = tmpVec.x; y = tmpVec.y; z = tmpVec.z;
    } else {
      const u = rand();
      const v = rand();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      let r = radius;
      if (rand() < params.cluster) {
        r *= rand();
      }
      x = r * Math.sin(phi) * Math.cos(theta);
      y = r * Math.sin(phi) * Math.sin(theta);
      z = r * Math.cos(phi);
    }
    positions.set([x, y, z], i * 3);
    basePositions.set([x, y, z], i * 3);
    const cat = categoryPool[i] !== undefined ? categoryPool[i] : 2;
    cats[i] = cat;
    let lower = mediumEnd;
    let upper = maxSize;
    if (cat === 0) {
      lower = minSize;
      upper = smallEnd;
    } else if (cat === 1) {
      lower = smallEnd;
      upper = mediumEnd;
    }
    if (upper - lower < 0.001) {
      sizes[i] = lower;
    } else {
      sizes[i] = lower + rand() * (upper - lower);
    }
    phases[i] = phaseRand();
  }
  const positionAttr = new THREE.BufferAttribute(positions, 3);
  const baseAttr = new THREE.BufferAttribute(basePositions, 3);
  const phaseAttr = new THREE.BufferAttribute(phases, 1);
  starGeometry.setAttribute('position', positionAttr);
  starGeometry.setAttribute('aBase', baseAttr);
  starGeometry.setAttribute('aPhase', phaseAttr);
  starGeometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
  starGeometry.setAttribute('aCat', new THREE.BufferAttribute(cats, 1));
  starGeometry.computeBoundingSphere();
  if (starGeometry.boundingSphere) {
    const center = starGeometry.boundingSphere.center.clone();
    if (center.lengthSq() > 1e-6) {
      for (let i = 0; i < positionAttr.count; i++) {
        positionAttr.setXYZ(
          i,
          positionAttr.getX(i) - center.x,
          positionAttr.getY(i) - center.y,
          positionAttr.getZ(i) - center.z
        );
        baseAttr.setXYZ(
          i,
          baseAttr.getX(i) - center.x,
          baseAttr.getY(i) - center.y,
          baseAttr.getZ(i) - center.z
        );
      }
      positionAttr.needsUpdate = true;
      baseAttr.needsUpdate = true;
      starGeometry.boundingSphere.center.set(0, 0, 0);
      controls.target.copy(clusterGroup.position);
    }
  }
  // Vertex shader for stars
  const starVert = `
    attribute float aSize;
    attribute float aCat;
    attribute vec3 aBase;
    attribute float aPhase;
    varying float vDepth;
    uniform float uSizeFactorSmall;
    uniform float uSizeFactorMedium;
    uniform float uSizeFactorLarge;
    uniform float uTime;
    uniform float uMotionMode;
    uniform float uMotionSpeed;
    uniform float uMotionAmplitude;
    uniform float uNoiseStrength;
    uniform float uNoiseScale;
    uniform vec3 uAudioBands;
    uniform float uAudioEnergy;
    uniform float uAudioWave;

    float hash3(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float valueNoise(vec3 p) {
      vec3 i = floor(p);
      vec3 f = fract(p);
      float n000 = hash3(i + vec3(0.0, 0.0, 0.0));
      float n100 = hash3(i + vec3(1.0, 0.0, 0.0));
      float n010 = hash3(i + vec3(0.0, 1.0, 0.0));
      float n110 = hash3(i + vec3(1.0, 1.0, 0.0));
      float n001 = hash3(i + vec3(0.0, 0.0, 1.0));
      float n101 = hash3(i + vec3(1.0, 0.0, 1.0));
      float n011 = hash3(i + vec3(0.0, 1.0, 1.0));
      float n111 = hash3(i + vec3(1.0, 1.0, 1.0));
      vec3 u = f * f * (3.0 - 2.0 * f);
      float nx00 = mix(n000, n100, u.x);
      float nx10 = mix(n010, n110, u.x);
      float nx01 = mix(n001, n101, u.x);
      float nx11 = mix(n011, n111, u.x);
      float nxy0 = mix(nx00, nx10, u.y);
      float nxy1 = mix(nx01, nx11, u.y);
      return mix(nxy0, nxy1, u.z);
    }

    vec3 applyAudioReactive(vec3 pos) {
      float radius = length(pos);
      if (radius < 1e-4) {
        return pos;
      }
      float bandMix = dot(uAudioBands, vec3(0.65, 0.28, 0.12));
      float wavePulse = uAudioWave * 0.7;
      float energyPulse = uAudioEnergy * 0.45;
      float ripple = sin(uTime * 4.0 + aPhase * 12.5663706) * (0.2 + wavePulse * 0.6);
      float scale = 1.0 + bandMix * 0.3 + energyPulse * 0.25 + wavePulse * 0.25;
      float newRadius = max(0.05, radius * scale + ripple * 10.0);
      vec3 radial = normalize(pos);
      return radial * newRadius;
    }

    vec3 applyMotion(vec3 base) {
      float mode = uMotionMode;
      float time = uTime * uMotionSpeed;
      if (mode < 0.5) {
        return base;
      } else if (mode < 1.5) {
        float phase = aPhase * 6.2831853;
        vec3 offset = vec3(
          sin(time + phase + base.x * 0.015),
          sin(time * 0.8 + phase * 1.3 + base.y * 0.02),
          sin(time * 1.2 + phase * 0.7 + base.z * 0.017)
        );
        return base + offset * uMotionAmplitude;
      } else if (mode < 2.5) {
        float scale = max(0.0001, uNoiseScale);
        vec3 samplePos = base * (0.01 * scale);
        float tx = valueNoise(vec3(samplePos.xy, time * 0.35 + aPhase));
        float ty = valueNoise(vec3(samplePos.yz, time * 0.35 + aPhase * 1.7));
        float tz = valueNoise(vec3(samplePos.zx, time * 0.35 + aPhase * 2.3));
        vec3 offset = vec3(tx, ty, tz) * 2.0 - 1.0;
        offset *= uMotionAmplitude * uNoiseStrength;
        return base + offset;
      } else {
        float phase = aPhase * 6.2831853;
        float angle = time * 0.6 + phase * 0.25;
        vec2 xz = base.xz;
        float radius = length(xz);
        float radial = max(0.0, radius + sin(time * 0.4 + phase) * uMotionAmplitude * 0.25);
        float c = cos(angle);
        float s = sin(angle);
        vec2 rotated = vec2(
          xz.x * c - xz.y * s,
          xz.x * s + xz.y * c
        );
        if (radial > 1e-4 && length(rotated) > 1e-5) {
          rotated = normalize(rotated) * radial;
        } else {
          rotated = vec2(radial * cos(angle), radial * sin(angle));
        }
        float yOffset = sin(time * 0.5 + phase * 0.5) * uMotionAmplitude * 0.3;
        return vec3(rotated.x, base.y + yOffset, rotated.y);
      }
    }

    void main() {
      vec3 animated = applyMotion(aBase);
      vec3 audioDriven = applyAudioReactive(animated);
      vec4 mv = modelViewMatrix * vec4(audioDriven, 1.0);
      vDepth = -mv.z;
      float factor;
      if (aCat < 0.5) {
        factor = uSizeFactorSmall;
      } else if (aCat < 1.5) {
        factor = uSizeFactorMedium;
      } else {
        factor = uSizeFactorLarge;
      }
      gl_PointSize = aSize * factor * 4.0 * (300.0 / max(1.0, vDepth));
      gl_Position = projectionMatrix * mv;
    }
  `;
  // Fragment shader for stars
  const starFrag = `
    precision highp float;
    uniform float uAlpha;
    uniform float uEdgeSoftness;
    uniform vec3 uColor;
    void main() {
      vec2 uv = gl_PointCoord * 2.0 - 1.0;
      float d = dot(uv, uv);
      if (d > 1.0) discard;
      // compute inner radius where the point is fully opaque
      float inner = 1.0 - uEdgeSoftness;
      // fade alpha near the outer edge: inside 'inner' radius alpha=1, outside alpha decreases to 0 at the rim
      float edge = 1.0 - smoothstep(inner, 1.0, d);
      gl_FragColor = vec4(uColor, edge * uAlpha);
    }
  `;
  starMaterial = new THREE.ShaderMaterial({
    vertexShader: starVert,
    fragmentShader: starFrag,
    transparent: true,
    depthTest: true,
    // disable depthWrite so points blend properly and do not occlude each other completely
    depthWrite: false,
    uniforms: {
      uAlpha: { value: params.pointAlpha },
      uEdgeSoftness: { value: params.filled ? 0.0 : params.edgeSoftness },
      uSizeFactorSmall: { value: params.sizeFactorSmall },
      uSizeFactorMedium: { value: params.sizeFactorMedium },
      uSizeFactorLarge: { value: params.sizeFactorLarge },
      uTime: { value: motionState.time },
      uMotionMode: { value: getMotionModeIndex() },
      uMotionSpeed: { value: params.motionSpeed },
      uMotionAmplitude: { value: params.motionAmplitude },
      uNoiseStrength: { value: params.motionNoiseStrength },
      uNoiseScale: { value: params.motionNoiseScale },
      uAudioBands: { value: new THREE.Vector3() },
      uAudioEnergy: { value: 0 },
      uAudioWave: { value: 0 },
      uColor: { value: colorState.point.clone() }
    }
  });
  starMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  starPoints = new THREE.Points(starGeometry, starMaterial);
  clusterGroup.add(starPoints);
}

/* Create tiny connection points */
function makeTiny() {
  disposeTinyResources();
  // Determine number of tiny points based on connPercent
  const nTiny = Math.round(params.tinyCount * params.connPercent);
  // Access star positions for connections
  const starPos = (starGeometry && starGeometry.getAttribute) ? starGeometry.getAttribute('position') : null;
  const nStars = starPos ? starPos.count : 0;
  if (!starPos || nStars === 0 || nTiny <= 0) {
    tinyPoints = undefined;
    return;
  }

  tinyGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(Math.max(0, nTiny * 3));
  const basePositions = new Float32Array(Math.max(0, nTiny * 3));
  const phases = new Float32Array(Math.max(0, nTiny));
  if (nTiny > 0 && nStars > 0) {
    const rand = mulberry32(params.seedTiny);
    const phaseRand = mulberry32((params.seedTiny ^ 0x9e3779b9) >>> 0);
    for (let i = 0; i < nTiny; i++) {
      // pick two random stars
      const idxA = Math.floor(rand() * nStars);
      const idxB = Math.floor(rand() * nStars);
      const ax = starPos.getX(idxA), ay = starPos.getY(idxA), az = starPos.getZ(idxA);
      const bx = starPos.getX(idxB), by = starPos.getY(idxB), bz = starPos.getZ(idxB);
      const t = rand();
      // linear interpolation between stars
      const x = ax + (bx - ax) * t;
      const y = ay + (by - ay) * t;
      const z = az + (bz - az) * t;
      positions.set([x, y, z], i * 3);
      basePositions.set([x, y, z], i * 3);
      phases[i] = phaseRand();
    }
  }
  tinyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  tinyGeometry.setAttribute('aBase', new THREE.BufferAttribute(basePositions, 3));
  tinyGeometry.setAttribute('aPhase', new THREE.BufferAttribute(phases, 1));
  const tinyVert = `
    attribute vec3 aBase;
    attribute float aPhase;
    uniform float uSize;
    uniform float uTime;
    uniform float uMotionMode;
    uniform float uMotionSpeed;
    uniform float uMotionAmplitude;
    uniform float uNoiseStrength;
    uniform float uNoiseScale;
    uniform vec3 uAudioBands;
    uniform float uAudioEnergy;
    uniform float uAudioWave;
    varying float vDepth;

    float hash3(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float valueNoise(vec3 p) {
      vec3 i = floor(p);
      vec3 f = fract(p);
      float n000 = hash3(i + vec3(0.0, 0.0, 0.0));
      float n100 = hash3(i + vec3(1.0, 0.0, 0.0));
      float n010 = hash3(i + vec3(0.0, 1.0, 0.0));
      float n110 = hash3(i + vec3(1.0, 1.0, 0.0));
      float n001 = hash3(i + vec3(0.0, 0.0, 1.0));
      float n101 = hash3(i + vec3(1.0, 0.0, 1.0));
      float n011 = hash3(i + vec3(0.0, 1.0, 1.0));
      float n111 = hash3(i + vec3(1.0, 1.0, 1.0));
      vec3 u = f * f * (3.0 - 2.0 * f);
      float nx00 = mix(n000, n100, u.x);
      float nx10 = mix(n010, n110, u.x);
      float nx01 = mix(n001, n101, u.x);
      float nx11 = mix(n011, n111, u.x);
      float nxy0 = mix(nx00, nx10, u.y);
      float nxy1 = mix(nx01, nx11, u.y);
      return mix(nxy0, nxy1, u.z);
    }

    vec3 applyAudioReactive(vec3 pos) {
      float radius = length(pos);
      if (radius < 1e-4) {
        return pos;
      }
      float bandMix = dot(uAudioBands, vec3(0.6, 0.3, 0.15));
      float wavePulse = uAudioWave * 0.6;
      float energyPulse = uAudioEnergy * 0.35;
      float ripple = sin(uTime * 4.2 + aPhase * 12.5663706) * (0.15 + wavePulse * 0.55);
      float scale = 1.0 + bandMix * 0.25 + energyPulse * 0.2 + wavePulse * 0.25;
      float newRadius = max(0.02, radius * scale + ripple * 6.0);
      vec3 radial = normalize(pos);
      return radial * newRadius;
    }

    vec3 applyMotion(vec3 base) {
      float mode = uMotionMode;
      float time = uTime * uMotionSpeed;
      if (mode < 0.5) {
        return base;
      } else if (mode < 1.5) {
        float phase = aPhase * 6.2831853;
        vec3 offset = vec3(
          sin(time + phase + base.x * 0.015),
          sin(time * 0.8 + phase * 1.3 + base.y * 0.02),
          sin(time * 1.2 + phase * 0.7 + base.z * 0.017)
        );
        return base + offset * uMotionAmplitude;
      } else if (mode < 2.5) {
        float scale = max(0.0001, uNoiseScale);
        vec3 samplePos = base * (0.01 * scale);
        float tx = valueNoise(vec3(samplePos.xy, time * 0.35 + aPhase));
        float ty = valueNoise(vec3(samplePos.yz, time * 0.35 + aPhase * 1.7));
        float tz = valueNoise(vec3(samplePos.zx, time * 0.35 + aPhase * 2.3));
        vec3 offset = vec3(tx, ty, tz) * 2.0 - 1.0;
        offset *= uMotionAmplitude * uNoiseStrength;
        return base + offset;
      } else {
        float phase = aPhase * 6.2831853;
        float angle = time * 0.6 + phase * 0.25;
        vec2 xz = base.xz;
        float radius = length(xz);
        float radial = max(0.0, radius + sin(time * 0.4 + phase) * uMotionAmplitude * 0.25);
        float c = cos(angle);
        float s = sin(angle);
        vec2 rotated = vec2(
          xz.x * c - xz.y * s,
          xz.x * s + xz.y * c
        );
        if (radial > 1e-4 && length(rotated) > 1e-5) {
          rotated = normalize(rotated) * radial;
        } else {
          rotated = vec2(radial * cos(angle), radial * sin(angle));
        }
        float yOffset = sin(time * 0.5 + phase * 0.5) * uMotionAmplitude * 0.3;
        return vec3(rotated.x, base.y + yOffset, rotated.y);
      }
    }

    void main() {
      vec3 animated = applyMotion(aBase);
      vec3 audioDriven = applyAudioReactive(animated);
      vec4 mv = modelViewMatrix * vec4(audioDriven, 1.0);
      vDepth = -mv.z;
      float px = max(1.0, uSize * 6.0);
      gl_PointSize = px * (300.0 / max(1.0, vDepth));
      gl_Position = projectionMatrix * mv;
    }
  `;
  const tinyFrag = `
    precision highp float;
    uniform float uAlpha;
    uniform vec3 uColor;
    void main() {
      vec2 uv = gl_PointCoord * 2.0 - 1.0;
      float d = dot(uv, uv);
      if (d > 1.0) discard;
      float fade = 1.0 - smoothstep(0.6, 1.0, d);
      gl_FragColor = vec4(uColor, fade * uAlpha);
    }
  `;
  tinyMaterial = new THREE.ShaderMaterial({
    vertexShader: tinyVert,
    fragmentShader: tinyFrag,
    transparent: true,
    depthTest: true,
    depthWrite: false,
    uniforms: {
      uAlpha: { value: params.tinyAlpha },
      uSize: { value: params.sizeFactorTiny },
      uTime: { value: motionState.time },
      uMotionMode: { value: getMotionModeIndex() },
      uMotionSpeed: { value: params.motionSpeed },
      uMotionAmplitude: { value: params.motionAmplitude },
      uNoiseStrength: { value: params.motionNoiseStrength },
      uNoiseScale: { value: params.motionNoiseScale },
      uAudioBands: { value: new THREE.Vector3() },
      uAudioEnergy: { value: 0 },
      uAudioWave: { value: 0 },
      uColor: { value: colorState.point.clone() }
    }
  });
  tinyMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  tinyPoints = new THREE.Points(tinyGeometry, tinyMaterial);
  clusterGroup.add(tinyPoints);
}

/* Update uniforms and materials when parameters change */
function updateStarUniforms() {
  if (!starMaterial) return;
  starMaterial.uniforms.uAlpha.value = params.pointAlpha;
  starMaterial.uniforms.uEdgeSoftness.value = params.filled ? 0.0 : params.edgeSoftness;
  starMaterial.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall;
  starMaterial.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium;
  starMaterial.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge;
  if (starMaterial.uniforms.uTime) {
    starMaterial.uniforms.uTime.value = motionState.time;
  }
  if (starMaterial.uniforms.uMotionMode) {
    starMaterial.uniforms.uMotionMode.value = getMotionModeIndex();
  }
  if (starMaterial.uniforms.uMotionSpeed) {
    starMaterial.uniforms.uMotionSpeed.value = params.motionSpeed;
  }
  if (starMaterial.uniforms.uMotionAmplitude) {
    starMaterial.uniforms.uMotionAmplitude.value = params.motionAmplitude;
  }
  if (starMaterial.uniforms.uNoiseStrength) {
    starMaterial.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
  }
  if (starMaterial.uniforms.uNoiseScale) {
    starMaterial.uniforms.uNoiseScale.value = params.motionNoiseScale;
  }
  if (starMaterial.uniforms.uColor) {
    starMaterial.uniforms.uColor.value.copy(colorState.point);
  }
  starMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  starMaterial.needsUpdate = true;
}

function updateTinyMaterial() {
  if (!tinyMaterial) return;
  tinyMaterial.uniforms.uAlpha.value = params.tinyAlpha;
  tinyMaterial.uniforms.uSize.value = params.sizeFactorTiny;
  if (tinyMaterial.uniforms.uTime) {
    tinyMaterial.uniforms.uTime.value = motionState.time;
  }
  if (tinyMaterial.uniforms.uMotionMode) {
    tinyMaterial.uniforms.uMotionMode.value = getMotionModeIndex();
  }
  if (tinyMaterial.uniforms.uMotionSpeed) {
    tinyMaterial.uniforms.uMotionSpeed.value = params.motionSpeed;
  }
  if (tinyMaterial.uniforms.uMotionAmplitude) {
    tinyMaterial.uniforms.uMotionAmplitude.value = params.motionAmplitude;
  }
  if (tinyMaterial.uniforms.uNoiseStrength) {
    tinyMaterial.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
  }
  if (tinyMaterial.uniforms.uNoiseScale) {
    tinyMaterial.uniforms.uNoiseScale.value = params.motionNoiseScale;
  }
  if (tinyMaterial.uniforms.uColor) {
    tinyMaterial.uniforms.uColor.value.copy(colorState.point);
  }
  tinyMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  tinyMaterial.needsUpdate = true;
}

/* Rebuild functions */
function rebuildStars() {
  makeStars();
  updateStarUniforms();
  // regenerate tiny connections as they depend on star positions
  makeTiny();
  updateTinyMaterial();
}
function rebuildTiny() {
  makeTiny();
  updateTinyMaterial();
}

/* Bind UI elements */
const $ = id => document.getElementById(id);
const panel = $('panel');
const toggleBtn = $('toggle');
const lockBtn = $('lock');
const sheetHandleBtn = $('sheetHandle');
const mobileSheetQuery = window.matchMedia('(max-width: 768px)');
const sheetState = {
  mode: 'compact',
  expandedHeight: 0,
  compactHeight: 0,
  pointerId: null,
  startY: 0,
  startOffset: 0,
  lastOffset: 0,
  moved: false,
  preventClick: false,
};

audioUI.fileInput = $('audioFile');
audioUI.fileMeta = $('audioFileMeta');
audioUI.playBtn = $('audioPlay');
audioUI.stopBtn = $('audioStop');
audioUI.micStartBtn = $('audioMicStart');
audioUI.micStopBtn = $('audioMicStop');
audioUI.statusText = $('audioStatus');
audioUI.statusDot = $('audioStatusDot');

if (audioUI.fileInput) {
  audioUI.fileInput.addEventListener('change', event => {
    const files = event.target.files;
    const file = files && files.length ? files[0] : null;
    audioState.selectedFile = file;
    audioState.fileName = file ? (file.name || 'Audio') : '';
    updateAudioFileMeta(file);
    if (file) {
      setAudioStatus('Datei geladen – Abspielen möglich', 'waiting');
    } else if (!audioState.playing) {
      setAudioStatus('Audio-Reaktivität inaktiv', 'idle');
    }
    refreshAudioUI();
  });
}

if (audioUI.playBtn) {
  audioUI.playBtn.addEventListener('click', () => {
    playSelectedFile();
  });
}

if (audioUI.stopBtn) {
  audioUI.stopBtn.addEventListener('click', () => {
    stopAudioFromUser();
  });
}

if (audioUI.micStartBtn) {
  audioUI.micStartBtn.addEventListener('click', () => {
    startMicrophone();
  });
}

if (audioUI.micStopBtn) {
  audioUI.micStopBtn.addEventListener('click', () => {
    stopAudioFromUser();
  });
}

if (audioUI.fileMeta) {
  updateAudioFileMeta(audioState.selectedFile);
}
setAudioStatus('Audio-Reaktivität inaktiv', 'idle');
refreshAudioUI();
let panelVisible = true;
let cameraLocked = false;

function isMobileSheetActive() {
  return mobileSheetQuery.matches;
}

function getSheetCompactOffset() {
  return Math.max(0, sheetState.expandedHeight - sheetState.compactHeight);
}

function updateSheetHandleAria() {
  if (!sheetHandleBtn) return;
  if (!isMobileSheetActive()) {
    sheetHandleBtn.setAttribute('tabindex', '-1');
    sheetHandleBtn.setAttribute('aria-expanded', 'false');
    sheetHandleBtn.setAttribute('aria-hidden', 'true');
    sheetHandleBtn.style.pointerEvents = 'none';
    const label = 'Panel vergrößern';
    sheetHandleBtn.setAttribute('aria-label', label);
    const labelSpan = sheetHandleBtn.querySelector('.sheet-handle-label');
    if (labelSpan) labelSpan.textContent = label;
    return;
  }
  sheetHandleBtn.style.pointerEvents = '';
  sheetHandleBtn.removeAttribute('aria-hidden');
  sheetHandleBtn.setAttribute('tabindex', '0');
  const expanded = panelVisible && sheetState.mode === 'expanded';
  const label = expanded ? 'Panel verkleinern' : 'Panel vergrößern';
  sheetHandleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  sheetHandleBtn.setAttribute('aria-label', label);
  const labelSpan = sheetHandleBtn.querySelector('.sheet-handle-label');
  if (labelSpan) labelSpan.textContent = label;
}

function applySheetOffset() {
  if (!isMobileSheetActive()) {
    panel.style.removeProperty('--sheet-offset');
    sheetState.lastOffset = 0;
    return;
  }
  const compactOffset = getSheetCompactOffset();
  let offset = sheetState.mode === 'expanded' ? 0 : compactOffset;
  if (!panelVisible) {
    offset = compactOffset;
  }
  sheetState.lastOffset = offset;
  panel.style.setProperty('--sheet-offset', `${Math.max(0, Math.round(offset))}px`);
}

function setSheetMode(mode, options = {}) {
  const next = mode === 'expanded' ? 'expanded' : 'compact';
  if (sheetState.mode === next && !options.force) return;
  sheetState.mode = next;
  panel.dataset.sheetState = next;
  applySheetOffset();
  updateSheetHandleAria();
}

function recalculateSheetMetrics() {
  if (!isMobileSheetActive()) {
    sheetState.expandedHeight = 0;
    sheetState.compactHeight = 0;
    panel.style.removeProperty('--sheet-expanded-height');
    panel.style.removeProperty('--sheet-compact-height');
    panel.removeAttribute('data-sheet-state');
    applySheetOffset();
    updateSheetHandleAria();
    return;
  }
  const vh = Math.max(window.innerHeight || 0, 0);
  const minSceneHeight = Math.max(0, Math.round(vh * 0.5));
  const allowed = Math.max(0, vh - minSceneHeight);
  const baseCompact = Math.max(0, Math.round(vh * 0.3));
  let compact = Math.max(baseCompact, 140);
  if (allowed > 0) {
    compact = Math.min(compact, allowed);
  }
  if (allowed < 140) {
    compact = allowed;
  }
  compact = Math.max(0, compact);
  sheetState.compactHeight = Math.round(compact);
  const maxAvailable = Math.max(sheetState.compactHeight, Math.max(0, Math.round(vh - 56)));
  const proposedExpanded = Math.max(sheetState.compactHeight + 80, Math.round(vh * 0.88));
  sheetState.expandedHeight = Math.min(Math.max(proposedExpanded, sheetState.compactHeight), maxAvailable);
  panel.style.setProperty('--sheet-expanded-height', `${sheetState.expandedHeight}px`);
  panel.style.setProperty('--sheet-compact-height', `${sheetState.compactHeight}px`);
  if (sheetState.mode !== 'expanded') {
    sheetState.mode = 'compact';
  } else if (sheetState.expandedHeight <= sheetState.compactHeight) {
    sheetState.mode = 'compact';
  }
  applySheetOffset();
  updateSheetHandleAria();
}

function handleMobileMediaChange() {
  sheetState.pointerId = null;
  sheetState.moved = false;
  sheetState.preventClick = false;
  panel.classList.remove('is-dragging');
  if (!isMobileSheetActive()) {
    sheetState.mode = 'compact';
    panel.removeAttribute('data-sheet-state');
  } else if (panelVisible) {
    setSheetMode('compact', { force: true });
  }
  recalculateSheetMetrics();
}

function setPanelVisible(show) {
  panelVisible = !!show;
  panel.classList.toggle('is-hidden', !panelVisible);
  if (isMobileSheetActive()) {
    if (panelVisible) {
      setSheetMode('compact', { force: true });
    }
    applySheetOffset();
  } else {
    panel.removeAttribute('data-sheet-state');
  }
  if (!panelVisible) {
    if (sheetState.pointerId !== null && panel.releasePointerCapture) {
      try { panel.releasePointerCapture(sheetState.pointerId); } catch (err) { /* noop */ }
    }
    sheetState.pointerId = null;
    sheetState.moved = false;
    sheetState.preventClick = false;
    panel.classList.remove('is-dragging');
  }
  toggleBtn.textContent = panelVisible ? '↕ Panel ausblenden' : '↕ Panel einblenden';
  toggleBtn.setAttribute('aria-expanded', panelVisible ? 'true' : 'false');
  updateSheetHandleAria();
}

function setCameraLocked(lock) {
  cameraLocked = lock;
  controls.enabled = !lock;
  controls.enablePan = !lock;
  controls.enableZoom = !lock;
  controls.enableRotate = !lock;
  if (lock) {
    controls.target.copy(clusterGroup.position);
  }
  controls.update();
  lockBtn.textContent = lock ? '🔒 Kamera gesperrt' : '🔓 Kamera frei';
  lockBtn.setAttribute('aria-pressed', lock ? 'true' : 'false');
  renderer.domElement.classList.toggle('locked', lock);
}

function startSheetDrag(event) {
  if (!sheetHandleBtn || !isMobileSheetActive() || !panelVisible) return;
  sheetState.pointerId = event.pointerId;
  sheetState.startY = event.clientY;
  sheetState.startOffset = sheetState.mode === 'expanded' ? 0 : getSheetCompactOffset();
  sheetState.lastOffset = sheetState.startOffset;
  sheetState.moved = false;
  sheetState.preventClick = false;
  panel.classList.add('is-dragging');
  if (panel.setPointerCapture) {
    try { panel.setPointerCapture(event.pointerId); } catch (err) { /* noop */ }
  }
}

function handleSheetDragMove(event) {
  if (sheetState.pointerId === null || event.pointerId !== sheetState.pointerId) return;
  const delta = event.clientY - sheetState.startY;
  const maxOffset = getSheetCompactOffset();
  let next = sheetState.startOffset + delta;
  if (!Number.isFinite(next)) next = 0;
  next = Math.max(0, Math.min(maxOffset, next));
  if (Math.abs(delta) > 6) {
    sheetState.moved = true;
  }
  sheetState.lastOffset = next;
  panel.style.setProperty('--sheet-offset', `${Math.max(0, Math.round(next))}px`);
}

function finishSheetDrag(event) {
  if (sheetState.pointerId === null || event.pointerId !== sheetState.pointerId) return;
  if (panel.releasePointerCapture) {
    try { panel.releasePointerCapture(event.pointerId); } catch (err) { /* noop */ }
  }
  panel.classList.remove('is-dragging');
  const moved = sheetState.moved;
  const lastOffset = sheetState.lastOffset;
  sheetState.pointerId = null;
  sheetState.moved = false;
  const maxOffset = getSheetCompactOffset();
  if (moved) {
    const threshold = maxOffset * 0.45;
    const nextState = lastOffset > threshold ? 'compact' : 'expanded';
    setSheetMode(nextState, { force: true });
    sheetState.preventClick = true;
  } else {
    sheetState.preventClick = false;
    applySheetOffset();
  }
}

/* Rotation dynamics */
const autoSpinBtn = $('autoSpin');
const spinStopBtn = $('spinStop');
const spinInertiaBtn = $('spinInertia');
const spinDecaySlider = $('spinDecay');
const spinDecayValue = $('vSpinDecay');
const spinInertiaValue = $('vInertia');
const spinAxisSliders = {
  x: $('spinVelX'),
  y: $('spinVelY'),
  z: $('spinVelZ'),
};
const spinAxisValues = {
  x: $('vSpinX'),
  y: $('vSpinY'),
  z: $('vSpinZ'),
};
const spinSpeedSlider = $('spinSpeed');
const spinSpeedValue = $('vSpinSpeed');
const spinAxisKeys = ['x', 'y', 'z'];

const spinState = {
  autoEnabled: false,
  inertiaEnabled: true,
  inertiaDuration: 12,
  velocity: new THREE.Vector3(),
  velocityComponents: new THREE.Vector3(),
  speedMultiplier: 1,
  isDragging: false,
  activePointerId: null,
  prevPointerTime: 0,
  decayStartSpeed: 0,
  decayTime: 0,
  controlsSnapshot: null,
};

const spinVectors = {
  prev: new THREE.Vector3(),
  curr: new THREE.Vector3(),
  axis: new THREE.Vector3(),
};

const defaultSpinSpeed = 0.35;
const defaultSpinAxis = new THREE.Vector3(0, 1, 0);
const spinApplyAxis = new THREE.Vector3();

function syncSpinSliderUI() {
  spinAxisKeys.forEach(axis => {
    const slider = spinAxisSliders[axis];
    const valueEl = spinAxisValues[axis];
    const component = spinState.velocityComponents[axis];
    const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
    if (slider) {
      applySliderValue(id, component);
    }
    if (valueEl) {
      valueEl.textContent = formatDisplayNumber(component, 2) + ' rad/s';
    }
  });
  if (spinSpeedSlider) {
    applySliderValue('spinSpeed', spinState.speedMultiplier);
  }
  if (spinSpeedValue) {
    spinSpeedValue.textContent = '×' + formatDisplayNumber(spinState.speedMultiplier, 2);
  }
}

function updateVelocityFromComponents() {
  spinState.velocity.set(
    spinState.velocityComponents.x * spinState.speedMultiplier,
    spinState.velocityComponents.y * spinState.speedMultiplier,
    spinState.velocityComponents.z * spinState.speedMultiplier,
  );
}

function updateComponentsFromVelocity(syncUI = true) {
  if (Math.abs(spinState.speedMultiplier) <= 1e-6) {
    spinState.velocityComponents.copy(spinState.velocity);
  } else {
    spinState.velocityComponents.copy(spinState.velocity).divideScalar(spinState.speedMultiplier);
  }
  spinAxisKeys.forEach(axis => {
    const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
    spinState.velocityComponents[axis] = clampToSliderBounds(id, spinState.velocityComponents[axis]);
  });
  if (syncUI) {
    syncSpinSliderUI();
  }
}

function setSpinAxisComponent(axis, value) {
  const numeric = parseFloat(value);
  if (Number.isNaN(numeric)) return;
  const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
  const clamped = clampToSliderBounds(id, numeric);
  spinState.velocityComponents[axis] = clamped;
  updateVelocityFromComponents();
  handleVelocityChange();
}

function setSpinSpeedMultiplier(value) {
  const numeric = parseFloat(value);
  if (Number.isNaN(numeric)) return;
  const clamped = clampToSliderBounds('spinSpeed', numeric);
  spinState.speedMultiplier = clamped;
  updateVelocityFromComponents();
  handleVelocityChange();
}

function handleVelocityChange(updateUI = true) {
  const speed = spinState.velocity.length();
  spinState.decayTime = 0;
  if (spinState.autoEnabled && spinState.inertiaEnabled && speed > 1e-6) {
    spinState.decayStartSpeed = speed;
  } else if (!spinState.autoEnabled || speed <= 1e-6) {
    spinState.decayStartSpeed = 0;
  } else {
    spinState.decayStartSpeed = 0;
  }
  if (updateUI) {
    updateRotationUI();
  }
}

function clearSpinVelocity({ resetMultiplier = false, updateUI = true } = {}) {
  spinState.velocity.set(0, 0, 0);
  spinState.velocityComponents.set(0, 0, 0);
  if (resetMultiplier) {
    spinState.speedMultiplier = 1;
  }
  spinState.decayStartSpeed = 0;
  spinState.decayTime = 0;
  if (updateUI) {
    updateRotationUI();
  } else {
    syncSpinSliderUI();
  }
}

function hasSpinVelocity() {
  return spinState.velocity.lengthSq() > 1e-8;
}

function updateRotationUI() {
  if (!autoSpinBtn) return;
  autoSpinBtn.setAttribute('aria-pressed', spinState.autoEnabled ? 'true' : 'false');
  autoSpinBtn.textContent = spinState.autoEnabled ? '🌀 Auto-Rotation an' : '🌀 Auto-Rotation aus';
  spinInertiaBtn.setAttribute('aria-pressed', spinState.inertiaEnabled ? 'true' : 'false');
  spinInertiaBtn.textContent = spinState.inertiaEnabled ? '🪁 Trägheit an' : '🪁 Trägheit aus';
  if (spinDecaySlider) {
    spinDecaySlider.disabled = !spinState.inertiaEnabled;
    applySliderValue('spinDecay', spinState.inertiaDuration);
  }
  if (spinDecayValue) {
    spinDecayValue.textContent = formatDisplayNumber(spinState.inertiaDuration, 0) + ' s';
  }
  if (spinInertiaValue) {
    spinInertiaValue.textContent = spinState.inertiaEnabled ? 'aktiv' : 'aus';
  }
  const velocityActive = spinState.autoEnabled && hasSpinVelocity();
  if (spinStopBtn) {
    spinStopBtn.disabled = !velocityActive;
    spinStopBtn.setAttribute('aria-disabled', velocityActive ? 'false' : 'true');
  }
  syncSpinSliderUI();
}

function stopRotation(updateUI = true) {
  clearSpinVelocity({ updateUI });
}

function setAutoRotation(enabled) {
  if (!enabled) {
    spinState.autoEnabled = false;
    clearSpinVelocity({ resetMultiplier: true, updateUI: false });
    updateRotationUI();
    return;
  }
  spinState.autoEnabled = true;
  if (!hasSpinVelocity()) {
    spinState.velocityComponents.copy(defaultSpinAxis).multiplyScalar(defaultSpinSpeed);
  } else {
    updateComponentsFromVelocity(false);
  }
  updateVelocityFromComponents();
  spinState.decayStartSpeed = spinState.inertiaEnabled ? spinState.velocity.length() : 0;
  spinState.decayTime = 0;
  updateRotationUI();
}

function setInertiaEnabled(enabled) {
  spinState.inertiaEnabled = enabled;
  if (!enabled) {
    spinState.decayStartSpeed = 0;
    spinState.decayTime = 0;
  } else if (hasSpinVelocity() && !spinState.isDragging) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  }
  updateRotationUI();
}

function setInertiaDuration(seconds) {
  let next = Math.round(Number(seconds));
  if (!Number.isFinite(next)) {
    next = spinState.inertiaDuration;
  }
  const clamped = Math.round(clampToSliderBounds('spinDecay', next));
  spinState.inertiaDuration = clamped;
  if (spinState.inertiaEnabled && !spinState.isDragging && hasSpinVelocity()) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  }
  updateRotationUI();
}

function projectOnTrackball(clientX, clientY, target) {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((clientX - rect.left) / rect.width) * 2 - 1;
  const y = ((clientY - rect.top) / rect.height) * -2 + 1;
  target.set(x, y, 0);
  const lengthSq = x * x + y * y;
  if (lengthSq <= 1) {
    target.z = Math.sqrt(1 - lengthSq);
  } else {
    target.normalize();
  }
  return target;
}

function onSpinPointerDown(e) {
  if (!spinState.autoEnabled || e.button !== 0) return;
  spinState.isDragging = true;
  spinState.activePointerId = e.pointerId;
  spinState.decayTime = 0;
  spinState.prevPointerTime = performance.now();
  projectOnTrackball(e.clientX, e.clientY, spinVectors.prev);
  spinState.controlsSnapshot = {
    enabled: controls.enabled,
    enableRotate: controls.enableRotate,
  };
  controls.enabled = false;
  controls.enableRotate = false;
  if (renderer.domElement.setPointerCapture) {
    renderer.domElement.setPointerCapture(e.pointerId);
  }
  e.preventDefault();
}

function onSpinPointerMove(e) {
  if (!spinState.isDragging || e.pointerId !== spinState.activePointerId) return;
  projectOnTrackball(e.clientX, e.clientY, spinVectors.curr);
  const dot = THREE.MathUtils.clamp(spinVectors.prev.dot(spinVectors.curr), -1, 1);
  const angle = Math.acos(dot);
  if (angle > 1e-5) {
    spinVectors.axis.crossVectors(spinVectors.prev, spinVectors.curr);
    if (spinVectors.axis.lengthSq() > 1e-6) {
      spinVectors.axis.normalize();
      clusterGroup.rotateOnAxis(spinVectors.axis, angle);
      const now = performance.now();
      const dt = Math.max((now - spinState.prevPointerTime) / 1000, 1e-3);
      spinState.prevPointerTime = now;
      spinState.velocity.copy(spinVectors.axis).multiplyScalar(angle / dt);
      updateComponentsFromVelocity();
    }
  }
  spinVectors.prev.copy(spinVectors.curr);
}

function onSpinPointerUp(e) {
  if (!spinState.isDragging) return;
  if (typeof e.pointerId === 'number' && spinState.activePointerId !== null && e.pointerId !== spinState.activePointerId) {
    return;
  }
  if (renderer.domElement.releasePointerCapture && spinState.activePointerId !== null) {
    try {
      if (!renderer.domElement.hasPointerCapture || renderer.domElement.hasPointerCapture(spinState.activePointerId)) {
        renderer.domElement.releasePointerCapture(spinState.activePointerId);
      }
    } catch (err) {
      // ignore release errors
    }
  }
  spinState.isDragging = false;
  spinState.activePointerId = null;
  if (!spinState.autoEnabled) {
    stopRotation(false);
  } else if (spinState.inertiaEnabled && hasSpinVelocity()) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  } else {
    spinState.decayStartSpeed = 0;
    spinState.decayTime = 0;
  }
  if (spinState.controlsSnapshot) {
    controls.enabled = spinState.controlsSnapshot.enabled;
    controls.enableRotate = spinState.controlsSnapshot.enableRotate;
    spinState.controlsSnapshot = null;
    controls.update();
  }
  updateRotationUI();
}

renderer.domElement.addEventListener('pointerdown', onSpinPointerDown);
renderer.domElement.addEventListener('pointermove', onSpinPointerMove);
renderer.domElement.addEventListener('pointerup', onSpinPointerUp);
renderer.domElement.addEventListener('pointercancel', onSpinPointerUp);
renderer.domElement.addEventListener('pointerleave', e => {
  if (spinState.isDragging) {
    onSpinPointerUp(e);
  }
});

if (autoSpinBtn) {
  autoSpinBtn.addEventListener('click', () => {
    setAutoRotation(!spinState.autoEnabled);
  });
}
if (spinStopBtn) {
  spinStopBtn.addEventListener('click', () => {
    stopRotation();
  });
}
if (spinInertiaBtn) {
  spinInertiaBtn.addEventListener('click', () => {
    setInertiaEnabled(!spinState.inertiaEnabled);
  });
}
function setCategoryCount(kind, value) {
  const keyMap = { small: 'catSmallCount', medium: 'catMediumCount', large: 'catLargeCount' };
  const key = keyMap[kind];
  if (!key) return;
  const next = Math.max(0, Math.floor(Number(value) || 0));
  if (params[key] === next) {
    return;
  }
  params[key] = next;
  rebuildStars();
}

function getSizeRange(sizeVar = params.sizeVar) {
  const min = Math.max(0.05, 1 - sizeVar * 0.5);
  const max = 1 + sizeVar * 0.5;
  return { min, max, delta: max - min };
}

function clampValue(value, min, max) {
  let next = Number(value);
  if (!Number.isFinite(next)) return next;
  let minVal = Number.isFinite(min) ? min : Number.NEGATIVE_INFINITY;
  let maxVal = Number.isFinite(max) ? max : Number.POSITIVE_INFINITY;
  if (minVal > maxVal) {
    const tmp = minVal;
    minVal = maxVal;
    maxVal = tmp;
  }
  if (Number.isFinite(minVal)) {
    next = Math.max(next, minVal);
  }
  if (Number.isFinite(maxVal)) {
    next = Math.min(next, maxVal);
  }
  return next;
}

function formatDisplayNumber(value, fractionDigits = 2) {
  if (!Number.isFinite(value)) return '';
  return Number.isInteger(value) ? String(value) : value.toFixed(fractionDigits);
}

const sliderBoundSettings = {};
const sliderBoundInputs = {};

function getSliderBounds(id) {
  const slider = $(id);
  const settings = sliderBoundSettings[id];
  let min = settings ? settings.min : undefined;
  let max = settings ? settings.max : undefined;
  if (!Number.isFinite(min) && slider) {
    const rawMin = parseFloat(slider.getAttribute('min'));
    if (Number.isFinite(rawMin)) {
      min = rawMin;
    }
  }
  if (!Number.isFinite(max) && slider) {
    const rawMax = parseFloat(slider.getAttribute('max'));
    if (Number.isFinite(rawMax)) {
      max = rawMax;
    }
  }
  return { min, max };
}

function clampToSliderBounds(id, value) {
  const bounds = getSliderBounds(id);
  return clampValue(value, bounds.min, bounds.max);
}

function syncSliderUI(id) {
  const slider = $(id);
  const settings = sliderBoundSettings[id];
  if (!slider || !settings) return;
  slider.min = String(settings.min);
  slider.max = String(settings.max);
  const pair = sliderBoundInputs[id];
  if (pair && pair.min && document.activeElement !== pair.min) {
    pair.min.value = settings.min;
  }
  if (pair && pair.max && document.activeElement !== pair.max) {
    pair.max.value = settings.max;
  }
}

function handleBoundInputChange(id, kind, inputEl) {
  const settings = sliderBoundSettings[id];
  if (!settings) return;
  let value = parseFloat(inputEl.value);
  if (!Number.isFinite(value)) {
    inputEl.value = settings[kind];
    return;
  }
  if (kind === 'min') {
    settings.min = value;
    if (value > settings.max) {
      settings.max = value;
      const partner = sliderBoundInputs[id] && sliderBoundInputs[id].max;
      if (partner) {
        partner.value = settings.max;
      }
    }
  } else {
    settings.max = value;
    if (value < settings.min) {
      settings.min = value;
      const partner = sliderBoundInputs[id] && sliderBoundInputs[id].min;
      if (partner) {
        partner.value = settings.min;
      }
    }
  }
  inputEl.value = settings[kind];
  syncSliderUI(id);
  const getter = sliderValueGetters[id];
  const handler = sliderHandlers[id];
  if (getter && handler) {
    const current = getter();
    if (Number.isFinite(current)) {
      const clamped = clampValue(current, settings.min, settings.max);
      if (clamped !== current) {
        handler(String(clamped));
      }
    }
  }
  setSliders();
}

function registerSliderBounds(id) {
  const slider = $(id);
  if (!slider) return;
  let min = parseFloat(slider.getAttribute('min'));
  let max = parseFloat(slider.getAttribute('max'));
  if (!Number.isFinite(min) && Number.isFinite(max)) {
    min = max < 0 ? max : 0;
  }
  if (!Number.isFinite(max) && Number.isFinite(min)) {
    max = min > 0 ? min : 1;
  }
  if (!Number.isFinite(min)) min = 0;
  if (!Number.isFinite(max)) max = min;
  if (min > max) {
    const tmp = min;
    min = max;
    max = tmp;
  }
  sliderBoundSettings[id] = { min, max };
  const wrap = slider.closest('.wrap');
  const labelElement = document.querySelector(`label[for="${id}"]`);
  let descriptor = '';
  if (labelElement && labelElement.textContent) {
    descriptor = labelElement.textContent.replace(/\s+/g, ' ').trim();
  } else if (wrap) {
    const tag = wrap.querySelector('.tag');
    if (tag && tag.textContent) {
      descriptor = tag.textContent.replace(/\s+/g, ' ').trim();
    }
  }
  const minLabel = descriptor ? `${descriptor} – Minimum` : 'Minimum';
  const maxLabel = descriptor ? `${descriptor} – Maximum` : 'Maximum';
  if (wrap) {
    const minInput = wrap.querySelector(`input[data-target="${id}"][data-bound="min"]`);
    const maxInput = wrap.querySelector(`input[data-target="${id}"][data-bound="max"]`);
    sliderBoundInputs[id] = sliderBoundInputs[id] || {};
    const step = slider.step && slider.step.length ? slider.step : 'any';
    const numericStep = Number(step);
    const hasNumericStep = Number.isFinite(numericStep) && step !== 'any';
    const isIntegerStep = hasNumericStep && Number.isInteger(numericStep);
    const inputMode = isIntegerStep ? 'numeric' : 'decimal';
    if (minInput) {
      sliderBoundInputs[id].min = minInput;
      minInput.value = min;
      minInput.step = step;
      minInput.inputMode = inputMode;
      minInput.setAttribute('aria-label', minLabel);
      minInput.title = minLabel;
      minInput.addEventListener('change', event => handleBoundInputChange(id, 'min', event.target));
    }
    if (maxInput) {
      sliderBoundInputs[id].max = maxInput;
      maxInput.value = max;
      maxInput.step = step;
      maxInput.inputMode = inputMode;
      maxInput.setAttribute('aria-label', maxLabel);
      maxInput.title = maxLabel;
      maxInput.addEventListener('change', event => handleBoundInputChange(id, 'max', event.target));
    }
  }
  syncSliderUI(id);
}

function initializeSliderBounds() {
  for (const id in sliderValueGetters) {
    registerSliderBounds(id);
  }
}

function applySliderValue(id, value) {
  const slider = $(id);
  if (!slider) return value;
  const bounds = getSliderBounds(id);
  const clamped = Number.isFinite(value) ? clampValue(value, bounds.min, bounds.max) : value;
  slider.value = Number.isFinite(clamped) ? clamped : slider.value;
  return Number.isFinite(clamped) ? clamped : value;
}

function enforceBounds() {
  let changed = false;
  for (const id in sliderValueGetters) {
    const getter = sliderValueGetters[id];
    const handler = sliderHandlers[id];
    const settings = sliderBoundSettings[id];
    if (!getter || !handler || !settings) continue;
    const current = getter();
    if (!Number.isFinite(current)) continue;
    const clamped = clampValue(current, settings.min, settings.max);
    if (clamped !== current) {
      handler(String(clamped));
      changed = true;
    }
  }
  return changed;
}

const sliderHandlers = {
  pCount:       val => {
    params.count = clampTotalCount(val);
    rebuildStars();
  },
  pRadius:      val => { params.radius = parseFloat(val); rebuildStars(); },
  pSizeVar:     val => { params.sizeVar = parseFloat(val); rebuildStars(); },
  pCluster:     val => { params.cluster = parseFloat(val); rebuildStars(); },
  pPointAlpha:  val => { params.pointAlpha = parseFloat(val); updateStarUniforms(); },
  pHue:         val => { params.pointHue = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pSaturation:  val => { params.pointSaturation = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pValue:       val => { params.pointValue = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pSeedStars:   val => { params.seedStars = parseInt(val, 10); rebuildStars(); },
  pCatSmallCount:  val => { setCategoryCount('small', val); },
  pCatMediumCount: val => { setCategoryCount('medium', val); },
  pCatLargeCount:  val => { setCategoryCount('large', val); },
  pSizeTiny:    val => { params.sizeFactorTiny = parseFloat(val); updateTinyMaterial(); },
  pSizeSmall:   val => { params.sizeFactorSmall = parseFloat(val); updateStarUniforms(); },
  pSizeMedium:  val => { params.sizeFactorMedium = parseFloat(val); updateStarUniforms(); },
  pSizeLarge:   val => { params.sizeFactorLarge = parseFloat(val); updateStarUniforms(); },
  pTinyCount:   val => { params.tinyCount = parseInt(val, 10); rebuildTiny(); },
  pConnPercent: val => { params.connPercent = parseFloat(val); rebuildTiny(); },
  pTinyAlpha:   val => { params.tinyAlpha = parseFloat(val); updateTinyMaterial(); },
  pSeedTiny:    val => { params.seedTiny = parseInt(val, 10); rebuildTiny(); },
  pEdgeSoft:    val => { params.edgeSoftness = parseFloat(val); updateStarUniforms(); },
  pMotionSpeed: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionSpeed = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionAmplitude: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionAmplitude = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionNoiseStrength: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionNoiseStrength = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionNoiseScale: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionNoiseScale = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  spinVelX:     val => { setSpinAxisComponent('x', val); },
  spinVelY:     val => { setSpinAxisComponent('y', val); },
  spinVelZ:     val => { setSpinAxisComponent('z', val); },
  spinSpeed:    val => { setSpinSpeedMultiplier(val); },
  spinDecay:    val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      setInertiaDuration(next);
    }
  },
};

const sliderValueGetters = {
  pRadius: () => params.radius,
  pSizeVar: () => params.sizeVar,
  pCluster: () => params.cluster,
  pPointAlpha: () => params.pointAlpha,
  pHue: () => params.pointHue,
  pSaturation: () => params.pointSaturation,
  pValue: () => params.pointValue,
  pSeedStars: () => params.seedStars,
  pSizeTiny: () => params.sizeFactorTiny,
  pSizeSmall: () => params.sizeFactorSmall,
  pSizeMedium: () => params.sizeFactorMedium,
  pSizeLarge: () => params.sizeFactorLarge,
  pTinyCount: () => params.tinyCount,
  pConnPercent: () => params.connPercent,
  pTinyAlpha: () => params.tinyAlpha,
  pSeedTiny: () => params.seedTiny,
  pEdgeSoft: () => params.edgeSoftness,
  pMotionSpeed: () => params.motionSpeed,
  pMotionAmplitude: () => params.motionAmplitude,
  pMotionNoiseStrength: () => params.motionNoiseStrength,
  pMotionNoiseScale: () => params.motionNoiseScale,
  spinVelX: () => spinState.velocityComponents.x,
  spinVelY: () => spinState.velocityComponents.y,
  spinVelZ: () => spinState.velocityComponents.z,
  spinSpeed: () => spinState.speedMultiplier,
  spinDecay: () => spinState.inertiaDuration,
};
initializeSliderBounds();
enforceBounds();
// assign input event handlers
for (const id in sliderHandlers) {
  const element = $(id);
  if (!element) continue;
  element.addEventListener('input', e => {
    sliderHandlers[id](e.target.value);
    setSliders();
  });
}
// Blending select
$('pBlending').addEventListener('change', e => {
  params.blending = e.target.value;
  updateStarUniforms();
  updateTinyMaterial();
});
$('pDistribution').addEventListener('change', e => {
  params.distribution = e.target.value;
  rebuildStars();
  setSliders();
});
$('pMotionMode').addEventListener('change', e => {
  params.motionMode = e.target.value;
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
});
// Filled checkbox
$('pFilled').addEventListener('change', e => {
  params.filled = e.target.checked;
  updateStarUniforms();
});

/* Accordion controls */
const accordionTriggers = Array.from(document.querySelectorAll('.accordion__trigger'));

function setAccordionState(trigger, expanded) {
  const panelId = trigger.getAttribute('aria-controls');
  const panel = panelId ? document.getElementById(panelId) : null;
  if (!panel) return;
  trigger.setAttribute('aria-expanded', String(expanded));
  panel.hidden = !expanded;
  trigger.classList.toggle('is-open', expanded);
  panel.classList.toggle('is-open', expanded);
}

accordionTriggers.forEach(trigger => {
  const initial = trigger.getAttribute('aria-expanded') === 'true';
  setAccordionState(trigger, initial);
  trigger.addEventListener('click', () => {
    const next = trigger.getAttribute('aria-expanded') !== 'true';
    setAccordionState(trigger, next);
  });
});

/* Toggle panel, lock camera & random button */
toggleBtn.addEventListener('click', () => {
  setPanelVisible(!panelVisible);
});

if (sheetHandleBtn) {
  sheetHandleBtn.addEventListener('pointerdown', event => {
    if (!isMobileSheetActive()) return;
    startSheetDrag(event);
  });
  sheetHandleBtn.addEventListener('click', event => {
    if (!isMobileSheetActive()) return;
    if (sheetState.preventClick) {
      sheetState.preventClick = false;
      event.preventDefault();
      return;
    }
    const next = sheetState.mode === 'expanded' ? 'compact' : 'expanded';
    setSheetMode(next, { force: true });
  });
}

panel.addEventListener('pointermove', handleSheetDragMove);
panel.addEventListener('pointerup', finishSheetDrag);
panel.addEventListener('pointercancel', finishSheetDrag);

if (mobileSheetQuery.addEventListener) {
  mobileSheetQuery.addEventListener('change', handleMobileMediaChange);
} else if (mobileSheetQuery.addListener) {
  mobileSheetQuery.addListener(handleMobileMediaChange);
}

lockBtn.addEventListener('click', () => {
  setCameraLocked(!cameraLocked);
});

$('random').addEventListener('click', () => {
  // randomize many parameters
  const totalCount = 500 + Math.floor(Math.random() * 7500);
  params.count = clampTotalCount(totalCount);
  params.radius = 60 + Math.random() * 180;
  params.sizeVar = Math.random() * 9.5;
  params.cluster = Math.random() * 0.95;
  params.pointAlpha = 0.3 + Math.random() * 0.7;
  params.pointHue = Math.random() * 360;
  params.pointSaturation = Math.random();
  params.pointValue = 0.3 + Math.random() * 0.7;
  params.seedStars = 1 + Math.floor(Math.random() * 9999);
  const distributions = ['random', 'fibonacci', 'spiral'];
  params.distribution = distributions[Math.floor(Math.random() * distributions.length)];
  const weights = [Math.random(), Math.random(), Math.random()];
  const weightSum = weights.reduce((sum, value) => sum + value, 0) || 1;
  const provisional = weights.map(value => Math.max(0, Math.floor((value / weightSum) * totalCount)));
  let assigned = provisional.reduce((sum, value) => sum + value, 0);
  let diff = totalCount - assigned;
  let idx = 0;
  const adjustOrder = [0, 1, 2];
  while (diff > 0 && idx < 300) {
    const target = adjustOrder[idx % adjustOrder.length];
    provisional[target] += 1;
    diff -= 1;
    idx += 1;
  }
  params.catSmallCount = provisional[0];
  params.catMediumCount = provisional[1];
  params.catLargeCount = Math.max(0, totalCount - params.catSmallCount - params.catMediumCount);
  params.sizeFactorSmall = 0.5 + Math.random() * 2.5;
  params.sizeFactorMedium = 0.5 + Math.random() * 2.5;
  params.sizeFactorLarge = 0.5 + Math.random() * 2.5;
  params.sizeFactorTiny = 0.05 + Math.random() * 0.6;
  params.tinyCount = Math.floor(Math.random() * 5000);
  params.connPercent = Math.random();
  params.tinyAlpha = Math.random();
  params.seedTiny = 1 + Math.floor(Math.random() * 9999);
  params.edgeSoftness = Math.random();
  params.blending = (Math.random() < 0.5) ? 'Normal' : 'Additive';
  params.filled = Math.random() < 0.3;
  const motionModes = MOTION_MODES;
  params.motionMode = motionModes[Math.floor(Math.random() * motionModes.length)];
  params.motionSpeed = Math.random() * 2.5;
  params.motionAmplitude = Math.random() * 30;
  params.motionNoiseStrength = Math.random() * 2.0;
  params.motionNoiseScale = 0.1 + Math.random() * 3.5;
  enforceBounds();
  updatePointColor();
  rebuildStars();
  setSliders();
});

/* Update slider displays */
function setSliders() {
  // star params
  params.count = clampTotalCount(params.count);
  if ($('pCount')) {
    $('pCount').value = params.count;
  }
  $('vCount').textContent = params.count;
  const radiusValue = applySliderValue('pRadius', params.radius);
  $('vRadius').textContent = formatDisplayNumber(radiusValue, 2);
  $('pDistribution').value = params.distribution;
  const sizeVarValue = applySliderValue('pSizeVar', params.sizeVar);
  const sizeRange = getSizeRange(sizeVarValue);
  $('vSizeVar').textContent = sizeRange.delta.toFixed(2);
  const clusterValue = applySliderValue('pCluster', params.cluster);
  $('vCluster').textContent = formatDisplayNumber(clusterValue, 2);
  const alphaValue = applySliderValue('pPointAlpha', params.pointAlpha);
  $('vPointAlpha').textContent = alphaValue.toFixed(2);
  const hueValue = applySliderValue('pHue', params.pointHue);
  $('vHue').textContent = formatDisplayNumber(hueValue, 1) + '°';
  const saturationValue = applySliderValue('pSaturation', params.pointSaturation);
  $('vSaturation').textContent = (saturationValue * 100).toFixed(0) + '%';
  const valueValue = applySliderValue('pValue', params.pointValue);
  $('vValue').textContent = (valueValue * 100).toFixed(0) + '%';
  const seedStarsValue = applySliderValue('pSeedStars', params.seedStars);
  $('vSeedStars').textContent = formatDisplayNumber(seedStarsValue);
  $('pCatSmallCount').value = params.catSmallCount; $('vCatSmallCount').textContent = params.catSmallCount;
  $('pCatMediumCount').value = params.catMediumCount; $('vCatMediumCount').textContent = params.catMediumCount;
  $('pCatLargeCount').value = params.catLargeCount; $('vCatLargeCount').textContent = params.catLargeCount;
  // size factors
  const sizeTinyValue = applySliderValue('pSizeTiny', params.sizeFactorTiny);
  $('vSizeTiny').textContent = sizeTinyValue.toFixed(2);
  const sizeSmallValue = applySliderValue('pSizeSmall', params.sizeFactorSmall);
  $('vSizeSmall').textContent = sizeSmallValue.toFixed(2);
  const sizeMediumValue = applySliderValue('pSizeMedium', params.sizeFactorMedium);
  $('vSizeMedium').textContent = sizeMediumValue.toFixed(2);
  const sizeLargeValue = applySliderValue('pSizeLarge', params.sizeFactorLarge);
  $('vSizeLarge').textContent = sizeLargeValue.toFixed(2);
  // tiny / connection
  const tinyCountValue = applySliderValue('pTinyCount', params.tinyCount);
  $('vTinyCount').textContent = formatDisplayNumber(tinyCountValue);
  const connPercentValue = applySliderValue('pConnPercent', params.connPercent);
  $('vConnPercent').textContent = (connPercentValue * 100).toFixed(0) + '%';
  const tinyAlphaValue = applySliderValue('pTinyAlpha', params.tinyAlpha);
  $('vTinyAlpha').textContent = tinyAlphaValue.toFixed(2);
  const seedTinyValue = applySliderValue('pSeedTiny', params.seedTiny);
  $('vSeedTiny').textContent = formatDisplayNumber(seedTinyValue);
  // motion
  $('pMotionMode').value = params.motionMode;
  const motionSpeedValue = applySliderValue('pMotionSpeed', params.motionSpeed);
  $('vMotionSpeed').textContent = motionSpeedValue.toFixed(2) + '×';
  const motionAmplitudeValue = applySliderValue('pMotionAmplitude', params.motionAmplitude);
  $('vMotionAmplitude').textContent = formatDisplayNumber(motionAmplitudeValue, 1);
  const motionNoiseStrengthValue = applySliderValue('pMotionNoiseStrength', params.motionNoiseStrength);
  $('vMotionNoiseStrength').textContent = motionNoiseStrengthValue.toFixed(2);
  const motionNoiseScaleValue = applySliderValue('pMotionNoiseScale', params.motionNoiseScale);
  $('vMotionNoiseScale').textContent = motionNoiseScaleValue.toFixed(2);
  // edge & blending
  const edgeSoftValue = applySliderValue('pEdgeSoft', params.edgeSoftness);
  $('vEdgeSoft').textContent = edgeSoftValue.toFixed(2);
  $('pBlending').value = params.blending;
  $('pFilled').checked = params.filled;
  updateRotationUI();
}

/* Resize handler */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  recalculateSheetMetrics();
  if (isMobileSheetActive()) {
    applySheetOffset();
  }
});

window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    recalculateSheetMetrics();
    if (isMobileSheetActive()) {
      applySheetOffset();
    }
  }, 120);
});

/* Animation loop */
let lastFrameTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  const current = (typeof now === 'number') ? now : performance.now();
  const delta = Math.min(Math.max((current - lastFrameTime) / 1000, 0), 0.25);
  lastFrameTime = current;

  motionState.time += delta;
  if (motionState.time > 1e6) {
    motionState.time = 0;
  }
  if (starMaterial && starMaterial.uniforms && starMaterial.uniforms.uTime) {
    starMaterial.uniforms.uTime.value = motionState.time;
  }
  if (tinyMaterial && tinyMaterial.uniforms && tinyMaterial.uniforms.uTime) {
    tinyMaterial.uniforms.uTime.value = motionState.time;
  }

  if (spinState.autoEnabled && !spinState.isDragging) {
    updateVelocityFromComponents();
    if (spinState.inertiaEnabled && spinState.decayStartSpeed > 0 && hasSpinVelocity()) {
      spinState.decayTime += delta;
      const duration = Math.max(spinState.inertiaDuration, 0.001);
      const progress = Math.min(spinState.decayTime / duration, 1);
      const newSpeed = spinState.decayStartSpeed * (1 - progress);
      if (newSpeed <= 1e-4) {
        stopRotation(false);
        updateRotationUI();
      } else {
        spinState.velocity.setLength(newSpeed);
        updateComponentsFromVelocity();
      }
    }
    const speed = spinState.velocity.length();
    if (speed > 1e-6) {
      spinApplyAxis.copy(spinState.velocity).normalize();
      clusterGroup.rotateOnAxis(spinApplyAxis, speed * delta);
    }
  }

  applyAudioVisuals(delta);

  if (cameraLocked) {
    controls.target.copy(clusterGroup.position);
  }
  controls.update();
  if (!cameraLocked && !controls.target.equals(clusterGroup.position)) {
    clusterGroup.position.copy(controls.target);
  }
  renderer.render(scene, camera);
}

/* Initialization */
setInertiaDuration(spinState.inertiaDuration);
setInertiaEnabled(spinState.inertiaEnabled);
setAutoRotation(true);
recalculateSheetMetrics();
const initialPanelVisible = window.innerWidth > 580;
setPanelVisible(initialPanelVisible);
setCameraLocked(false);
updatePointColor(false);
setSliders();
rebuildStars();
requestAnimationFrame(animate);
</script>
</body>
</html>
