<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Chaos‚ÄëKugel ‚Äì erweiterte Kontrolle</title>
  <style>
    :root {
      --panel: rgba(0,0,0,.6);
      --fg: #ddd;
      --sheet-compact-height: 32vh;
      --sheet-expanded-height: 84vh;
      --player-panel: rgba(12, 12, 14, 0.78);
      --player-border: rgba(255,255,255,0.08);
      --accent: #71c7ff;
    }
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; color: var(--fg); font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    #playerShell {
      position: fixed;
      inset: 0;
      z-index: 18;
      display: grid;
      grid-template-rows: auto 1fr auto auto;
      pointer-events: none;
    }
    #playerShell[data-mode="studio"] {
      pointer-events: none;
      opacity: 0;
      transition: opacity .25s ease;
    }
    #playerShell[data-mode="player"] {
      pointer-events: none;
    }
    .player-header,
    .player-controls,
    .player-visual-panel {
      pointer-events: auto;
    }
    .player-header {
      display: flex;
      align-items: center;
      gap: .65rem;
      padding: .9rem 1rem .35rem;
      background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0.35));
      backdrop-filter: blur(8px);
    }
    .player-source {
      padding: .4rem .65rem;
      border-radius: 999px;
      border: 1px solid var(--player-border);
      background: rgba(255,255,255,0.06);
      font-size: .78rem;
      letter-spacing: .01em;
    }
    .player-track {
      flex: 1;
      min-width: 0;
      display: grid;
      gap: .15rem;
    }
    .player-track-title {
      font-weight: 700;
      font-size: 1rem;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .player-track-meta { font-size: .8rem; opacity: .8; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .player-chip {
      padding: .5rem .75rem;
      border-radius: 10px;
      border: 1px solid var(--player-border);
      background: rgba(255,255,255,0.08);
      color: inherit;
      font-weight: 600;
      cursor: pointer;
      transition: transform .15s ease, background .2s ease, border-color .2s ease;
    }
    .player-chip:hover { transform: translateY(-1px); }
    .player-chip[data-pressed="true"] {
      border-color: rgba(255,255,255,0.35);
      background: rgba(113, 199, 255, 0.18);
      box-shadow: 0 6px 20px rgba(0,0,0,0.35);
    }
    .player-controls {
      margin: 0 .75rem .4rem;
      padding: .65rem .75rem .9rem;
      border-radius: 14px;
      border: 1px solid var(--player-border);
      background: var(--player-panel);
      backdrop-filter: blur(14px);
      box-shadow: 0 16px 40px rgba(0,0,0,0.38);
    }
    .player-progress {
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: .5rem;
      font-size: .8rem;
      opacity: .92;
    }
    .player-progress input[type=range] { width: 100%; }
    .player-transport {
      margin-top: .55rem;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: .5rem;
    }
    .player-transport button {
      padding: .65rem .5rem;
      border-radius: 12px;
      border: 1px solid var(--player-border);
      background: rgba(255,255,255,0.08);
      color: inherit;
      font-weight: 700;
      font-size: .95rem;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, transform .15s ease;
    }
    .player-transport button:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .player-transport button:hover { transform: translateY(-1px); }
    .player-transport button[aria-pressed="true"] { border-color: rgba(255,255,255,0.35); }
    .player-visual-panel {
      margin: 0 .75rem 1rem;
      padding: .75rem .85rem;
      border-radius: 14px;
      border: 1px solid var(--player-border);
      background: rgba(10,10,12,0.82);
      box-shadow: 0 14px 32px rgba(0,0,0,0.35);
      display: grid;
      gap: .6rem;
    }
    .macro-row { display: grid; gap: .35rem; }
    .macro-label { font-size: .82rem; letter-spacing: .01em; opacity: .86; }
    .macro-chips { display: flex; gap: .4rem; flex-wrap: wrap; }
    .macro-slider { display: grid; gap: .3rem; }
    .macro-slider input[type=range] { width: 100%; }
    .player-compact-actions { display: flex; gap: .5rem; flex-wrap: wrap; }
    .player-compact-actions .player-chip { flex: 1 1 120px; text-align: center; }
    .player-queue-sheet {
      position: fixed;
      inset: auto 0 0 0;
      z-index: 40;
      max-height: var(--sheet-expanded-height);
      display: grid;
      grid-template-rows: auto 1fr;
      background: rgba(8, 10, 14, 0.94);
      backdrop-filter: blur(18px);
      border-top: 1px solid var(--player-border);
      transform: translate3d(0, 100%, 0);
      transition: transform .25s ease, box-shadow .25s ease;
      box-shadow: 0 -20px 38px rgba(0, 0, 0, 0.45);
    }
    .player-queue-sheet[data-open="true"] { transform: translate3d(0, 0, 0); }
    .player-queue-header {
      display: flex;
      align-items: center;
      gap: .65rem;
      padding: .9rem 1rem .45rem;
      border-bottom: 1px solid var(--player-border);
    }
    .player-queue-title { font-weight: 800; letter-spacing: .01em; }
    .player-queue-body { padding: .65rem 1rem 1rem; overflow-y: auto; }
    .queue-add { display: grid; gap: .65rem; margin-bottom: .75rem; }
    .queue-add-row { display: flex; gap: .5rem; flex-wrap: wrap; }
    .queue-add-row input[type=text] { flex: 1 1 220px; padding: .7rem .75rem; border-radius: 10px; border: 1px solid var(--player-border); background: rgba(255,255,255,0.06); color: inherit; }
    .queue-add-row button { border-radius: 10px; border: 1px solid var(--player-border); background: rgba(255,255,255,0.08); color: inherit; font-weight: 700; padding: .65rem .85rem; cursor: pointer; }
    .queue-list { list-style: none; margin: 0; padding: 0; display: grid; gap: .5rem; }
    .recent-playlists { display: grid; gap: .4rem; padding: .35rem .4rem .2rem; border-radius: 10px; border: 1px dashed var(--player-border); background: rgba(255,255,255,0.03); }
    .recent-playlists[data-empty="true"] { opacity: .72; }
    .recent-playlists__header { display: flex; align-items: center; gap: .5rem; justify-content: space-between; font-size: .85rem; letter-spacing: .01em; }
    .recent-playlists__list { display: flex; gap: .4rem; flex-wrap: wrap; }
    .recent-playlist-chip { padding: .45rem .7rem; border-radius: 9px; border: 1px solid var(--player-border); background: rgba(255,255,255,0.06); color: inherit; cursor: pointer; transition: transform .1s ease, border-color .2s ease, background .2s ease; }
    .recent-playlist-chip:hover { transform: translateY(-1px); border-color: rgba(255,255,255,0.35); }
    .recent-playlist-chip:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }
    .recent-playlists__empty { font-size: .85rem; opacity: .8; }
    .queue-item { display: grid; grid-template-columns: 1fr auto; gap: .45rem; padding: .65rem .75rem; border-radius: 12px; border: 1px solid var(--player-border); background: rgba(255,255,255,0.05); }
    .queue-item-title { font-weight: 700; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .queue-item-meta { font-size: .8rem; opacity: .78; display: flex; gap: .4rem; align-items: center; }
    .queue-source { padding: .25rem .55rem; border-radius: 999px; border: 1px solid var(--player-border); font-size: .7rem; letter-spacing: .02em; }
    .queue-actions { display: flex; gap: .4rem; align-items: center; }
    .queue-actions button { border-radius: 10px; border: 1px solid var(--player-border); background: rgba(255,255,255,0.08); color: inherit; padding: .4rem .55rem; cursor: pointer; }
    .queue-empty { padding: .65rem .75rem; border-radius: 10px; border: 1px dashed var(--player-border); opacity: .75; text-align: center; }
    #audioOverlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 30;
      pointer-events: none;
      opacity: 0;
      transform: translateY(18px);
      transition: opacity .35s ease, transform .35s ease;
    }
    #audioOverlay[data-visible="true"] {
      opacity: 1;
      transform: translateY(0);
    }
    #audioOverlay[data-visible="true"] #audioOverlayButton {
      pointer-events: auto;
    }
    #audioOverlayButton {
      display: inline-flex;
      align-items: center;
      gap: .6rem;
      padding: 1.2rem 1.9rem;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(0, 0, 0, 0.68);
      color: var(--fg);
      font-size: 1.05rem;
      font-weight: 600;
      letter-spacing: .02em;
      cursor: pointer;
      box-shadow: 0 14px 42px rgba(0,0,0,0.45);
      transition: transform .25s ease, box-shadow .25s ease, border-color .25s ease, background .25s ease;
    }
    #audioOverlayButton:hover,
    #audioOverlayButton:focus-visible {
      transform: scale(1.04);
      border-color: rgba(90, 190, 255, 0.85);
      box-shadow: 0 16px 46px rgba(20,120,200,0.45);
      background: rgba(20, 40, 70, 0.75);
      outline: none;
    }
    #audioOverlayButton:focus-visible {
      box-shadow: 0 0 0 3px rgba(90, 190, 255, 0.45), 0 16px 46px rgba(20,120,200,0.45);
    }
    #audioOverlayButton[disabled] {
      cursor: wait;
      opacity: .7;
    }
    #panel {
      position: absolute;
      top: 56px;
      right: 10px;
      z-index: 10;
      width: 330px;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
      background: var(--panel);
      border-radius: 10px;
      padding: 12px;
      backdrop-filter: blur(2px);
      transition: opacity .25s ease, transform .25s ease;
    }
    #panel.is-hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(-12px);
    }
    #panel h3 { margin: .25rem 0 .5rem; font-size: .95rem; }
    .accordion {
      background: rgba(20, 20, 20, 0.45);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 10px;
      margin: 0 0 .75rem;
      overflow: hidden;
    }
    .accordion + .accordion { margin-top: .5rem; }
    .accordion__trigger {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .65rem;
      padding: .6rem .85rem;
      background: transparent;
      color: inherit;
      border: none;
      font-size: .85rem;
      font-weight: 600;
      letter-spacing: .01em;
      cursor: pointer;
      position: relative;
      transition: background .2s ease, color .2s ease;
    }
    .accordion__trigger::after {
      content: '‚ñæ';
      font-size: .9rem;
      transition: transform .2s ease;
    }
    .accordion__trigger[aria-expanded="false"]::after {
      transform: rotate(-90deg);
    }
    .accordion__trigger[aria-expanded="true"] {
      background: rgba(70, 70, 70, 0.25);
    }
    .accordion__trigger[aria-expanded="false"] {
      background: rgba(0, 0, 0, 0.05);
    }
    .accordion__trigger:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 2px;
    }
    .accordion__panel {
      padding: .5rem .85rem .55rem;
      display: grid;
      gap: .2rem;
      border-top: 1px solid rgba(255, 255, 255, 0.08);
    }
    .accordion__panel.is-open {
      background: rgba(255, 255, 255, 0.04);
    }
    .accordion__panel[hidden] {
      display: none;
    }
    .row { margin: .35rem 0 .8rem; }
    .row label { display: block; font-size: .8rem; margin-bottom: .25rem; opacity: .95; }
    .row button {
      padding: .35rem .6rem;
      font-size: .8rem;
      background: rgba(255, 255, 255, 0.08);
      color: var(--fg);
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, opacity .2s ease;
    }
    .row button[aria-pressed="true"] {
      background: rgba(40, 160, 220, 0.35);
      border-color: rgba(90, 190, 255, 0.7);
    }
    .swatch-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(96px, 1fr));
      gap: .35rem;
    }
    .color-swatch {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: .45rem .5rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
      border-radius: 8px;
      background: var(--swatch, rgba(255, 255, 255, 0.1));
      color: var(--swatch-text, #fff);
      font-size: .75rem;
      font-weight: 600;
      letter-spacing: .01em;
      cursor: pointer;
      transition: transform .15s ease, border-color .2s ease, box-shadow .2s ease;
      text-shadow: 0 0 4px rgba(0, 0, 0, 0.45);
    }
    .color-swatch:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.35);
    }
    .color-swatch[aria-pressed="true"] {
      border-color: rgba(255, 255, 255, 0.8);
      box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.35);
    }
    .color-swatch--picker {
      display: flex;
      flex-direction: column;
      gap: .3rem;
      padding: .55rem .6rem .45rem;
      background: rgba(255, 255, 255, 0.07);
      text-shadow: none;
      color: #fff;
    }
    .color-swatch--picker input[type=color] {
      width: 100%;
      height: 32px;
      border: none;
      border-radius: 6px;
      padding: 0;
      background: transparent;
      cursor: pointer;
    }
    .color-swatch--picker input[type=color]::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 6px;
    }
    .color-swatch--picker input[type=color]::-webkit-color-swatch {
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 6px;
    }
    .color-swatch--picker input[type=color]::-moz-color-swatch {
      border: 1px solid rgba(255, 255, 255, 0.25);
      border-radius: 6px;
    }
    .color-swatch__label {
      font-size: .72rem;
      font-weight: 600;
      letter-spacing: .02em;
      opacity: .85;
    }
    .hint {
      margin: .35rem 0 0;
      font-size: .72rem;
      line-height: 1.35;
      opacity: .68;
    }
    .row button:disabled,
    .row button[aria-disabled="true"] {
      opacity: 0.55;
      cursor: default;
    }
    .file-row { display: flex; flex-direction: column; gap: .35rem; }
    .file-meta { font-size: .75rem; opacity: .75; word-break: break-word; }
    .audio-controls { display: flex; flex-wrap: wrap; gap: .5rem; }
    .audio-controls button { flex: 1 1 140px; }
    .audio-controls--primary button { flex: 1 1 calc(50% - .5rem); }
    .audio-controls--secondary button { flex: 1 1 100%; }
    .input-row { display: flex; gap: .5rem; align-items: center; }
    .input-row input[type=text] { flex: 1 1 auto; min-width: 0; padding: .5rem .7rem; border-radius: 8px; border: 1px solid rgba(255,255,255,0.2); background: rgba(0,0,0,0.35); color: var(--fg); }
    .input-row button { flex: 0 0 auto; }
    .youtube-status { font-size: .8rem; opacity: .85; line-height: 1.4; }
    .sr-only { position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
    .playlist-meta { font-size: .74rem; line-height: 1.4; opacity: .75; }
    .stl-mode-backdrop {
      position: fixed;
      inset: 0;
      z-index: 40;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(3px);
    }
    .stl-mode-dialog {
      width: min(420px, calc(100vw - 32px));
      background: rgba(20, 20, 20, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 1.25rem;
      display: grid;
      gap: .85rem;
      box-shadow: 0 28px 64px rgba(0, 0, 0, 0.55);
    }
    .stl-mode-dialog h2 {
      margin: 0;
      font-size: 1rem;
      letter-spacing: .01em;
    }
    .stl-mode-dialog p {
      margin: 0;
      font-size: .82rem;
      line-height: 1.5;
      opacity: .85;
    }
    .stl-mode-actions {
      display: flex;
      flex-wrap: wrap;
      gap: .5rem;
    }
    .stl-mode-actions button {
      flex: 1 1 120px;
      padding: .55rem .75rem;
      font-size: .85rem;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(255, 255, 255, 0.08);
      color: inherit;
      cursor: pointer;
      transition: background .2s ease, border-color .2s ease, transform .2s ease;
    }
    .stl-mode-actions button:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 2px;
    }
    .stl-mode-actions button[data-choice="distribution"] {
      background: rgba(40, 160, 220, 0.35);
      border-color: rgba(90, 190, 255, 0.65);
    }
    .stl-mode-actions button:hover {
      background: rgba(255, 255, 255, 0.16);
    }
    .stl-mode-actions button[data-choice="distribution"]:hover {
      background: rgba(60, 180, 240, 0.45);
    }
    .modifier-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: .35rem;
    }
    .intensity-grid {
      display: flex;
      flex-direction: column;
      gap: .35rem;
    }
    .intensity-grid .wrap {
      gap: .45rem;
    }
    .intensity-grid .wrap.is-disabled {
      opacity: 0.55;
    }
    .intensity-limit {
      width: 72px;
      padding: .25rem .35rem;
      font-size: .75rem;
      color: var(--fg);
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      flex: 0 0 72px;
    }
    .intensity-limit:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 1px;
    }
    .status-row { display: flex; align-items: center; gap: .5rem; font-size: .78rem; min-height: 1.4em; }
    .status-indicator { width: 10px; height: 10px; border-radius: 50%; background: rgba(255, 255, 255, 0.35); box-shadow: 0 0 6px rgba(0, 0, 0, 0.45); flex-shrink: 0; transition: background .2s ease, box-shadow .2s ease; }
    .status-text { flex: 1; }
    .status-text[data-state="idle"] { color: rgba(255, 255, 255, 0.65); }
    .status-text[data-state="waiting"] { color: #ffd166; }
    .status-text[data-state="active"] { color: #7fffd4; }
    .status-text[data-state="error"] { color: #ff8a80; }
    .status-indicator[data-state="waiting"] { background: #ffd166; box-shadow: 0 0 12px rgba(255, 209, 102, 0.6); }
    .status-indicator[data-state="active"] { background: #7fffd4; box-shadow: 0 0 12px rgba(127, 255, 212, 0.65); }
    .status-indicator[data-state="error"] { background: #ff8a80; box-shadow: 0 0 12px rgba(255, 138, 128, 0.75); }
    .wrap { display: flex; gap: .5rem; align-items: center; flex-wrap: wrap; }
    .bound-input {
      width: 64px;
      padding: .25rem .35rem;
      font-size: .75rem;
      color: var(--fg);
      background: rgba(255, 255, 255, 0.08);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 6px;
      flex: 0 0 64px;
    }
    .bound-input:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 1px;
    }
    .stack { display: flex; flex-direction: column; gap: .4rem; }
    .tag { min-width: 64px; font-size: .75rem; letter-spacing: .02em; text-transform: uppercase; opacity: .7; }
    input[type=range],
    input[type=number] { flex: 1; width: 100%; }
    .val { min-width: 66px; text-align: right; font-variant-numeric: tabular-nums; }
    select { flex: 1; }
    #barHotspot {
      position: fixed;
      top: 0;
      left: 0;
      width: clamp(56px, 12vw, 120px);
      height: clamp(72px, 18vh, 160px);
      z-index: 14;
      pointer-events: auto;
      background: transparent;
      touch-action: manipulation;
    }
    #bar {
      position: fixed;
      top: 12px;
      left: 12px;
      z-index: 16;
      display: flex;
      gap: 8px;
      opacity: 0;
      pointer-events: none;
      --bar-hidden-transform: translate3d(calc(-100% - 24px), 0, 0);
      transform: var(--bar-hidden-transform);
      transition: transform .35s ease, opacity .35s ease;
      will-change: transform, opacity;
    }
    #bar.is-visible {
      opacity: 1;
      pointer-events: auto;
      transform: translate3d(0, 0, 0);
      transition-timing-function: cubic-bezier(.25, .1, .25, 1);
    }
    #bar button {
      padding: .45rem .65rem;
      font-size: .85rem;
      background: var(--panel);
      color: #fff;
      border: 1px solid #666;
      border-radius: 6px;
      cursor: pointer;
      backdrop-filter: blur(2px);
      transition: background .2s ease, border-color .2s ease;
    }
    #bar button[aria-pressed="true"] {
      background: rgba(40, 160, 220, 0.65);
      border-color: rgba(90, 190, 255, 0.9);
    }
    #audioPanel {
      position: absolute;
      left: 12px;
      bottom: 12px;
      z-index: 11;
      width: 300px;
      max-width: calc(100vw - 24px);
      background: var(--panel);
      border-radius: 10px;
      padding: 12px 14px 14px;
      display: grid;
      gap: .55rem;
      backdrop-filter: blur(2px);
      box-shadow: 0 12px 28px rgba(0, 0, 0, 0.45);
      transition: transform .25s ease, opacity .25s ease;
    }
    #audioPanel.is-hidden {
      opacity: 0;
      pointer-events: none;
      transform: translateY(12px);
    }
    #audioPanel.is-collapsed {
      padding-bottom: 12px;
    }
    #audioPanel h3 {
      margin: 0;
      font-size: .95rem;
      letter-spacing: .01em;
    }
    #audioPanel .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: .5rem;
    }
    #audioPanelToggle {
      border: none;
      background: rgba(255, 255, 255, 0.08);
      color: inherit;
      width: 28px;
      height: 28px;
      border-radius: 50%;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: background .2s ease, transform .2s ease;
    }
    #audioPanelToggle:hover {
      background: rgba(255, 255, 255, 0.18);
    }
    #audioPanelToggle:focus-visible {
      outline: 2px solid rgba(90, 190, 255, 0.9);
      outline-offset: 2px;
    }
    #audioPanelToggle[aria-expanded="false"] {
      transform: rotate(-90deg);
    }
    #audioPanel .panel-body {
      display: grid;
      gap: .6rem;
    }
    #audioPanel .row {
      margin: 0;
    }
    #audioPanel .row + .row {
      margin-top: .45rem;
    }
    #audioPanel .status-row {
      margin-top: .2rem;
    }
    #audioPanel .file-row {
      gap: .45rem;
    }
    #audioPanel .file-row label {
      margin-bottom: .1rem;
    }
    #audioPanel .panel-footnote {
      font-size: .72rem;
      opacity: .75;
      line-height: 1.4;
    }
    #audioPanel .panel-footnote[data-state="warning"] {
      color: #ffd166;
      opacity: 1;
    }
    #audioPanel .panel-footnote[data-state="error"] {
      color: #ffb0a8;
      opacity: 1;
    }
    @media (hover:hover) {
      #bar button:hover {
        background: rgba(80, 80, 80, 0.7);
      }
    }
    .sheet-handle {
      display: none;
    }
    .sheet-handle-label {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }
    @media (max-width: 768px) {
      #panel {
        position: fixed;
        top: auto;
        bottom: 0;
        right: auto;
        left: 0;
        width: 100%;
        max-width: none;
        border-radius: 18px 18px 0 0;
        padding: 18px 18px 24px;
        max-height: min(var(--sheet-expanded-height), calc(100vh - 56px));
        transform: translateY(var(--sheet-offset, 0px));
        transition: opacity .25s ease, transform .35s ease;
        box-shadow: 0 -12px 28px rgba(0, 0, 0, 0.4);
      }
      #audioPanel {
        position: fixed;
        top: 64px;
        bottom: auto;
        left: 12px;
        right: 12px;
        width: auto;
        max-width: none;
      }
      #panel.is-hidden {
        transform: translateY(calc(var(--sheet-expanded-height, 80vh) + 40px));
      }
      #panel.is-dragging {
        transition: none;
      }
      .sheet-handle {
        display: flex;
        justify-content: center;
        margin: -6px auto 10px;
      }
      .sheet-handle button {
        appearance: none;
        border: none;
        background: transparent;
        padding: 10px 24px;
        border-radius: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        cursor: grab;
        touch-action: none;
      }
      .sheet-handle button:active {
        cursor: grabbing;
      }
      .sheet-handle-bar {
        width: 44px;
        height: 5px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.35);
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
      }
      .sheet-handle button:focus-visible .sheet-handle-bar {
        outline: 2px solid rgba(90, 190, 255, 0.95);
        outline-offset: 4px;
      }
      #barHotspot {
        width: clamp(88px, 28vw, 180px);
        height: clamp(96px, 24vh, 200px);
      }
      #bar {
        left: 50%;
        width: calc(100% - 24px);
        flex-wrap: wrap;
        justify-content: center;
        --bar-hidden-transform: translate3d(-50%, -120%, 0);
      }
      #bar.is-visible {
        transform: translate3d(-50%, 0, 0);
      }
      #bar button {
        flex: 1 1 140px;
        text-align: center;
      }
    }
    canvas { display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }
    canvas.locked { cursor: not-allowed; }
    canvas.locked:active { cursor: not-allowed; }
  </style>
  <!-- Load Three.js and OrbitControls from local files -->
  <script src="./three.min.js"></script>
  <script src="./OrbitControls.js"></script>
<script src="./STLLoader.js"></script>
</head>
<body>
<div id="playerShell" data-mode="player">
  <header class="player-header">
    <div class="player-source" id="playerSource">Lokale Musik</div>
    <div class="player-track">
      <div class="player-track-title" id="playerTitle">Visual Player</div>
      <div class="player-track-meta" id="playerMeta">Bereit</div>
    </div>
    <button class="player-chip" type="button" id="studioToggle">üéõÔ∏è Studio</button>
  </header>
  <div></div>
  <div class="player-controls">
    <div class="player-progress">
      <span id="playerTime">0:00</span>
      <input id="playerProgress" type="range" min="0" max="1" step="0.001" value="0" aria-label="Wiedergabeposition" />
      <span id="playerDuration">‚Äì:‚Äì‚Äì</span>
    </div>
    <div class="player-transport" role="group" aria-label="Player-Steuerung">
      <button type="button" id="playerSourceCycle" title="Quelle wechseln">üîä</button>
      <button type="button" id="playerPrev">‚èÆÔ∏è</button>
      <button type="button" id="playerPlay">‚ñ∂Ô∏è</button>
      <button type="button" id="playerNext">‚è≠Ô∏è</button>
      <button type="button" id="playerRepeat" aria-pressed="false">üîÅ</button>
    </div>
    <div class="player-compact-actions">
      <button class="player-chip" type="button" id="playerQueue">Playlist</button>
      <button class="player-chip" type="button" id="playerRandomStyle">üé≤ Zufall</button>
    </div>
  </div>
  <div class="player-visual-panel">
    <div class="macro-row">
      <div class="macro-label">Stil</div>
      <div class="macro-chips" id="playerStyles">
        <button type="button" class="player-chip" data-style="nebula">Nebula</button>
        <button type="button" class="player-chip" data-style="orbit">Orbit</button>
        <button type="button" class="player-chip" data-style="spiral">Spirale</button>
        <button type="button" class="player-chip" data-style="cluster">Cluster</button>
      </div>
    </div>
    <div class="macro-row">
      <div class="macro-label">Farbstimmung</div>
      <div class="macro-chips" id="playerMoods">
        <button type="button" class="player-chip" data-mood="cool">Blau/T√ºrkis</button>
        <button type="button" class="player-chip" data-mood="warm">Warm</button>
        <button type="button" class="player-chip" data-mood="pastel">Pastell</button>
        <button type="button" class="player-chip" data-mood="mono">Monochrom</button>
        <button type="button" class="player-chip" data-mood="auto">Auto</button>
      </div>
    </div>
    <div class="macro-row macro-slider">
      <div class="macro-label">Komplexit√§t</div>
      <input id="playerComplexity" type="range" min="0" max="1" step="0.01" value="0.5" />
    </div>
    <div class="macro-row macro-slider">
      <div class="macro-label">Bewegung</div>
      <input id="playerMotion" type="range" min="0" max="1" step="0.01" value="0.45" />
    </div>
    <div class="macro-row macro-slider">
      <div class="macro-label">Reaktivit√§t</div>
      <input id="playerReactivity" type="range" min="0" max="1.5" step="0.05" value="1" />
    </div>
  </div>
</div>
<div class="player-queue-sheet" id="playerQueueSheet" data-open="false" aria-hidden="true">
  <div class="player-queue-header">
    <div class="player-queue-title">Playlist</div>
    <span class="playlist-meta" id="queueMeta">Keine Titel</span>
    <div style="flex:1"></div>
    <button class="player-chip" type="button" id="queueClose">Schlie√üen</button>
  </div>
  <div class="player-queue-body">
    <div class="queue-add">
      <div class="queue-add-row">
        <button type="button" id="queueAddLocal">Lokale Dateien</button>
        <button type="button" id="queueAddPreset">Beispielmusik hinzuf√ºgen</button>
        <input id="queueFileInput" type="file" accept="audio/*" multiple hidden />
      </div>
      <div class="queue-add-row">
        <input id="queueYoutubeInput" type="text" placeholder="YouTube-Playlist oder Video-URL" aria-label="YouTube-URL" />
        <button type="button" id="queueAddYoutube">YouTube importieren</button>
      </div>
      <div class="recent-playlists" id="queueRecentPlaylists" data-empty="true" aria-live="polite">
        <div class="recent-playlists__header">
          <span>Zuletzt importiert</span>
          <button type="button" class="recent-playlist-chip" id="queueRecentNew">Neuer Link</button>
        </div>
        <div class="recent-playlists__list" id="queueRecentList"></div>
      </div>
    </div>
    <ul class="queue-list" id="queueList" aria-live="polite"></ul>
    <div class="queue-empty" id="queueEmpty">F√ºge lokale Dateien, Beispielmusik oder YouTube-Titel hinzu.</div>
  </div>
</div>
<div id="barHotspot" aria-hidden="true"></div>
<div id="bar" role="toolbar" aria-hidden="true">
  <button id="toggle" aria-expanded="true">‚Üï Panels ausblenden</button>
  <button id="editMode" aria-pressed="false">üõ†Ô∏è Bearbeitungsmodus aus</button>
  <button id="lock" aria-pressed="false">üîì Kamera frei</button>
  <button id="random">üé≤ Random</button>
</div>
<div id="panel" class="is-hidden" aria-hidden="true">
  <div class="sheet-handle">
    <button id="sheetHandle" type="button" aria-expanded="false" aria-controls="panel">
      <span class="sheet-handle-bar" aria-hidden="true"></span>
      <span class="sheet-handle-label">Panel vergr√∂√üern</span>
    </button>
  </div>
  <h3>Parameter</h3>
  <section class="accordion" id="acc-points">
    <button type="button" class="accordion__trigger" id="acc-points-trigger" aria-expanded="true" aria-controls="acc-points-panel">
      Punkte
    </button>
    <div class="accordion__panel" id="acc-points-panel" role="region" aria-labelledby="acc-points-trigger">
      <div class="row">
        <label for="pCount">Anzahl Punkte (Summe)</label>
        <div class="wrap">
          <input id="pCount" type="number" min="0" step="1" readonly />
          <div class="val" id="vCount"></div>
        </div>
      </div>
      <div class="row">
        <label for="pRadius">Radius</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pRadius" data-bound="min" />
          <input id="pRadius" type="range" min="40" max="260" step="1" />
          <input class="bound-input" type="number" data-target="pRadius" data-bound="max" />
          <div class="val" id="vRadius"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeVar">Gr√∂√üenvariation (Œî)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeVar" data-bound="min" />
          <input id="pSizeVar" type="range" min="0" max="10" step="0.1" />
          <input class="bound-input" type="number" data-target="pSizeVar" data-bound="max" />
          <div class="val" id="vSizeVar"></div>
        </div>
      </div>
      <div class="row">
        <label for="pCluster">Clustering</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pCluster" data-bound="min" />
          <input id="pCluster" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pCluster" data-bound="max" />
          <div class="val" id="vCluster"></div>
        </div>
      </div>
      <div class="row">
        <label for="pPointAlpha">Deckkraft Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pPointAlpha" data-bound="min" />
          <input id="pPointAlpha" type="range" min="0.3" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pPointAlpha" data-bound="max" />
          <div class="val" id="vPointAlpha"></div>
        </div>
      </div>
      <div class="row">
        <label for="pHue">Punktfarbe (Farbton)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pHue" data-bound="min" />
          <input id="pHue" type="range" min="0" max="360" step="1" />
          <input class="bound-input" type="number" data-target="pHue" data-bound="max" />
          <div class="val" id="vHue"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSaturation">Punktfarbe (S√§ttigung)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSaturation" data-bound="min" />
          <input id="pSaturation" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pSaturation" data-bound="max" />
          <div class="val" id="vSaturation"></div>
        </div>
      </div>
      <div class="row">
        <label for="pValue">Punktfarbe (Helligkeit)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pValue" data-bound="min" />
          <input id="pValue" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pValue" data-bound="max" />
          <div class="val" id="vValue"></div>
        </div>
      </div>
      <div class="row">
        <label for="pHueColor">Farben f√ºr einzelne Punkte</label>
        <div class="swatch-grid" id="pColorSwatches">
          <button type="button" class="color-swatch" data-color-swatch data-h="210" data-s="0.75" data-v="1" aria-pressed="false" style="--swatch:#5fa8ff;">
            Polarblau
          </button>
          <button type="button" class="color-swatch" data-color-swatch data-h="280" data-s="0.55" data-v="1" aria-pressed="false" style="--swatch:#ba68ff;">
            Kosmos
          </button>
          <button type="button" class="color-swatch" data-color-swatch data-h="35" data-s="0.82" data-v="1" aria-pressed="false" style="--swatch:#ffad46; --swatch-text:#1a1320;">
            Sonnenaufg.
          </button>
          <button type="button" class="color-swatch" data-color-swatch data-h="150" data-s="0.9" data-v="0.9" aria-pressed="false" style="--swatch:#36f5a3; --swatch-text:#10251c;">
            Neonwald
          </button>
          <button type="button" class="color-swatch" data-color-swatch data-h="8" data-s="0.88" data-v="1" aria-pressed="false" style="--swatch:#ff5a4e;">
            Plasma
          </button>
          <button type="button" class="color-swatch" data-color-swatch data-h="0" data-s="0" data-v="0.94" aria-pressed="false" style="--swatch:#f0f0f0; --swatch-text:#111;">
            Neutral
          </button>
          <label class="color-swatch color-swatch--picker" for="pHueColor">
            <span class="color-swatch__label">Eigene Farbe</span>
            <input id="pHueColor" type="color" aria-label="Eigene Punktfarbe w√§hlen" />
          </label>
        </div>
        <p class="hint">Tipp: W√§hle oben einen Farbton oder nutze den Zufallsmodus bzw. erh√∂he die Farbton-Streuung, damit alle Punkte eigene Farben annehmen.</p>
      </div>
      <div class="row">
        <label for="pColorMode">Farbmodus</label>
        <select id="pColorMode">
          <option value="uniform">Einzelfarbe</option>
          <option value="radialPulse">Radialer Puls</option>
          <option value="axisWave">Vertikale Welle</option>
          <option value="phaseFlicker">Zuf√§lliges Flimmern</option>
          <option value="randomHue">Zufallsmodus</option>
        </select>
      </div>
      <div class="row">
        <label for="pColorIntensity">Farbintensit√§t</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pColorIntensity" data-bound="min" />
          <input id="pColorIntensity" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pColorIntensity" data-bound="max" />
          <div class="val" id="vColorIntensity"></div>
        </div>
      </div>
      <div class="row">
        <label for="pColorSpeed">Farbanimation (Tempo)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pColorSpeed" data-bound="min" />
          <input id="pColorSpeed" type="range" min="0" max="5" step="0.05" />
          <input class="bound-input" type="number" data-target="pColorSpeed" data-bound="max" />
          <div class="val" id="vColorSpeed"></div>
        </div>
      </div>
      <div class="row">
        <label for="pHueSpread">Farbton-Streuung</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pHueSpread" data-bound="min" />
          <input id="pHueSpread" type="range" min="0" max="180" step="1" />
          <input class="bound-input" type="number" data-target="pHueSpread" data-bound="max" />
          <div class="val" id="vHueSpread"></div>
        </div>
      </div>
      <div class="row">
        <label for="pColorPropagationDistance">Farb-Ausbreitung (Distanz)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pColorPropagationDistance" data-bound="min" />
          <input id="pColorPropagationDistance" type="range" min="10" max="600" step="1" />
          <input class="bound-input" type="number" data-target="pColorPropagationDistance" data-bound="max" />
          <div class="val" id="vColorPropagationDistance"></div>
        </div>
      </div>
      <div class="row">
        <label for="pColorPropagationDuration">Farb-Ausbreitung (Dauer)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pColorPropagationDuration" data-bound="min" />
          <input id="pColorPropagationDuration" type="range" min="0" max="20" step="0.1" />
          <input class="bound-input" type="number" data-target="pColorPropagationDuration" data-bound="max" />
          <div class="val" id="vColorPropagationDuration"></div>
        </div>
      </div>
      <div class="row">
        <label for="pColorToneCount">Farbt√∂ne (Anzahl)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pColorToneCount" data-bound="min" />
          <input id="pColorToneCount" type="range" min="1" max="12" step="1" />
          <input class="bound-input" type="number" data-target="pColorToneCount" data-bound="max" />
          <div class="val" id="vColorToneCount"></div>
        </div>
      </div>
      <div class="row">
        </select>
      </div>
      <div class="row">
        <label for="pSeedStars">Seed Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSeedStars" data-bound="min" />
          <input id="pSeedStars" type="range" min="1" max="9999" step="1" />
          <input class="bound-input" type="number" data-target="pSeedStars" data-bound="max" />
          <div class="val" id="vSeedStars"></div>
        </div>
      </div>
      <div class="row">
        <label>Punktkategorien (Anzahl)</label>
        <div class="stack">
          <div class="wrap">
            <span class="tag">Klein</span>
            <input id="pCatSmallCount" type="number" min="0" step="1" />
            <div class="val" id="vCatSmallCount"></div>
          </div>
          <div class="wrap">
            <span class="tag">Mittel</span>
            <input id="pCatMediumCount" type="number" min="0" step="1" />
            <div class="val" id="vCatMediumCount"></div>
          </div>
          <div class="wrap">
            <span class="tag">Gro√ü</span>
            <input id="pCatLargeCount" type="number" min="0" step="1" />
            <div class="val" id="vCatLargeCount"></div>
          </div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-distribution">
    <button type="button" class="accordion__trigger" id="acc-distribution-trigger" aria-expanded="false" aria-controls="acc-distribution-panel">
      Verteilung & Volumen
    </button>
    <div class="accordion__panel" id="acc-distribution-panel" role="region" aria-labelledby="acc-distribution-trigger" hidden>
      <div class="row">
        <label for="pDistribution">Verteilungsalgorithmus</label>
        <select id="pDistribution">
          <option value="random">Zufall (Sph√§re)</option>
          <option value="fibonacci">Fibonacci-Sph√§re</option>
          <option value="spiral">Galaxie-Spirale</option>
          <option value="cube">W√ºrfel-Volumen</option>
          <option value="cylinder">Zylinder-Volumen</option>
          <option value="octahedron">Oktaeder-Volumen</option>
          <option value="stl" data-stl-option hidden disabled>Importierte STL-Punkte</option>
        </select>
      </div>
      <div class="row file-row">
        <label for="stlFiles">STL-Modelle</label>
        <input id="stlFiles" type="file" accept=".stl,model/stl,application/sla" multiple />
        <div class="file-meta" id="stlFileMeta">Keine Auswahl</div>
        <div class="hint">Nach dem Import kannst du w√§hlen, ob die STL-Punkte zus√§tzlich oder als Verteilungsalgorithmus genutzt werden.</div>
      </div>
      <div class="row">
        <div class="wrap">
          <button type="button" id="stlClear" disabled>üßπ Modelle entfernen</button>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-size">
    <button type="button" class="accordion__trigger" id="acc-size-trigger" aria-expanded="false" aria-controls="acc-size-panel">
      Gr√∂√üe
    </button>
    <div class="accordion__panel" id="acc-size-panel" role="region" aria-labelledby="acc-size-trigger" hidden>
      <div class="row">
        <label for="pSizeTiny">Gr√∂√üe winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeTiny" data-bound="min" />
          <input id="pSizeTiny" type="range" min="0.05" max="3" step="0.01" />
          <input class="bound-input" type="number" data-target="pSizeTiny" data-bound="max" />
          <div class="val" id="vSizeTiny"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeSmall">Gr√∂√üe kleine Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeSmall" data-bound="min" />
          <input id="pSizeSmall" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeSmall" data-bound="max" />
          <div class="val" id="vSizeSmall"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeMedium">Gr√∂√üe mittlere Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeMedium" data-bound="min" />
          <input id="pSizeMedium" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeMedium" data-bound="max" />
          <div class="val" id="vSizeMedium"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSizeLarge">Gr√∂√üe gro√üe Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSizeLarge" data-bound="min" />
          <input id="pSizeLarge" type="range" min="0.2" max="3" step="0.05" />
          <input class="bound-input" type="number" data-target="pSizeLarge" data-bound="max" />
          <div class="val" id="vSizeLarge"></div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-connections">
    <button type="button" class="accordion__trigger" id="acc-connections-trigger" aria-expanded="false" aria-controls="acc-connections-panel">
      Verbindungen
    </button>
    <div class="accordion__panel" id="acc-connections-panel" role="region" aria-labelledby="acc-connections-trigger" hidden>
      <div class="row">
        <label for="pTinyCount">Menge winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pTinyCount" data-bound="min" />
          <input id="pTinyCount" type="range" min="0" max="5000" step="10" />
          <input class="bound-input" type="number" data-target="pTinyCount" data-bound="max" />
          <div class="val" id="vTinyCount"></div>
        </div>
      </div>
      <div class="row">
        <label for="pConnPercent">Prozent Verbindungen</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pConnPercent" data-bound="min" />
          <input id="pConnPercent" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pConnPercent" data-bound="max" />
          <div class="val" id="vConnPercent"></div>
        </div>
      </div>
      <div class="row">
        <label for="pTinyAlpha">Deckkraft winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pTinyAlpha" data-bound="min" />
          <input id="pTinyAlpha" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pTinyAlpha" data-bound="max" />
          <div class="val" id="vTinyAlpha"></div>
        </div>
      </div>
      <div class="row">
        <label for="pSeedTiny">Seed winzige Punkte</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pSeedTiny" data-bound="min" />
          <input id="pSeedTiny" type="range" min="1" max="9999" step="1" />
          <input class="bound-input" type="number" data-target="pSeedTiny" data-bound="max" />
          <div class="val" id="vSeedTiny"></div>
        </div>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-display">
    <button type="button" class="accordion__trigger" id="acc-display-trigger" aria-expanded="false" aria-controls="acc-display-panel">
      Darstellung
    </button>
    <div class="accordion__panel" id="acc-display-panel" role="region" aria-labelledby="acc-display-trigger" hidden>
      <div class="row">
        <label for="pEdgeSoft">Randweichheit</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pEdgeSoft" data-bound="min" />
          <input id="pEdgeSoft" type="range" min="0" max="1" step="0.01" />
          <input class="bound-input" type="number" data-target="pEdgeSoft" data-bound="max" />
          <div class="val" id="vEdgeSoft"></div>
        </div>
      </div>
      <div class="row">
        <label for="pBlending">Blending-Modus</label>
        <select id="pBlending">
          <option value="Normal">Normal</option>
          <option value="Additive">Additiv</option>
        </select>
      </div>
      <div class="row">
        <label><input id="pFilled" type="checkbox" /> Gef√ºllt (harte Kreise)</label>
      </div>
    </div>
  </section>
  <section class="accordion" id="acc-dynamics">
    <button type="button" class="accordion__trigger" id="acc-dynamics-trigger" aria-expanded="true" aria-controls="acc-dynamics-panel">
      Dynamik
    </button>
    <div class="accordion__panel" id="acc-dynamics-panel" role="region" aria-labelledby="acc-dynamics-trigger">
      <div class="row">
        <label for="pMotionMode">Bewegungsmodus</label>
        <select id="pMotionMode">
          <option value="static">Statisch</option>
          <option value="sine">Sinuswellen</option>
          <option value="noise">Noise</option>
          <option value="orbit">Orbit</option>
        </select>
      </div>
      <div class="row">
        <label for="pMotionSpeed">Bewegungsgeschwindigkeit</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionSpeed" data-bound="min" />
          <input id="pMotionSpeed" type="range" min="0" max="3" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionSpeed" data-bound="max" />
          <div class="val" id="vMotionSpeed"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionAmplitude">Amplitude</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionAmplitude" data-bound="min" />
          <input id="pMotionAmplitude" type="range" min="0" max="40" step="0.1" />
          <input class="bound-input" type="number" data-target="pMotionAmplitude" data-bound="max" />
          <div class="val" id="vMotionAmplitude"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionNoiseStrength">Noise-Intensit√§t</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionNoiseStrength" data-bound="min" />
          <input id="pMotionNoiseStrength" type="range" min="0" max="2.5" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionNoiseStrength" data-bound="max" />
          <div class="val" id="vMotionNoiseStrength"></div>
        </div>
      </div>
      <div class="row">
        <label for="pMotionNoiseScale">Noise-Skala</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="pMotionNoiseScale" data-bound="min" />
          <input id="pMotionNoiseScale" type="range" min="0.1" max="4" step="0.01" />
          <input class="bound-input" type="number" data-target="pMotionNoiseScale" data-bound="max" />
          <div class="val" id="vMotionNoiseScale"></div>
        </div>
      </div>
      <div class="row">
        <label>Rotation</label>
        <div class="wrap">
          <button id="autoSpin" aria-pressed="false">üåÄ Auto-Rotation aus</button>
          <button id="spinStop" aria-disabled="true" disabled>‚èπÔ∏è Stoppen</button>
        </div>
      </div>
      <div class="row">
        <label>Winkelgeschwindigkeit (rad/s)</label>
        <div class="stack">
          <div class="wrap">
            <span class="tag">X</span>
            <input class="bound-input" type="number" data-target="spinVelX" data-bound="min" />
            <input id="spinVelX" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelX" data-bound="max" />
            <div class="val" id="vSpinX"></div>
          </div>
          <div class="wrap">
            <span class="tag">Y</span>
            <input class="bound-input" type="number" data-target="spinVelY" data-bound="min" />
            <input id="spinVelY" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelY" data-bound="max" />
            <div class="val" id="vSpinY"></div>
          </div>
          <div class="wrap">
            <span class="tag">Z</span>
            <input class="bound-input" type="number" data-target="spinVelZ" data-bound="min" />
            <input id="spinVelZ" type="range" min="-3" max="3" step="0.01" />
            <input class="bound-input" type="number" data-target="spinVelZ" data-bound="max" />
            <div class="val" id="vSpinZ"></div>
          </div>
        </div>
      </div>
      <div class="row">
        <label for="spinSpeed">Geschwindigkeitsfaktor</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="spinSpeed" data-bound="min" />
          <input id="spinSpeed" type="range" min="0" max="20" step="0.01" />
          <input class="bound-input" type="number" data-target="spinSpeed" data-bound="max" />
          <div class="val" id="vSpinSpeed"></div>
        </div>
      </div>
      <div class="row">
        <label>Tr√§gheit</label>
        <div class="wrap">
          <button id="spinInertia" aria-pressed="true">ü™Å Tr√§gheit an</button>
          <div class="val" id="vInertia"></div>
        </div>
      </div>
      <div class="row">
        <label for="spinDecay">Abklingzeit (s)</label>
        <div class="wrap">
          <input class="bound-input" type="number" data-target="spinDecay" data-bound="min" />
          <input id="spinDecay" type="range" min="1" max="30" step="1" />
          <input class="bound-input" type="number" data-target="spinDecay" data-bound="max" />
          <div class="val" id="vSpinDecay"></div>
        </div>
      </div>
    </div>
  </section>
</div>
<div id="audioPanel" class="is-hidden" role="complementary" aria-label="Audio-Steuerung" aria-hidden="true">
  <div class="panel-header">
    <h3>Audio-Reaktivit√§t</h3>
    <button type="button" id="audioPanelToggle" aria-expanded="true" aria-controls="audioPanelBody" aria-label="Audio-Bedienfeld ein- oder ausblenden" title="Audio-Bedienfeld ein- oder ausblenden">‚ñæ</button>
  </div>
  <div class="panel-body" id="audioPanelBody">
    <div class="row file-row">
      <label for="audioFile">Audio-Dateien</label>
      <input id="audioFile" type="file" accept="audio/*" multiple />
      <div class="file-meta" id="audioFileMeta">Keine Auswahl</div>
      <div class="playlist-meta" id="audioPlaylistMeta">Keine Playlist geladen</div>
    </div>
    <div class="row">
      <div class="audio-controls audio-controls--primary">
        <button type="button" id="audioPrev" disabled>‚èÆÔ∏è Zur√ºck</button>
        <button type="button" id="audioPlay" disabled>‚ñ∂Ô∏è Abspielen</button>
        <button type="button" id="audioStop" disabled>‚èπÔ∏è Stop</button>
        <button type="button" id="audioNext" disabled>‚è≠Ô∏è Weiter</button>
      </div>
    </div>
    <div class="row">
      <label for="youtubePlaylistUrl">YouTube-Playlist</label>
      <div class="input-row">
        <input id="youtubePlaylistUrl" type="text" placeholder="https://www.youtube.com/playlist?list=‚Ä¶" aria-label="YouTube-Playlist-URL oder -ID" />
        <button type="button" id="youtubeLoad">üîó Laden</button>
      </div>
      <div class="recent-playlists" id="recentPlaylists" data-empty="true" aria-live="polite">
        <div class="recent-playlists__header">
          <span>Zuletzt importierte Playlists</span>
          <button type="button" class="recent-playlist-chip" id="recentPlaylistNew">Neuer Link</button>
        </div>
        <div class="recent-playlists__list" id="recentPlaylistList"></div>
      </div>
      <div class="audio-controls">
        <button type="button" id="youtubePlay" disabled>‚ñ∂Ô∏è Start</button>
        <button type="button" id="youtubePause" disabled>‚è∏Ô∏è Pause</button>
        <button type="button" id="youtubePrev" disabled>‚èÆÔ∏è Zur√ºck</button>
        <button type="button" id="youtubeNext" disabled>‚è≠Ô∏è Weiter</button>
      </div>
      <div class="youtube-status" id="youtubeStatus">Keine YouTube-Playlist geladen</div>
    </div>
    <div class="row">
      <div class="audio-controls audio-controls--secondary">
        <button type="button" id="audioRepeat" aria-pressed="false" disabled>üîÅ Repeat aus</button>
      </div>
    </div>
    <div class="row">
      <label for="audioMicStart">Mikrofon</label>
      <div class="audio-controls">
        <button type="button" id="audioMicStart">üéôÔ∏è Start</button>
        <button type="button" id="audioMicStop" disabled>‚èπÔ∏è Stop</button>
      </div>
    </div>
    <div class="row">
      <label>Audio-Reaktionsziele</label>
      <div class="modifier-grid" id="audioModifierGrid">
        <button type="button" class="modifier-toggle" data-modifier="motion" aria-pressed="true">Rotation</button>
        <button type="button" class="modifier-toggle" data-modifier="scale" aria-pressed="true">Skalierung</button>
        <button type="button" class="modifier-toggle" data-modifier="size" aria-pressed="true">Punktgr√∂√üe</button>
        <button type="button" class="modifier-toggle" data-modifier="hue" aria-pressed="true">Farbton</button>
        <button type="button" class="modifier-toggle" data-modifier="saturation" aria-pressed="true">S√§ttigung</button>
        <button type="button" class="modifier-toggle" data-modifier="brightness" aria-pressed="true">Helligkeit</button>
        <button type="button" class="modifier-toggle" data-modifier="alpha" aria-pressed="true">Transparenz</button>
      </div>
    </div>
    <div class="row">
      <label>Reaktionsst√§rke</label>
      <div class="intensity-grid">
        <div class="wrap" data-intensity-row="motion">
          <span class="tag">Rotation</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="20" data-intensity-limit="motion" aria-label="Maximale Reaktionsst√§rke f√ºr Rotation in Prozent" />
          <input type="range" min="0" max="100" step="5" value="50" data-intensity-target="motion" />
          <div class="val" data-intensity-value="motion">50%</div>
        </div>
        <div class="wrap" data-intensity-row="scale">
          <span class="tag">Skalierung</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="scale" aria-label="Maximale Reaktionsst√§rke f√ºr Skalierung in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="scale" />
          <div class="val" data-intensity-value="scale">100%</div>
        </div>
        <div class="wrap" data-intensity-row="size">
          <span class="tag">Punktgr√∂√üe</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="size" aria-label="Maximale Reaktionsst√§rke f√ºr Punktgr√∂√üe in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="size" />
          <div class="val" data-intensity-value="size">100%</div>
        </div>
        <div class="wrap" data-intensity-row="hue">
          <span class="tag">Farbton</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="hue" aria-label="Maximale Reaktionsst√§rke f√ºr Farbton in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="hue" />
          <div class="val" data-intensity-value="hue">100%</div>
        </div>
        <div class="wrap" data-intensity-row="saturation">
          <span class="tag">S√§ttigung</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="saturation" aria-label="Maximale Reaktionsst√§rke f√ºr S√§ttigung in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="saturation" />
          <div class="val" data-intensity-value="saturation">100%</div>
        </div>
        <div class="wrap" data-intensity-row="brightness">
          <span class="tag">Helligkeit</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="brightness" aria-label="Maximale Reaktionsst√§rke f√ºr Helligkeit in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="brightness" />
          <div class="val" data-intensity-value="brightness">100%</div>
        </div>
        <div class="wrap" data-intensity-row="alpha">
          <span class="tag">Transparenz</span>
          <input class="intensity-limit" type="number" min="5" max="200" step="5" value="100" data-intensity-limit="alpha" aria-label="Maximale Reaktionsst√§rke f√ºr Transparenz in Prozent" />
          <input type="range" min="0" max="100" step="5" value="100" data-intensity-target="alpha" />
          <div class="val" data-intensity-value="alpha">100%</div>
        </div>
      </div>
    </div>
    <div class="row">
      <label for="brightnessAdaptationToggle">Helligkeitsadaption</label>
      <div class="wrap">
        <button type="button" id="brightnessAdaptationToggle" aria-pressed="true">üåó Adaption an</button>
      </div>
    </div>
    <div class="row">
      <label for="audioRandomMode">Random-Modus</label>
      <div class="audio-controls">
        <button type="button" id="audioRandomMode" aria-pressed="true">üîÄ Random-Modus aus</button>
      </div>
    </div>
    <div class="row status-row" role="status" aria-live="polite">
      <span class="status-indicator" id="audioStatusDot" data-state="idle" aria-hidden="true"></span>
      <span class="status-text" id="audioStatus" data-state="idle">Audio-Reaktivit√§t inaktiv</span>
    </div>
    <div class="panel-footnote" id="audioSupportNotice">Nutze eine Datei oder das Mikrofon, um die Punktfarben an Audio zu koppeln.</div>
  </div>
</div>
<div id="audioOverlay" data-visible="false" aria-hidden="true">
  <button type="button" id="audioOverlayButton" aria-label="Musik und Visualisierung starten">
    ‚ñ∂Ô∏è Play ‚Äì Musik & Visualisierung starten
  </button>
</div>
<div class="sr-only" aria-hidden="true">
  <div id="youtubePlayer"></div>
</div>
<script>
/* Utility: HSV‚ÜíRGB (for potential future color variations) */
function hsv2rgb(h, s, v) {
  let c = v * s;
  let hp = h / 60;
  let x = c * (1 - Math.abs((hp % 2) - 1));
  let m = v - c;
  let r=0,g=0,b=0;
  if(hp < 1){r=c; g=x;} else
  if(hp < 2){r=x; g=c;} else
  if(hp < 3){g=c; b=x;} else
  if(hp < 4){g=x; b=c;} else
  if(hp < 5){r=x; b=c;} else{r=c; b=x;}
  return new THREE.Color(r+m,g+m,b+m);
}

function clampColor(color) {
  color.r = Math.min(1, Math.max(0, color.r));
  color.g = Math.min(1, Math.max(0, color.g));
  color.b = Math.min(1, Math.max(0, color.b));
  return color;
}

function clamp01(value) {
  if (!Number.isFinite(value)) return 0;
  if (value < 0) return 0;
  if (value > 1) return 1;
  return value;
}

function normalizeHue(value) {
  if (!Number.isFinite(value)) return 0;
  let hue = value % 360;
  if (hue < 0) hue += 360;
  return hue;
}

function hsvToHex(h, s, v) {
  const color = hsv2rgb(h, s, v);
  const r = Math.round(clamp01(color.r) * 255);
  const g = Math.round(clamp01(color.g) * 255);
  const b = Math.round(clamp01(color.b) * 255);
  const toHex = component => component.toString(16).padStart(2, '0');
  return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toLowerCase();
}

function hexToHsv(hex) {
  if (typeof hex !== 'string') return null;
  const normalized = hex.trim().toLowerCase();
  const match = /^#?([\da-f]{6})$/.exec(normalized);
  if (!match) return null;
  const intVal = parseInt(match[1], 16);
  const r = ((intVal >> 16) & 255) / 255;
  const g = ((intVal >> 8) & 255) / 255;
  const b = (intVal & 255) / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;
  let h = 0;
  if (delta !== 0) {
    if (max === r) {
      h = ((g - b) / delta) % 6;
    } else if (max === g) {
      h = (b - r) / delta + 2;
    } else {
      h = (r - g) / delta + 4;
    }
    h *= 60;
  }
  if (h < 0) h += 360;
  const s = max === 0 ? 0 : delta / max;
  const v = max;
  return { h: normalizeHue(h), s: clamp01(s), v: clamp01(v) };
}

function hueDifference(a, b) {
  const diff = Math.abs(((a - b + 540) % 360) - 180);
  return Math.abs(diff);
}

/* PRNG: Mulberry32 for reproducible random */
function mulberry32(seed) {
  return function() {
    let t = seed += 0x6D2B79F5;
    t = Math.imul(t ^ (t >>> 15), 1 | t);
    t ^= t + Math.imul(t ^ (t >>> 7), 61 | t);
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function hashStringList(strings) {
  if (!Array.isArray(strings) || !strings.length) {
    return 0x9e3779b9;
  }
  let hash = 0x811c9dc5;
  for (const entry of strings) {
    const value = typeof entry === 'string' ? entry : '';
    for (let i = 0; i < value.length; i++) {
      hash ^= value.charCodeAt(i);
      hash = Math.imul(hash, 0x01000193);
      hash >>>= 0;
    }
  }
  if (hash === 0) {
    return 0x6d2b79f5;
  }
  return hash >>> 0;
}

function randomRange(min, max) {
  const a = Number.isFinite(min) ? min : 0;
  const b = Number.isFinite(max) ? max : 0;
  return a + Math.random() * (b - a);
}

function randomInRange(range, fallback = 0, { clamp = false } = {}) {
  if (Array.isArray(range) && range.length === 2) {
    const min = Number.isFinite(range[0]) ? range[0] : range[1];
    const max = Number.isFinite(range[1]) ? range[1] : range[0];
    if (Number.isFinite(min) && Number.isFinite(max)) {
      const value = min + Math.random() * (max - min);
      if (!clamp) {
        return value;
      }
      if (min > max) {
        return fallback;
      }
      return Math.min(Math.max(value, min), max);
    }
  }
  if (Number.isFinite(range)) {
    return range;
  }
  if (Array.isArray(fallback) && fallback.length === 2) {
    return randomInRange(fallback, 0, { clamp });
  }
  return Number.isFinite(fallback) ? fallback : 0;
}

function randomIntInRange(range, fallback = 0) {
  const value = randomInRange(range, fallback, { clamp: true });
  return Math.round(value);
}

function randomChoice(list, fallback = null) {
  if (Array.isArray(list) && list.length) {
    const index = Math.floor(Math.random() * list.length);
    return list[Math.max(0, Math.min(list.length - 1, index))];
  }
  return fallback;
}

function damp(current, target, rate, delta) {
  const clampedRate = Math.max(0, rate);
  const frame = Math.max(0, delta);
  if (clampedRate === 0 || frame === 0) return current;
  const factor = 1 - Math.exp(-clampedRate * frame);
  return current + (target - current) * factor;
}

/* Renderer/Scene/Camera */
const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(2, window.devicePixelRatio || 1));
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0, 480);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.dampingFactor = 0.06;
controls.rotateSpeed = 0.6;
controls.zoomSpeed = 0.6;

const clusterGroup = new THREE.Group();
scene.add(clusterGroup);

const FELDAPPEN_CENTER = new THREE.Vector3(0, 0, 0);

const stlGroup = new THREE.Group();
stlGroup.name = 'feldappenVolume';
stlGroup.visible = false;
clusterGroup.add(stlGroup);

const ambientLight = new THREE.AmbientLight(0xffffff, 0.45);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
directionalLight.position.set(220, 340, 260);
directionalLight.target.position.copy(FELDAPPEN_CENTER);
scene.add(directionalLight);
scene.add(directionalLight.target);

clusterGroup.position.copy(FELDAPPEN_CENTER);
controls.target.copy(FELDAPPEN_CENTER);
controls.update();
const stlLoader = new THREE.STLLoader();
const MAX_STL_POINTS = 18000;
let stlMaterial = null;
const stlState = {
  files: [],
  points: null,
  boundingRadius: 0,
  samples: null,
  sampleCount: 0,
  displayMode: 'overlay',
  previousDistribution: null
};
const stlUI = {
  input: null,
  meta: null,
  clearBtn: null
};
let stlDistributionOption = null;

/* Parameters */
const params = {
  count: 2500,
  radius: 140,
  distribution: 'random',
  sizeVar: 4.0,
  cluster: 0.65,
  pointAlpha: 0.95,
  pointHue: 210,
  pointSaturation: 0.75,
  pointValue: 1.0,
  colorMode: 'uniform',
  colorIntensity: 0.8,
  colorSpeed: 1.0,
  hueSpread: 45,
  colorPropagationDistance: 140,
  colorPropagationDuration: 6,
  colorToneCount: 3,
  seedStars: 1,
  catSmallCount: 1125,
  catMediumCount: 875,
  catLargeCount: 500,
  // Size factors
  sizeFactorTiny: 0.15,
  sizeFactorSmall: 1.0,
  sizeFactorMedium: 1.5,
  sizeFactorLarge: 2.0,
  // Tiny points / connections
  tinyCount: 2000,
  connPercent: 0.5,
  tinyAlpha: 0.5,
  seedTiny: 1,
  // Edge & blending
  edgeSoftness: 0.6,
  blending: 'Normal',
  filled: false,
  // Motion
  motionMode: 'static',
  motionSpeed: 1.0,
  motionAmplitude: 8.0,
  motionNoiseStrength: 1.0,
  motionNoiseScale: 1.0
};

function clampTotalCount(value) {
  const numeric = Math.floor(Number(value) || 0);
  return Math.max(0, numeric);
}

const colorState = {
  point: new THREE.Color(),
  accent: new THREE.Color(),
  dim: new THREE.Color(),
  radius: params.radius
};
const COLOR_MODES = ['uniform', 'radialPulse', 'axisWave', 'phaseFlicker', 'randomHue'];
const MOTION_MODES = ['static', 'sine', 'noise', 'orbit'];
const EXPERIENCE_BIOMES = Object.freeze([
  {
    name: 'Aurora Drift',
    distribution: ['fibonacci', 'spiral'],
    count: [2200, 4200],
    radius: [120, 200],
    sizeVar: [3.2, 6.2],
    cluster: [0.25, 0.55],
    pointAlpha: [0.55, 0.78],
    pointHueRanges: [[160, 220]],
    pointSaturation: [0.55, 0.85],
    pointValue: [0.68, 0.95],
    colorMode: ['radialPulse', 'axisWave'],
    colorIntensity: [0.55, 0.9],
    colorSpeed: [0.18, 0.55],
    hueSpread: [60, 140],
    colorPropagationDistance: [120, 220],
    colorPropagationDuration: [3.2, 7.5],
    colorToneCount: [2, 4],
    motionMode: ['sine', 'noise'],
    motionSpeed: [0.28, 0.75],
    motionAmplitude: [6, 18],
    motionNoiseStrength: [0.35, 0.9],
    motionNoiseScale: [0.6, 1.6],
    catDistribution: [0.44, 0.36, 0.2],
    sizeFactorTiny: [0.08, 0.24],
    sizeFactorSmall: [0.6, 1.2],
    sizeFactorMedium: [0.8, 1.6],
    sizeFactorLarge: [1.1, 2.4],
    tinyCount: [600, 1800],
    tinyAlpha: [0.18, 0.36],
    connPercent: [0.18, 0.38],
    edgeSoftness: [0.45, 0.78],
    blending: ['Additive'],
    filledChance: 0.15,
  },
  {
    name: 'Celestial Bloom',
    distribution: ['fibonacci', 'cylinder', 'spiral'],
    count: [2800, 5200],
    radius: [140, 210],
    sizeVar: [2.4, 5.2],
    cluster: [0.3, 0.6],
    pointAlpha: [0.45, 0.7],
    pointHueRanges: [[330, 360], [0, 32], [28, 56]],
    pointSaturation: [0.4, 0.7],
    pointValue: [0.72, 1.0],
    colorMode: ['phaseFlicker', 'radialPulse'],
    colorIntensity: [0.45, 0.85],
    colorSpeed: [0.24, 0.8],
    hueSpread: [40, 110],
    colorPropagationDistance: [100, 180],
    colorPropagationDuration: [4.5, 8.5],
    colorToneCount: [2, 5],
    motionMode: ['sine', 'noise'],
    motionSpeed: [0.24, 0.68],
    motionAmplitude: [5, 14],
    motionNoiseStrength: [0.25, 0.8],
    motionNoiseScale: [0.5, 1.4],
    catDistribution: [0.36, 0.38, 0.26],
    sizeFactorTiny: [0.09, 0.28],
    sizeFactorSmall: [0.7, 1.6],
    sizeFactorMedium: [1.1, 2.4],
    sizeFactorLarge: [1.5, 2.9],
    tinyCount: [900, 2200],
    tinyAlpha: [0.2, 0.42],
    connPercent: [0.22, 0.48],
    edgeSoftness: [0.35, 0.72],
    blending: ['Normal', 'Additive'],
    filledChance: 0.35,
  },
  {
    name: 'Obsidian Pulse',
    distribution: ['random', 'octahedron', 'spiral'],
    count: [2600, 4800],
    radius: [110, 180],
    sizeVar: [4.2, 7.0],
    cluster: [0.4, 0.75],
    pointAlpha: [0.55, 0.85],
    pointHueRanges: [[200, 240], [240, 290], [300, 330]],
    pointSaturation: [0.6, 0.9],
    pointValue: [0.45, 0.85],
    colorMode: ['axisWave', 'randomHue'],
    colorIntensity: [0.65, 0.95],
    colorSpeed: [0.45, 1.4],
    hueSpread: [80, 160],
    colorPropagationDistance: [150, 260],
    colorPropagationDuration: [2.8, 5.8],
    colorToneCount: [3, 6],
    motionMode: ['noise', 'sine'],
    motionSpeed: [0.36, 0.9],
    motionAmplitude: [8, 22],
    motionNoiseStrength: [0.45, 1.2],
    motionNoiseScale: [0.8, 2.4],
    catDistribution: [0.4, 0.32, 0.28],
    sizeFactorTiny: [0.1, 0.32],
    sizeFactorSmall: [0.5, 1.1],
    sizeFactorMedium: [1.0, 2.0],
    sizeFactorLarge: [1.8, 3.3],
    tinyCount: [400, 1200],
    tinyAlpha: [0.26, 0.5],
    connPercent: [0.28, 0.6],
    edgeSoftness: [0.28, 0.6],
    blending: ['Additive'],
    filledChance: 0.1,
  },
  {
    name: 'Deep Sea Shimmer',
    distribution: ['fibonacci', 'cylinder', 'random'],
    count: [2300, 4300],
    radius: [130, 210],
    sizeVar: [3.4, 5.8],
    cluster: [0.2, 0.5],
    pointAlpha: [0.5, 0.78],
    pointHueRanges: [[170, 210], [190, 230]],
    pointSaturation: [0.55, 0.85],
    pointValue: [0.6, 0.92],
    colorMode: ['radialPulse', 'axisWave'],
    colorIntensity: [0.5, 0.85],
    colorSpeed: [0.2, 0.7],
    hueSpread: [50, 120],
    colorPropagationDistance: [130, 240],
    colorPropagationDuration: [3.2, 6.5],
    colorToneCount: [2, 4],
    motionMode: ['noise', 'sine'],
    motionSpeed: [0.3, 0.78],
    motionAmplitude: [7, 16],
    motionNoiseStrength: [0.35, 0.95],
    motionNoiseScale: [0.7, 1.9],
    catDistribution: [0.38, 0.36, 0.26],
    sizeFactorTiny: [0.08, 0.26],
    sizeFactorSmall: [0.7, 1.4],
    sizeFactorMedium: [1.1, 2.1],
    sizeFactorLarge: [1.6, 2.8],
    tinyCount: [700, 2000],
    tinyAlpha: [0.22, 0.4],
    connPercent: [0.2, 0.42],
    edgeSoftness: [0.38, 0.75],
    blending: ['Normal'],
    filledChance: 0.25,
  },
]);

const PLAYER_STYLE_PRESETS = Object.freeze({
  nebula: {
    name: 'Nebula',
    distribution: ['fibonacci', 'spiral'],
    count: [2200, 3600],
    radius: [120, 180],
    sizeVar: [3.2, 5.5],
    cluster: [0.25, 0.55],
    pointAlpha: [0.6, 0.8],
    pointHueRanges: [[180, 240]],
    pointSaturation: [0.65, 0.95],
    pointValue: [0.72, 0.95],
    colorMode: ['radialPulse', 'axisWave'],
    colorIntensity: [0.6, 0.95],
    colorSpeed: [0.6, 1.3],
    hueSpread: [25, 55],
    colorPropagationDistance: [120, 220],
    colorPropagationDuration: [5, 10],
    colorToneCount: [3, 6],
    motionMode: ['sine', 'orbit'],
    motionSpeed: [0.6, 1.1],
    motionAmplitude: [6, 12],
    motionNoiseStrength: [0.35, 0.6],
    motionNoiseScale: [0.8, 1.3],
    catDistribution: [0.36, 0.32],
    tinyCount: [1500, 2600],
    connPercent: [0.25, 0.55],
    tinyAlpha: [0.45, 0.7],
    edgeSoftness: [0.45, 0.7],
    blending: ['Additive', 'Normal']
  },
  orbit: {
    name: 'Orbit',
    distribution: ['random', 'fibonacci'],
    count: [1800, 2400],
    radius: [140, 220],
    sizeVar: [2.5, 4.1],
    cluster: [0.15, 0.4],
    pointAlpha: [0.7, 0.9],
    pointHueRanges: [[180, 260]],
    pointSaturation: [0.4, 0.8],
    pointValue: [0.6, 0.95],
    colorMode: ['axisWave', 'uniform'],
    colorIntensity: [0.55, 0.9],
    colorSpeed: [0.35, 0.9],
    hueSpread: [10, 30],
    colorPropagationDistance: [90, 160],
    colorPropagationDuration: [4, 8],
    colorToneCount: [2, 4],
    motionMode: ['orbit'],
    motionSpeed: [0.4, 0.9],
    motionAmplitude: [4, 10],
    motionNoiseStrength: [0.2, 0.45],
    motionNoiseScale: [0.8, 1.2],
    catDistribution: [0.4, 0.34],
    tinyCount: [1100, 2200],
    connPercent: [0.18, 0.48],
    tinyAlpha: [0.4, 0.65],
    edgeSoftness: [0.4, 0.65],
    blending: ['Normal', 'Additive']
  },
  spiral: {
    name: 'Spiral',
    distribution: ['spiral'],
    count: [1800, 3200],
    radius: [140, 220],
    sizeVar: [2.8, 5.2],
    cluster: [0.35, 0.6],
    pointAlpha: [0.6, 0.82],
    pointHueRanges: [[15, 60], [290, 340]],
    pointSaturation: [0.65, 0.95],
    pointValue: [0.7, 1],
    colorMode: ['phaseFlicker', 'radialPulse'],
    colorIntensity: [0.65, 1],
    colorSpeed: [0.9, 1.6],
    hueSpread: [40, 90],
    colorPropagationDistance: [140, 240],
    colorPropagationDuration: [6, 12],
    colorToneCount: [3, 6],
    motionMode: ['sine', 'orbit'],
    motionSpeed: [0.7, 1.3],
    motionAmplitude: [8, 14],
    motionNoiseStrength: [0.35, 0.7],
    motionNoiseScale: [0.9, 1.5],
    catDistribution: [0.32, 0.36],
    tinyCount: [1500, 2800],
    connPercent: [0.35, 0.62],
    tinyAlpha: [0.42, 0.7],
    edgeSoftness: [0.5, 0.75],
    blending: ['Additive', 'Normal']
  },
  cluster: {
    name: 'Cluster',
    distribution: ['cube', 'cylinder', 'octahedron'],
    count: [2600, 3800],
    radius: [120, 200],
    sizeVar: [3, 6.2],
    cluster: [0.55, 0.85],
    pointAlpha: [0.55, 0.78],
    pointHueRanges: [[120, 210]],
    pointSaturation: [0.55, 0.9],
    pointValue: [0.6, 0.9],
    colorMode: ['axisWave', 'phaseFlicker'],
    colorIntensity: [0.55, 0.9],
    colorSpeed: [0.45, 1.15],
    hueSpread: [20, 55],
    colorPropagationDistance: [160, 260],
    colorPropagationDuration: [5, 10],
    colorToneCount: [2, 5],
    motionMode: ['noise', 'sine'],
    motionSpeed: [0.6, 1.2],
    motionAmplitude: [10, 18],
    motionNoiseStrength: [0.5, 0.85],
    motionNoiseScale: [0.9, 1.6],
    catDistribution: [0.45, 0.3],
    tinyCount: [2400, 3600],
    connPercent: [0.35, 0.7],
    tinyAlpha: [0.45, 0.75],
    edgeSoftness: [0.55, 0.78],
    blending: ['Normal', 'Additive']
  }
});

const PLAYER_MOOD_PRESETS = Object.freeze({
  cool: { h: 200, s: 0.75, v: 1, spread: 35 },
  warm: { h: 28, s: 0.9, v: 1, spread: 30 },
  pastel: { h: 320, s: 0.45, v: 1, spread: 18 },
  mono: { h: 210, s: 0.05, v: 0.92, spread: 4 },
  auto: null
});

function randomHueFromRanges(ranges, fallbackRange = [0, 360]) {
  if (Array.isArray(ranges) && ranges.length) {
    const choice = randomChoice(ranges);
    if (Array.isArray(choice) && choice.length === 2) {
      return normalizeHue(randomInRange(choice, normalizeHue(randomInRange(fallbackRange))));
    }
    if (Number.isFinite(choice)) {
      return normalizeHue(choice);
    }
  }
  if (Array.isArray(fallbackRange) && fallbackRange.length === 2) {
    return normalizeHue(randomInRange(fallbackRange, 0));
  }
  if (Number.isFinite(fallbackRange)) {
    return normalizeHue(fallbackRange);
  }
  return normalizeHue(Math.random() * 360);
}

function distributeCategoryCounts(total, weights = []) {
  const safeTotal = Math.max(0, Math.floor(Number(total) || 0));
  if (!Array.isArray(weights) || weights.length !== 3) {
    const base = Math.floor(safeTotal / 3);
    const remainder = safeTotal - base * 3;
    return [base + (remainder > 0 ? 1 : 0), base + (remainder > 1 ? 1 : 0), safeTotal - base * 2 - (remainder > 0 ? 1 : 0) - (remainder > 1 ? 1 : 0)];
  }
  const normalized = weights.map(value => Math.max(0, Number(value) || 0));
  const sum = normalized.reduce((acc, value) => acc + value, 0) || 1;
  const provisional = normalized.map(value => Math.floor((value / sum) * safeTotal));
  let assigned = provisional.reduce((acc, value) => acc + value, 0);
  let index = 0;
  while (assigned < safeTotal && index < 300) {
    provisional[index % provisional.length] += 1;
    assigned += 1;
    index += 1;
  }
  const [small, medium, large] = provisional;
  return [small, medium, Math.max(0, safeTotal - small - medium)];
}

function applyBiomePreset(preset, { syncUI = true, repositionCamera = false } = {}) {
  if (!preset) {
    return null;
  }
  const totalCount = clampTotalCount(randomIntInRange(preset.count, params.count));
  params.count = totalCount;
  params.radius = Math.max(0, randomInRange(preset.radius, params.radius));
  params.sizeVar = Math.max(0, randomInRange(preset.sizeVar, params.sizeVar));
  params.cluster = clamp01(randomInRange(preset.cluster, params.cluster));
  params.pointAlpha = clamp01(randomInRange(preset.pointAlpha, params.pointAlpha));
  params.pointHue = randomHueFromRanges(preset.pointHueRanges, preset.pointHue || [0, 360]);
  params.pointSaturation = clamp01(randomInRange(preset.pointSaturation, params.pointSaturation));
  params.pointValue = clamp01(randomInRange(preset.pointValue, params.pointValue));
  params.colorMode = randomChoice(preset.colorMode, params.colorMode);
  params.colorIntensity = clamp01(randomInRange(preset.colorIntensity, params.colorIntensity));
  params.colorSpeed = Math.max(0, randomInRange(preset.colorSpeed, params.colorSpeed));
  params.hueSpread = Math.max(0, randomInRange(preset.hueSpread, params.hueSpread));
  params.colorPropagationDistance = Math.max(0, randomInRange(preset.colorPropagationDistance, params.colorPropagationDistance));
  params.colorPropagationDuration = Math.max(0.25, randomInRange(preset.colorPropagationDuration, params.colorPropagationDuration));
  params.colorToneCount = Math.max(1, randomIntInRange(preset.colorToneCount, params.colorToneCount));
  const availableDistributions = getAvailableDistributions();
  let presetDistribution = preset.distribution;
  if (Array.isArray(presetDistribution)) {
    presetDistribution = presetDistribution.filter(option => availableDistributions.includes(option));
  } else if (typeof presetDistribution === 'string' && !availableDistributions.includes(presetDistribution)) {
    presetDistribution = null;
  }
  const fallbackDistribution = availableDistributions.includes(params.distribution)
    ? params.distribution
    : 'random';
  const chosenDistribution = Array.isArray(presetDistribution) && presetDistribution.length
    ? randomChoice(presetDistribution, fallbackDistribution)
    : (typeof presetDistribution === 'string' ? presetDistribution : fallbackDistribution);
  params.distribution = availableDistributions.includes(chosenDistribution)
    ? chosenDistribution
    : fallbackDistribution;
  params.motionMode = randomChoice(preset.motionMode, params.motionMode);
  params.motionSpeed = Math.max(0, randomInRange(preset.motionSpeed, params.motionSpeed));
  params.motionAmplitude = Math.max(0, randomInRange(preset.motionAmplitude, params.motionAmplitude));
  params.motionNoiseStrength = Math.max(0, randomInRange(preset.motionNoiseStrength, params.motionNoiseStrength));
  params.motionNoiseScale = Math.max(0.1, randomInRange(preset.motionNoiseScale, params.motionNoiseScale));
  const [catSmall, catMedium, catLarge] = distributeCategoryCounts(totalCount, preset.catDistribution);
  params.catSmallCount = catSmall;
  params.catMediumCount = catMedium;
  params.catLargeCount = Math.max(0, totalCount - catSmall - catMedium);
  params.sizeFactorTiny = Math.max(0, randomInRange(preset.sizeFactorTiny, params.sizeFactorTiny));
  params.sizeFactorSmall = Math.max(0.05, randomInRange(preset.sizeFactorSmall, params.sizeFactorSmall));
  params.sizeFactorMedium = Math.max(0.05, randomInRange(preset.sizeFactorMedium, params.sizeFactorMedium));
  params.sizeFactorLarge = Math.max(0.05, randomInRange(preset.sizeFactorLarge, params.sizeFactorLarge));
  params.tinyCount = Math.max(0, randomIntInRange(preset.tinyCount, params.tinyCount));
  params.connPercent = clamp01(randomInRange(preset.connPercent, params.connPercent));
  params.tinyAlpha = clamp01(randomInRange(preset.tinyAlpha, params.tinyAlpha));
  params.edgeSoftness = clamp01(randomInRange(preset.edgeSoftness, params.edgeSoftness));
  params.blending = randomChoice(preset.blending, params.blending);
  const filledChance = Number.isFinite(preset.filledChance) ? preset.filledChance : 0;
  params.filled = Math.random() < Math.max(0, Math.min(1, filledChance));
  params.seedStars = 1 + Math.floor(Math.random() * 9999);
  params.seedTiny = 1 + Math.floor(Math.random() * 9999);
  enforceBounds();
  updatePointColor();
  rebuildStars();
  updateStarUniforms();
  updateTinyMaterial();
  if (repositionCamera) {
    focusOnFeldappenCenter({ repositionCamera: true });
  }
  if (syncUI) {
    setSliders();
  }
  return preset.name || null;
}

function generateRandomBiome(options = {}) {
  const preset = randomChoice(EXPERIENCE_BIOMES);
  if (!preset) {
    return null;
  }
  return applyBiomePreset(preset, options);
}

function setPlayerChipState(group, activeKey) {
  const chips = group ? Array.from(group.querySelectorAll('button')) : [];
  chips.forEach(chip => {
    const pressed = chip.dataset.style === activeKey || chip.dataset.mood === activeKey;
    chip.dataset.pressed = pressed ? 'true' : 'false';
    chip.setAttribute('aria-pressed', pressed ? 'true' : 'false');
  });
}

function applyPlayerStyle(styleKey) {
  const preset = PLAYER_STYLE_PRESETS[styleKey];
  if (!preset) return;
  applyBiomePreset(preset, { syncUI: true, repositionCamera: false });
  setPlayerChipState(playerUI.styles, styleKey);
}

function applyPlayerMood(moodKey) {
  const preset = PLAYER_MOOD_PRESETS[moodKey];
  if (!preset) {
    setPlayerChipState(playerUI.moods, 'auto');
    return;
  }
  params.pointHue = preset.h;
  params.pointSaturation = preset.s;
  params.pointValue = preset.v;
  params.hueSpread = preset.spread;
  updatePointColor();
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
  setPlayerChipState(playerUI.moods, moodKey);
}

function applyPlayerComplexityMacro(value) {
  const t = clamp01(Number(value));
  const baseTotal = 1500 + t * 2200;
  const cluster = 0.2 + t * 0.55;
  const tinyCount = 800 + t * 2800;
  const connections = 0.18 + t * 0.55;
  const small = Math.floor(baseTotal * (0.42 + t * 0.08));
  const medium = Math.floor(baseTotal * (0.34 - t * 0.06));
  params.catSmallCount = small;
  params.catMediumCount = medium;
  params.catLargeCount = Math.max(0, Math.floor(baseTotal - small - medium));
  params.cluster = cluster;
  params.tinyCount = Math.round(tinyCount);
  params.connPercent = clamp01(connections);
  params.sizeVar = 2.8 + t * 3.5;
  rebuildStars();
  rebuildTiny();
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
}

function applyPlayerMotionMacro(value) {
  const t = clamp01(Number(value));
  params.motionMode = t < 0.25 ? 'static' : (t < 0.6 ? 'sine' : 'noise');
  params.motionSpeed = 0.35 + t * 1.4;
  params.motionAmplitude = 4 + t * 16;
  params.motionNoiseStrength = 0.25 + t * 0.8;
  params.motionNoiseScale = 0.8 + t * 1.0;
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
}

function applyPlayerReactivityMacro(value) {
  const strength = Math.max(0, Number(value));
  Object.keys(audioState.intensity || {}).forEach(key => {
    audioState.intensity[key] = strength;
  });
  syncAudioIntensityControls();
}
const motionState = { time: 0 };

function getFeldappenFocusRadius() {
  const values = [
    Number.isFinite(colorState.radius) ? colorState.radius : 0,
    Number.isFinite(stlState.boundingRadius) ? stlState.boundingRadius : 0,
    Number.isFinite(params.radius) ? params.radius : 0,
    80
  ];
  return Math.max(...values);
}

function focusOnFeldappenCenter({ repositionCamera = true } = {}) {
  const target = FELDAPPEN_CENTER;
  controls.target.copy(target);
  clusterGroup.position.copy(target);
  if (repositionCamera) {
    const distance = Math.max(getFeldappenFocusRadius() * 3.2, 320);
    camera.position.set(target.x, target.y, target.z + distance);
  }
  controls.update();
}

function updateStlMeta(files = stlState.files || [], { loading = false, error = '' } = {}) {
  const names = Array.isArray(files)
    ? files.map(item => (typeof item === 'string' ? item : (item && item.name) || '')).filter(Boolean)
    : [];
  if (stlUI.meta) {
    let text = 'Keine Auswahl';
    let state = 'idle';
    if (error) {
      text = error;
      state = 'error';
    } else if (loading) {
      text = 'Lade STL-Dateien ‚Ä¶';
      state = 'loading';
    } else if (names.length) {
      text = names.length === 1
        ? `Geladen: ${names[0]}`
        : `Geladen: ${names.length} STL-Dateien`;
      state = 'ready';
      if (stlState.displayMode === 'distribution') {
        text += ' ‚Äì als Verteilungsalgorithmus aktiv';
      } else {
        text += ' ‚Äì zus√§tzlich eingeblendet';
      }
    }
    stlUI.meta.textContent = text;
    stlUI.meta.dataset.state = state;
    if (!loading && !error && names.length) {
      stlUI.meta.dataset.mode = stlState.displayMode || 'overlay';
    } else if (stlUI.meta.dataset.mode) {
      delete stlUI.meta.dataset.mode;
    }
  }
  if (stlUI.clearBtn) {
    stlUI.clearBtn.disabled = loading || !stlState.points;
  }
  if (stlUI.input) {
    stlUI.input.disabled = loading;
  }
}

function clearStlModels({ keepCamera = false, skipInputReset = false, preserveMeta = false, preserveUsage = false } = {}) {
  const hadPoints = Boolean(stlState.points);
  if (stlState.points) {
    if (stlState.points.geometry) {
      stlState.points.geometry.dispose();
    }
    stlGroup.remove(stlState.points);
    stlState.points = null;
  }
  stlGroup.visible = false;
  stlState.files = [];
  stlState.boundingRadius = 0;
  stlState.samples = null;
  stlState.sampleCount = 0;
  if (!preserveUsage) {
    stlState.displayMode = 'overlay';
    stlState.previousDistribution = null;
  }
  if (!skipInputReset && stlUI.input) {
    stlUI.input.value = '';
  }
  if (!preserveMeta) {
    updateStlMeta([]);
  } else if (stlUI.clearBtn) {
    stlUI.clearBtn.disabled = true;
  }
  if (!preserveUsage) {
    const reverted = revertFromStlDistribution();
    if (reverted) {
      rebuildStars();
      setSliders();
    }
  }
  updateStlOptionAvailability();
  updateStarUniforms();
  if (hadPoints && !keepCamera) {
    focusOnFeldappenCenter({ repositionCamera: true });
  }
}

function hasStlSamples() {
  return stlState.samples instanceof Float32Array && stlState.sampleCount > 0;
}

function getAvailableDistributions() {
  const base = ['random', 'fibonacci', 'spiral', 'cube', 'cylinder', 'octahedron'];
  if (hasStlSamples()) {
    base.push('stl');
  }
  return base;
}

function updateStlVisibility() {
  stlGroup.visible = Boolean(stlState.points && stlState.displayMode === 'overlay');
}

function updateStlOptionAvailability() {
  if (!stlDistributionOption) return;
  const available = hasStlSamples();
  stlDistributionOption.hidden = available ? false : true;
  stlDistributionOption.disabled = available ? false : true;
}

function useStlAsDistribution({ rememberPrevious = true } = {}) {
  if (!hasStlSamples()) {
    return false;
  }
  if (rememberPrevious && params.distribution !== 'stl') {
    stlState.previousDistribution = params.distribution;
  }
  params.distribution = 'stl';
  stlState.displayMode = 'distribution';
  return true;
}

function revertFromStlDistribution({ fallback = 'random' } = {}) {
  if (params.distribution !== 'stl') {
    return false;
  }
  const fallbackValue = stlState.previousDistribution && stlState.previousDistribution !== 'stl'
    ? stlState.previousDistribution
    : fallback;
  stlState.previousDistribution = null;
  params.distribution = fallbackValue;
  if (stlState.displayMode === 'distribution') {
    stlState.displayMode = 'overlay';
  }
  return true;
}

function mergeStlGeometries(geometries) {
  if (!Array.isArray(geometries) || !geometries.length) {
    return null;
  }
  let totalVertices = 0;
  let hasNormals = true;
  let hasColors = false;
  let alpha = 1;
  geometries.forEach(geometry => {
    if (!geometry || !geometry.getAttribute) {
      return;
    }
    const position = geometry.getAttribute('position');
    if (!position) {
      return;
    }
    totalVertices += position.count;
    if (!geometry.getAttribute('normal')) {
      hasNormals = false;
    }
    if (geometry.hasColors && geometry.getAttribute('color')) {
      hasColors = true;
      if (typeof geometry.alpha === 'number') {
        alpha = Math.min(alpha, geometry.alpha);
      }
    }
  });
  if (!Number.isFinite(totalVertices) || totalVertices <= 0) {
    return null;
  }
  const merged = new THREE.BufferGeometry();
  const positions = new Float32Array(totalVertices * 3);
  const normals = hasNormals ? new Float32Array(totalVertices * 3) : null;
  const colors = hasColors ? new Float32Array(totalVertices * 3) : null;
  let vertexOffset = 0;
  geometries.forEach(geometry => {
    if (!geometry || !geometry.getAttribute) {
      return;
    }
    const position = geometry.getAttribute('position');
    if (!position) {
      return;
    }
    positions.set(position.array, vertexOffset * 3);
    if (hasNormals) {
      const normal = geometry.getAttribute('normal');
      if (normal && normal.count === position.count) {
        normals.set(normal.array, vertexOffset * 3);
      }
    }
    if (hasColors) {
      const colorAttr = geometry.getAttribute('color');
      if (colorAttr && colorAttr.count === position.count) {
        colors.set(colorAttr.array, vertexOffset * 3);
      }
    }
    vertexOffset += position.count;
  });
  merged.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  if (hasNormals && normals) {
    merged.setAttribute('normal', new THREE.BufferAttribute(normals, 3));
  } else {
    merged.computeVertexNormals();
  }
  if (hasColors && colors) {
    merged.setAttribute('color', new THREE.BufferAttribute(colors, 3));
    merged.hasColors = true;
    merged.alpha = alpha;
  }
  return merged;
}

function ensureStlMaterial() {
  if (stlMaterial) {
    return stlMaterial;
  }
  if (!starMaterial) {
    return null;
  }
  const uniforms = THREE.UniformsUtils.clone(starMaterial.uniforms);
  stlMaterial = new THREE.ShaderMaterial({
    vertexShader: starMaterial.vertexShader,
    fragmentShader: starMaterial.fragmentShader,
    transparent: starMaterial.transparent,
    depthTest: starMaterial.depthTest,
    depthWrite: starMaterial.depthWrite,
    blending: starMaterial.blending,
    uniforms
  });
  return stlMaterial;
}

function applyStlGeometry(geometry, fileNames = []) {
  if (!(geometry instanceof THREE.BufferGeometry)) {
    return;
  }
  if (geometry.index) {
    const nonIndexed = geometry.toNonIndexed();
    geometry.dispose();
    geometry = nonIndexed;
  }
  if (stlState.points) {
    clearStlModels({ keepCamera: true, skipInputReset: true, preserveMeta: true, preserveUsage: true });
  }
  geometry.computeBoundingBox();
  if (geometry.boundingBox) {
    const center = new THREE.Vector3();
    geometry.boundingBox.getCenter(center);
    geometry.translate(-center.x, -center.y, -center.z);
  }
  geometry.computeBoundingSphere();
  const radius = geometry.boundingSphere ? geometry.boundingSphere.radius : 0;
  stlState.boundingRadius = Number.isFinite(radius) ? Math.max(0, radius) : 0;
  const names = Array.isArray(fileNames) ? fileNames : [];
  const positionAttr = geometry.getAttribute ? geometry.getAttribute('position') : null;
  if (!positionAttr || !positionAttr.array || positionAttr.count <= 0) {
    geometry.dispose();
    return;
  }
  const sourceArray = positionAttr.array;
  const sourceCount = positionAttr.count;
  const targetCount = Math.min(sourceCount, MAX_STL_POINTS);
  const seed = hashStringList(names);
  const sampleRand = mulberry32((seed ^ 0x27d4eb2f) >>> 0);
  const positions = new Float32Array(targetCount * 3);
  const basePositions = new Float32Array(targetCount * 3);
  const triangleCount = Math.floor(sourceCount / 3);
  let usedSurfaceSampling = false;
  if (triangleCount > 0 && targetCount > 0) {
    const cumulativeAreas = new Float32Array(triangleCount);
    const vA = new THREE.Vector3();
    const vB = new THREE.Vector3();
    const vC = new THREE.Vector3();
    const edgeAB = new THREE.Vector3();
    const edgeAC = new THREE.Vector3();
    let totalArea = 0;
    for (let i = 0; i < triangleCount; i++) {
      const base = i * 9;
      vA.fromArray(sourceArray, base);
      vB.fromArray(sourceArray, base + 3);
      vC.fromArray(sourceArray, base + 6);
      edgeAB.subVectors(vB, vA);
      edgeAC.subVectors(vC, vA);
      const area = edgeAB.cross(edgeAC).length() * 0.5;
      totalArea += area;
      cumulativeAreas[i] = totalArea;
    }
    if (totalArea > 0) {
      usedSurfaceSampling = true;
      for (let i = 0; i < targetCount; i++) {
        const targetArea = sampleRand() * totalArea;
        let low = 0;
        let high = triangleCount - 1;
        while (low < high) {
          const mid = (low + high) >> 1;
          if (targetArea <= cumulativeAreas[mid]) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        const triBase = low * 9;
        const ax = sourceArray[triBase];
        const ay = sourceArray[triBase + 1];
        const az = sourceArray[triBase + 2];
        const bx = sourceArray[triBase + 3];
        const by = sourceArray[triBase + 4];
        const bz = sourceArray[triBase + 5];
        const cx = sourceArray[triBase + 6];
        const cy = sourceArray[triBase + 7];
        const cz = sourceArray[triBase + 8];
        const r1 = sampleRand();
        const r2 = sampleRand();
        const sqrtR1 = Math.sqrt(r1);
        const weightA = 1 - sqrtR1;
        const weightB = sqrtR1 * (1 - r2);
        const weightC = sqrtR1 * r2;
        const px = ax * weightA + bx * weightB + cx * weightC;
        const py = ay * weightA + by * weightB + cy * weightC;
        const pz = az * weightA + bz * weightB + cz * weightC;
        positions[i * 3] = px;
        positions[i * 3 + 1] = py;
        positions[i * 3 + 2] = pz;
        basePositions[i * 3] = px;
        basePositions[i * 3 + 1] = py;
        basePositions[i * 3 + 2] = pz;
      }
    }
  }
  if (!usedSurfaceSampling) {
    const indices = new Uint32Array(targetCount);
    if (sourceCount <= targetCount) {
      for (let i = 0; i < targetCount; i++) {
        indices[i] = i;
      }
    } else {
      const step = sourceCount / targetCount;
      for (let i = 0; i < targetCount; i++) {
        const base = i * step;
        let idx = Math.floor(base + sampleRand() * step);
        if (idx >= sourceCount) {
          idx = sourceCount - 1;
        }
        indices[i] = idx;
      }
    }
    for (let i = 0; i < targetCount; i++) {
      const srcIndex = indices[i] * 3;
      positions[i * 3] = sourceArray[srcIndex];
      positions[i * 3 + 1] = sourceArray[srcIndex + 1];
      positions[i * 3 + 2] = sourceArray[srcIndex + 2];
      basePositions[i * 3] = sourceArray[srcIndex];
      basePositions[i * 3 + 1] = sourceArray[srcIndex + 1];
      basePositions[i * 3 + 2] = sourceArray[srcIndex + 2];
    }
  }
  const phases = new Float32Array(targetCount);
  const sizes = new Float32Array(targetCount);
  const categories = new Float32Array(targetCount);
  const categoryRand = mulberry32(seed);
  const sizeRand = mulberry32((seed ^ 0x85ebca6b) >>> 0);
  const phaseRand = mulberry32((seed ^ 0x51f32a95) >>> 0);
  for (let i = 0; i < targetCount; i++) {
    phases[i] = phaseRand();
    const catRoll = categoryRand();
    categories[i] = catRoll < 0.25 ? 0 : (catRoll < 0.7 ? 1 : 2);
    sizes[i] = 0.85 + sizeRand() * 0.4;
  }
  const pointGeometry = new THREE.BufferGeometry();
  pointGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  pointGeometry.setAttribute('aBase', new THREE.BufferAttribute(basePositions, 3));
  pointGeometry.setAttribute('aPhase', new THREE.BufferAttribute(phases, 1));
  pointGeometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
  pointGeometry.setAttribute('aCat', new THREE.BufferAttribute(categories, 1));
  pointGeometry.setDrawRange(0, targetCount);
  pointGeometry.computeBoundingSphere();
  if (pointGeometry.boundingSphere) {
    pointGeometry.boundingSphere.center.set(0, 0, 0);
  }
  const material = ensureStlMaterial();
  if (!material) {
    pointGeometry.dispose();
    return;
  }
  const points = new THREE.Points(pointGeometry, material);
  points.name = 'feldappenVolumePoints';
  stlGroup.add(points);
  stlGroup.position.copy(FELDAPPEN_CENTER);
  stlState.points = points;
  stlState.files = names;
  stlState.samples = basePositions.slice(0);
  stlState.sampleCount = targetCount;
  updateStlOptionAvailability();
  updateStlVisibility();
  if (stlState.displayMode === 'distribution') {
    const applied = useStlAsDistribution({ rememberPrevious: true });
    if (applied) {
      rebuildStars();
      setSliders();
    } else {
      stlState.displayMode = 'overlay';
    }
  } else if (params.distribution === 'stl') {
    const reverted = revertFromStlDistribution();
    if (reverted) {
      rebuildStars();
      setSliders();
    }
  }
  updateStlMeta(names);
  updateStlVisibility();
  updateStarUniforms();
  focusOnFeldappenCenter({ repositionCamera: true });
  geometry.dispose();
}

function askStlUsageMode(files) {
  return new Promise(resolve => {
    const previousFocus = document.activeElement;
    const backdrop = document.createElement('div');
    backdrop.className = 'stl-mode-backdrop';
    backdrop.setAttribute('role', 'dialog');
    backdrop.setAttribute('aria-modal', 'true');
    const dialog = document.createElement('div');
    dialog.className = 'stl-mode-dialog';
    const headingId = `stl-mode-heading-${Date.now()}`;
    const title = document.createElement('h2');
    title.id = headingId;
    title.textContent = 'STL-Nutzung w√§hlen';
    dialog.setAttribute('aria-labelledby', headingId);
    const description = document.createElement('p');
    const fileHint = Array.isArray(files) && files.length === 1
      ? `(${files[0].name || 'STL-Datei'})`
      : '';
    description.textContent = fileHint
      ? `Wie sollen die importierten STL-Punkte ${fileHint} verwendet werden?`
      : 'Wie sollen die importierten STL-Punkte verwendet werden?';
    const actions = document.createElement('div');
    actions.className = 'stl-mode-actions';

    const overlayBtn = document.createElement('button');
    overlayBtn.type = 'button';
    overlayBtn.dataset.choice = 'overlay';
    overlayBtn.textContent = 'Zus√§tzlich anzeigen';

    const distributionBtn = document.createElement('button');
    distributionBtn.type = 'button';
    distributionBtn.dataset.choice = 'distribution';
    distributionBtn.textContent = 'Als Verteilungsalgorithmus nutzen';

    const cancelBtn = document.createElement('button');
    cancelBtn.type = 'button';
    cancelBtn.dataset.choice = 'cancel';
    cancelBtn.textContent = 'Abbrechen';

    actions.append(overlayBtn, distributionBtn, cancelBtn);
    dialog.append(title, description, actions);
    backdrop.appendChild(dialog);
    document.body.appendChild(backdrop);

    let settled = false;
    const cleanup = choice => {
      if (settled) return;
      settled = true;
      document.removeEventListener('keydown', onKeyDown);
      backdrop.removeEventListener('click', onBackdropClick);
      if (backdrop.parentNode) {
        backdrop.parentNode.removeChild(backdrop);
      }
      if (previousFocus && typeof previousFocus.focus === 'function') {
        previousFocus.focus();
      }
      resolve(choice);
    };

    const onKeyDown = event => {
      if (event.key === 'Escape') {
        event.preventDefault();
        cleanup('cancel');
      }
    };

    const onBackdropClick = event => {
      if (event.target === backdrop) {
        cleanup('cancel');
      }
    };

    overlayBtn.addEventListener('click', () => cleanup('overlay'));
    distributionBtn.addEventListener('click', () => cleanup('distribution'));
    cancelBtn.addEventListener('click', () => cleanup('cancel'));
    document.addEventListener('keydown', onKeyDown);
    backdrop.addEventListener('click', onBackdropClick);

    window.requestAnimationFrame(() => {
      overlayBtn.focus();
    });
  });
}

async function loadStlFilesFromInput(files) {
  const selection = Array.isArray(files) ? files.filter(Boolean) : [];
  if (!selection.length) {
    clearStlModels();
    return;
  }
  const mode = await askStlUsageMode(selection);
  if (mode === 'cancel') {
    updateStlMeta(stlState.files);
    if (stlUI.input) {
      stlUI.input.value = '';
    }
    return;
  }
  stlState.displayMode = mode === 'distribution' ? 'distribution' : 'overlay';
  updateStlMeta(selection, { loading: true });
  try {
    const geometries = [];
    for (const file of selection) {
      const buffer = await file.arrayBuffer();
      let geometry = stlLoader.parse(buffer);
      if (!geometry) {
        continue;
      }
      if (geometry.index) {
        const nonIndexed = geometry.toNonIndexed();
        geometry.dispose();
        geometry = nonIndexed;
      }
      geometry.computeVertexNormals();
      geometries.push(geometry);
    }
    if (!geometries.length) {
      throw new Error('Keine g√ºltigen STL-Geometrien gefunden.');
    }
    const merged = mergeStlGeometries(geometries);
    geometries.forEach(geometry => geometry.dispose());
    if (!merged) {
      throw new Error('Geometrien konnten nicht kombiniert werden.');
    }
    merged.computeVertexNormals();
    merged.computeBoundingBox();
    merged.computeBoundingSphere();
    const names = selection.map(file => (file && file.name) ? file.name : 'STL-Datei');
    applyStlGeometry(merged, names);
  } catch (error) {
    console.error('STL-Dateien konnten nicht geladen werden:', error);
    updateStlMeta([], { error: 'Fehler beim Laden der STL-Dateien.' });
    clearStlModels({ keepCamera: true, skipInputReset: true, preserveMeta: true });
  } finally {
    if (stlUI.input) {
      stlUI.input.disabled = false;
      stlUI.input.value = '';
    }
  }
}

function getMotionModeIndex() {
  const idx = MOTION_MODES.indexOf(params.motionMode);
  return idx >= 0 ? idx : 0;
}

function getColorModeIndex() {
  const idx = COLOR_MODES.indexOf(params.colorMode);
  return idx >= 0 ? idx : 0;
}

const AudioContextClass = window.AudioContext || window.webkitAudioContext || null;

const AUDIO_INTENSITY_DEFAULTS = Object.freeze({
  motion: 1,
  scale: 1,
  size: 1,
  hue: 1,
  saturation: 1,
  brightness: 1,
  alpha: 1
});

const AUDIO_INTENSITY_BASE_DEFAULTS = Object.freeze({
  motion: 0.1,
  scale: 1,
  size: 1,
  hue: 1,
  saturation: 1,
  brightness: 1,
  alpha: 1
});

const AUDIO_INTENSITY_LIMIT_DEFAULTS = Object.freeze({
  motion: 0.2,
  scale: 1,
  size: 1,
  hue: 1,
  saturation: 1,
  brightness: 1,
  alpha: 1
});

const AUDIO_DYNAMIC_INTENSITY_CONFIG = Object.freeze({
  motion: {
    min: 0.45,
    max: 1.55,
    hold: { min: 0.38, max: 1.1 },
    driver: metrics => Math.min(1.2, metrics.energy * 0.6 + metrics.bass * 0.85),
    pulse: 'bass',
    pulseThreshold: 0.08,
    pulseWeight: 0.65,
    randomWeight: 0.4,
    jitter: 0.18,
    damping: 3.8,
    relaxRate: 2.6
  },
  size: {
    min: 0.5,
    max: 1.8,
    hold: { min: 0.42, max: 1.35 },
    driver: metrics => Math.min(1.2, metrics.mid * 0.85 + metrics.wave * 0.65),
    pulse: 'mid',
    pulseThreshold: 0.07,
    pulseWeight: 0.6,
    randomWeight: 0.35,
    jitter: 0.22,
    damping: 3.4,
    relaxRate: 2.4
  },
  hue: {
    min: 0.35,
    max: 1.45,
    hold: { min: 0.52, max: 1.4 },
    driver: metrics => Math.min(1.2, metrics.treble * 0.95 + metrics.energy * 0.45),
    pulse: 'treble',
    pulseThreshold: 0.07,
    pulseWeight: 0.65,
    randomWeight: 0.45,
    jitter: 0.25,
    damping: 2.8,
    relaxRate: 2.2
  },
  saturation: {
    min: 0.45,
    max: 1.6,
    hold: { min: 0.55, max: 1.55 },
    driver: metrics => Math.min(1.2, metrics.treble * 0.9 + metrics.wave * 0.6),
    pulse: 'treble',
    pulseThreshold: 0.06,
    pulseWeight: 0.7,
    randomWeight: 0.4,
    jitter: 0.23,
    damping: 2.9,
    relaxRate: 2.3
  },
  brightness: {
    min: 0.45,
    max: 1.65,
    hold: { min: 0.5, max: 1.45 },
    driver: metrics => Math.min(1.2, metrics.energy * 0.95 + metrics.mid * 0.45),
    pulse: 'energy',
    pulseThreshold: 0.07,
    pulseWeight: 0.7,
    randomWeight: 0.35,
    jitter: 0.19,
    damping: 3.1,
    relaxRate: 2.5
  },
  alpha: {
    min: 0.4,
    max: 1.25,
    hold: { min: 0.55, max: 1.6 },
    driver: metrics => Math.min(1.2, metrics.wave * 0.85 + metrics.energy * 0.55),
    pulse: 'wave',
    pulseThreshold: 0.05,
    pulseWeight: 0.6,
    randomWeight: 0.32,
    jitter: 0.2,
    damping: 3.0,
    relaxRate: 2.4
  }
});

const PRESET_AUDIO_DIRECTORY = 'Musik/';
const PRESET_PLAYLIST_MANIFEST = `${PRESET_AUDIO_DIRECTORY}playlist.json`;

let presetPlaylistPromise = null;

const audioState = {
  context: null,
  analyser: null,
  freqData: null,
  timeData: null,
  source: null,
  youtubeActive: false,
  micStream: null,
  playing: false,
  usingMic: false,
  trackDuration: 0,
  playbackStartedAt: 0,
  pausedAt: 0,
  currentBuffer: null,
  playlist: [],
  currentTrack: null,
  currentIndex: -1,
  selectedFile: null,
  fileName: '',
  repeatMode: 'off',
  status: 'idle',
  metrics: { energy: 0, bass: 0, mid: 0, treble: 0, wave: 0 },
  visual: { motion: 0, size: 1, hue: 0, alpha: 0, scale: 1, saturation: 0, brightness: 0 },
  modifiers: {
    motion: true,
    scale: true,
    size: true,
    hue: true,
    saturation: true,
    brightness: true,
    alpha: true
  },
  intensity: { ...AUDIO_INTENSITY_BASE_DEFAULTS },
  intensityLimits: { ...AUDIO_INTENSITY_LIMIT_DEFAULTS },
  dynamicIntensity: { ...AUDIO_INTENSITY_DEFAULTS },
  dynamicTargets: { ...AUDIO_INTENSITY_DEFAULTS },
  dynamicTimers: {},
  color: new THREE.Color(),
  silenceLevel: 1,
  brightnessAdaptationEnabled: true,
  needsResume: false,
  motionDirection: 1,
  pitchDirection: 1,
  motionFlipCooldown: 0,
  pitchFlipCooldown: 0,
  previousBass: 0,
  previousTreble: 0,
  previousEnergy: 0,
  previousWave: 0,
  previousMid: 0
};

const youtubeState = {
  apiPromise: null,
  player: null,
  ready: false,
  loading: false,
  playlistId: '',
  currentVideoTitle: '',
  stream: null,
  streamSource: null
};

const RECENT_YOUTUBE_STORAGE_KEY = 'oc_recent_youtube_playlists';
const RECENT_YOUTUBE_LIMIT = 6;
let recentYouTubePlaylists = [];

let trackIdCounter = 0;

function createTrackId() {
  trackIdCounter += 1;
  return `track-${Date.now()}-${trackIdCounter}`;
}

function loadRecentYouTubePlaylists() {
  try {
    const stored = localStorage.getItem(RECENT_YOUTUBE_STORAGE_KEY);
    if (!stored) return [];
    const parsed = JSON.parse(stored);
    return Array.isArray(parsed) ? parsed.slice(0, RECENT_YOUTUBE_LIMIT) : [];
  } catch (error) {
    console.warn('Konnte gespeicherte YouTube-Playlists nicht laden:', error);
    return [];
  }
}

function persistRecentYouTubePlaylists(list) {
  try {
    localStorage.setItem(RECENT_YOUTUBE_STORAGE_KEY, JSON.stringify(list.slice(0, RECENT_YOUTUBE_LIMIT)));
  } catch (error) {
    console.warn('Konnte YouTube-Verlauf nicht speichern:', error);
  }
}

function formatRecentPlaylistLabel(entry) {
  const label = entry.title && entry.title.trim() ? entry.title.trim() : 'Playlist';
  const countLabel = Number.isFinite(entry.trackCount) && entry.trackCount > 0
    ? ` ¬∑ ${entry.trackCount} Titel`
    : '';
  return `${label}${countLabel}`;
}

function rememberRecentPlaylist({ inputValue = '', playlistId = '', title = '', trackCount = 0 } = {}) {
  const value = (inputValue || playlistId || '').trim();
  if (!value) return;
  const normalizedId = playlistId || parseYouTubePlaylistId(value) || '';
  const existing = recentYouTubePlaylists.filter(entry => (
    (normalizedId && entry.playlistId === normalizedId) || entry.value === value
  ));
  const filtered = recentYouTubePlaylists.filter(entry => !existing.includes(entry));
  const nextEntry = {
    value,
    playlistId: normalizedId,
    title: title || (existing[0] ? existing[0].title : ''),
    trackCount: trackCount || (existing[0]?.trackCount ?? 0)
  };
  recentYouTubePlaylists = [nextEntry, ...filtered].slice(0, RECENT_YOUTUBE_LIMIT);
  persistRecentYouTubePlaylists(recentYouTubePlaylists);
  renderRecentPlaylists();
}

function applyRecentPlaylist(value) {
  if (!value) return;
  if (youtubeUI.playlistInput) {
    youtubeUI.playlistInput.value = value;
  }
  if (queueUI.youtubeInput) {
    queueUI.youtubeInput.value = value;
  }
  loadYouTubePlaylistFromInput(value);
}

function renderRecentPlaylistContainer(container) {
  if (!container) return;
  container.innerHTML = '';
  const parent = container.closest('.recent-playlists');
  if (!recentYouTubePlaylists.length) {
    if (parent) parent.dataset.empty = 'true';
    const empty = document.createElement('div');
    empty.className = 'recent-playlists__empty';
    empty.textContent = 'Noch keine YouTube-Playlists importiert.';
    container.appendChild(empty);
    return;
  }
  if (parent) parent.dataset.empty = 'false';
  recentYouTubePlaylists.forEach(entry => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'recent-playlist-chip';
    button.textContent = formatRecentPlaylistLabel(entry);
    button.title = entry.value;
    button.addEventListener('click', () => applyRecentPlaylist(entry.value));
    container.appendChild(button);
  });
}

function renderRecentPlaylists() {
  renderRecentPlaylistContainer(youtubeUI.recentList);
  renderRecentPlaylistContainer(queueUI.recentList);
}

function focusNewPlaylistInput() {
  if (youtubeUI.playlistInput) {
    youtubeUI.playlistInput.value = '';
    youtubeUI.playlistInput.focus();
    return;
  }
  if (queueUI.youtubeInput) {
    queueUI.youtubeInput.value = '';
    queueUI.youtubeInput.focus();
  }
}

function getTrackSourceLabel(track) {
  if (!track) return 'Unbekannt';
  switch (track.source) {
    case 'preset': return 'Beispielmusik';
    case 'youtube': return 'YouTube';
    case 'local':
    default: return 'Lokal';
  }
}

function getTrackDisplayName(track) {
  if (!track) return 'Audio';
  if (track.title) return track.title;
  if (track.file && track.file.name) return track.file.name;
  if (track.youtubeId) return `YouTube ¬∑ ${track.youtubeId}`;
  return 'Audio';
}

function getTrackSourceIcon(track) {
  if (!track) return 'üéµ';
  switch (track.source) {
    case 'preset': return 'üìÄ';
    case 'youtube': return '‚ñ∂Ô∏è';
    case 'local':
    default: return 'üéß';
  }
}

function getYoutubeTrackIndices() {
  const tracks = Array.isArray(audioState.playlist) ? audioState.playlist : [];
  const indices = [];
  tracks.forEach((track, index) => {
    if (track && track.source === 'youtube') {
      indices.push(index);
    }
  });
  return indices;
}

function findNextYoutubeIndex(startIndex = -1, direction = 1) {
  const tracks = Array.isArray(audioState.playlist) ? audioState.playlist : [];
  if (!tracks.length) return -1;
  const total = tracks.length;
  let steps = 0;
  let index = startIndex;
  while (steps < total) {
    index = (index + direction + total) % total;
    if (tracks[index] && tracks[index].source === 'youtube') {
      return index;
    }
    steps += 1;
  }
  return -1;
}

function focusYoutubeTrack(direction = 'first') {
  const hasYoutubeTracks = getYoutubeTrackIndices();
  if (!hasYoutubeTracks.length) return false;
  let targetIndex = -1;
  if (direction === 'prev') {
    targetIndex = findNextYoutubeIndex(audioState.currentIndex, -1);
  } else if (direction === 'next') {
    targetIndex = findNextYoutubeIndex(audioState.currentIndex, 1);
  } else {
    targetIndex = findNextYoutubeIndex(-1, 1);
  }
  if (targetIndex === -1) return false;
  return setCurrentTrack(targetIndex, { updateMeta: true });
}

function mapItemToTrack(item, { sourceHint = 'local', playlistId = '' } = {}) {
  if (!item) return null;
  if (item && item.source && item.id) {
    return { ...item, id: item.id || createTrackId() };
  }
  if (item.youtubeId) {
    return {
      id: createTrackId(),
      source: 'youtube',
      youtubeId: item.youtubeId,
      playlistId: playlistId || item.playlistId || '',
      title: item.title || item.name || 'YouTube-Track'
    };
  }
  if (item instanceof PresetAudioFile) {
    return {
      id: createTrackId(),
      source: 'preset',
      title: item.name || extractFileName(item.src),
      file: item
    };
  }
  if (item instanceof File) {
    return {
      id: createTrackId(),
      source: sourceHint || 'local',
      title: item.name || 'Audio',
      file: item
    };
  }
  return null;
}

function buildYouTubeTrack(videoId, title = '', playlistId = '') {
  if (!videoId) return null;
  return {
    id: createTrackId(),
    source: 'youtube',
    youtubeId: videoId,
    playlistId: playlistId || '',
    title: title || 'YouTube'
  };
}

const AUDIO_VISUAL_BASE = Object.freeze({
  motion: 0,
  size: 1,
  hue: 0,
  alpha: 0,
  scale: 1,
  saturation: 0,
  brightness: 0
});

const audioUI = {
  panel: null,
  body: null,
  toggle: null,
  fileInput: null,
  fileMeta: null,
  playBtn: null,
  stopBtn: null,
  micStartBtn: null,
  micStopBtn: null,
  statusText: null,
  statusDot: null,
  modifierButtons: null,
  intensityControls: null,
  supportNotice: null,
  autoRandomBtn: null,
  overlay: null,
  overlayButton: null,
  brightnessAdaptationBtn: null
};

const youtubeUI = {
  playlistInput: null,
  loadBtn: null,
  playBtn: null,
  pauseBtn: null,
  prevBtn: null,
  nextBtn: null,
  status: null
};

const queueUI = {
  sheet: null,
  list: null,
  meta: null,
  empty: null,
  addLocal: null,
  addPreset: null,
  fileInput: null,
  addYoutube: null,
  youtubeInput: null,
  close: null
};

const playerUI = {
  shell: null,
  source: null,
  title: null,
  meta: null,
  studioToggle: null,
  sourceCycle: null,
  prev: null,
  play: null,
  next: null,
  repeat: null,
  queue: null,
  random: null,
  styles: null,
  moods: null,
  complexity: null,
  motion: null,
  reactivity: null,
  progress: null,
  time: null,
  duration: null
};

const autoRandomState = {
  enabled: true,
  elapsed: 0,
  nextTrigger: Infinity,
  nudgeAccumulator: 0,
  minInterval: 5,
  maxInterval: 26,
  nudgeInterval: 0.45
};

function clampIntensityPercent(value, fallback = 100, max = 200) {
  const numeric = Number(value);
  const limit = Number.isFinite(max) ? Math.max(0, max) : 200;
  const fallbackValue = Math.max(0, Math.min(limit, Math.round(Number(fallback))));
  if (!Number.isFinite(numeric)) {
    return fallbackValue;
  }
  const rounded = Math.round(numeric / 5) * 5;
  return Math.max(0, Math.min(limit, rounded));
}

function getAudioIntensity(key) {
  if (!key || !audioState || !audioState.intensity) {
    return 1;
  }
  if (!(key in audioState.intensity)) {
    const fallback = (key in AUDIO_INTENSITY_BASE_DEFAULTS)
      ? AUDIO_INTENSITY_BASE_DEFAULTS[key]
      : ((key in AUDIO_INTENSITY_DEFAULTS) ? AUDIO_INTENSITY_DEFAULTS[key] : 1);
    audioState.intensity[key] = Number.isFinite(fallback) ? fallback : 1;
  }
  const base = audioState.intensity[key];
  const baseValue = Number.isFinite(base) ? Math.max(0, base) : 1;
  const dynamicSource = audioState.dynamicIntensity && key in audioState.dynamicIntensity
    ? audioState.dynamicIntensity[key]
    : 1;
  const dynamicValue = Number.isFinite(dynamicSource) ? Math.max(0, dynamicSource) : 1;
  return baseValue * (dynamicValue || 1);
}

function getAudioIntensityLimit(key) {
  if (!key || !audioState) {
    return 1;
  }
  if (!audioState.intensityLimits) {
    audioState.intensityLimits = { ...AUDIO_INTENSITY_LIMIT_DEFAULTS };
  }
  if (!(key in audioState.intensityLimits)) {
    const fallback = (key in AUDIO_INTENSITY_LIMIT_DEFAULTS) ? AUDIO_INTENSITY_LIMIT_DEFAULTS[key] : 1;
    audioState.intensityLimits[key] = Number.isFinite(fallback) ? fallback : 1;
  }
  const limit = audioState.intensityLimits[key];
  return Number.isFinite(limit) && limit >= 0 ? limit : 1;
}

function syncAudioIntensityControls() {
  if (!audioUI.intensityControls || typeof audioUI.intensityControls.forEach !== 'function') {
    return;
  }
  const modifiers = audioState.modifiers || {};
  audioUI.intensityControls.forEach(({ input, valueEl, container, limitInput }, key) => {
    const limit = getAudioIntensityLimit(key);
    const base = audioState.intensity && key in audioState.intensity
      ? audioState.intensity[key]
      : (AUDIO_INTENSITY_BASE_DEFAULTS[key] || 1);
    const limitPercent = clampIntensityPercent(limit * 100, (AUDIO_INTENSITY_LIMIT_DEFAULTS[key] || 1) * 100, 200);
    const percent = limit > 0
      ? clampIntensityPercent((Number.isFinite(base) ? base : limit) / limit * 100, 0, 100)
      : 0;
    const enabled = modifiers[key] !== false;
    if (input) {
      if (document.activeElement !== input) {
        input.value = String(percent);
      }
      input.setAttribute('aria-valuenow', String(percent));
      input.toggleAttribute('disabled', !enabled);
      input.setAttribute('aria-disabled', String(!enabled));
      input.setAttribute('aria-valuemax', '100');
      input.setAttribute('aria-valuemin', '0');
    }
    if (limitInput && document.activeElement !== limitInput) {
      limitInput.value = String(limitPercent);
    }
    if (valueEl) {
      valueEl.textContent = `${percent}% (Max ${limitPercent}%)`;
      valueEl.setAttribute('title', `Aktuell ${percent}% von ${limitPercent}%`);
    }
    if (container) {
      container.classList.toggle('is-disabled', !enabled);
    }
  });
}

function setAudioIntensity(key, percentValue) {
  if (!key || !(key in AUDIO_INTENSITY_DEFAULTS)) {
    return;
  }
  const limit = getAudioIntensityLimit(key);
  const clampedPercent = clampIntensityPercent(percentValue, 100, 100);
  if (!audioState.intensity) {
    audioState.intensity = { ...AUDIO_INTENSITY_BASE_DEFAULTS };
  }
  const nextValue = limit > 0 ? (clampedPercent / 100) * limit : 0;
  audioState.intensity[key] = clampValue(nextValue, 0, Math.max(limit, 0));
  syncAudioIntensityControls();
  applyAudioVisualState();
}

function setAudioIntensityLimit(key, percentValue, { preserveRatio = true } = {}) {
  if (!key || !(key in AUDIO_INTENSITY_DEFAULTS)) {
    return;
  }
  const defaultPercent = (AUDIO_INTENSITY_LIMIT_DEFAULTS[key] || 1) * 100;
  const clampedPercent = clampIntensityPercent(percentValue, defaultPercent, 200);
  if (!audioState.intensityLimits) {
    audioState.intensityLimits = { ...AUDIO_INTENSITY_LIMIT_DEFAULTS };
  }
  const previousLimit = getAudioIntensityLimit(key);
  const nextLimit = clampedPercent / 100;
  audioState.intensityLimits[key] = nextLimit;
  if (!audioState.intensity) {
    audioState.intensity = { ...AUDIO_INTENSITY_BASE_DEFAULTS };
  }
  const currentBase = audioState.intensity[key] ?? (AUDIO_INTENSITY_BASE_DEFAULTS[key] || nextLimit || 1);
  let nextBase = currentBase;
  if (preserveRatio && previousLimit > 0) {
    const ratio = Number.isFinite(currentBase) ? currentBase / previousLimit : 0;
    nextBase = nextLimit > 0 ? ratio * nextLimit : 0;
  }
  nextBase = clampValue(Number.isFinite(nextBase) ? nextBase : 0, 0, Math.max(nextLimit, 0));
  audioState.intensity[key] = nextBase;
  syncAudioIntensityControls();
  applyAudioVisualState();
}

function isBrightnessAdaptationEnabled() {
  return audioState && audioState.brightnessAdaptationEnabled !== false;
}

function updateBrightnessAdaptationButton() {
  if (!audioUI.brightnessAdaptationBtn) {
    return;
  }
  const enabled = isBrightnessAdaptationEnabled();
  audioUI.brightnessAdaptationBtn.setAttribute('aria-pressed', enabled ? 'true' : 'false');
  audioUI.brightnessAdaptationBtn.textContent = enabled ? 'üåó Adaption an' : 'üåó Adaption aus';
}

function setBrightnessAdaptationEnabled(enabled) {
  if (!audioState) {
    return;
  }
  audioState.brightnessAdaptationEnabled = Boolean(enabled);
  updateBrightnessAdaptationButton();
  applyAudioVisualState();
}

function applyIntensityToTarget(rawValue, key, base = 0, { min, max } = {}) {
  const intensity = Math.max(0, getAudioIntensity(key));
  let result = Number(rawValue);
  if (!Number.isFinite(result)) {
    result = base;
  }
  if (Number.isFinite(base)) {
    result = base + (result - base) * intensity;
  } else {
    result *= intensity;
  }
  if (Number.isFinite(min)) {
    result = Math.max(min, result);
  }
  if (Number.isFinite(max)) {
    result = Math.min(max, result);
  }
  return result;
}

function updateAudioIntensityDynamics(delta, metrics, pulses, playing) {
  if (!audioState.dynamicIntensity) {
    audioState.dynamicIntensity = { ...AUDIO_INTENSITY_DEFAULTS };
  }
  if (!audioState.dynamicTargets) {
    audioState.dynamicTargets = { ...AUDIO_INTENSITY_DEFAULTS };
  }
  if (!audioState.dynamicTimers) {
    audioState.dynamicTimers = {};
  }
  const configEntries = Object.entries(AUDIO_DYNAMIC_INTENSITY_CONFIG);
  const modifiers = audioState.modifiers || {};
  if (!playing) {
    configEntries.forEach(([key, cfg]) => {
      const relax = Number.isFinite(cfg?.relaxRate) ? cfg.relaxRate : 2.4;
      const current = Number.isFinite(audioState.dynamicIntensity[key]) ? audioState.dynamicIntensity[key] : 1;
      audioState.dynamicIntensity[key] = damp(current, 1, relax, delta);
      audioState.dynamicTargets[key] = 1;
      audioState.dynamicTimers[key] = 0;
    });
    return;
  }
  configEntries.forEach(([key, cfg]) => {
    const modifierActive = modifiers[key] !== false;
    const current = Number.isFinite(audioState.dynamicIntensity[key]) ? audioState.dynamicIntensity[key] : 1;
    if (!modifierActive) {
      const relax = Number.isFinite(cfg?.relaxRate) ? cfg.relaxRate : 2.5;
      audioState.dynamicIntensity[key] = damp(current, 1, relax, delta);
      audioState.dynamicTargets[key] = 1;
      audioState.dynamicTimers[key] = 0;
      return;
    }
    const hold = cfg && cfg.hold ? cfg.hold : { min: 0.45, max: 1.2 };
    const holdMin = Number.isFinite(hold.min) ? Math.max(0.1, hold.min) : 0.45;
    const holdMaxRaw = Number.isFinite(hold.max) ? hold.max : holdMin + 0.8;
    const holdMax = Math.max(holdMin + 0.05, holdMaxRaw);
    const timerBaseline = Number.isFinite(audioState.dynamicTimers[key])
      ? audioState.dynamicTimers[key]
      : randomRange(holdMin, holdMax);
    let timer = timerBaseline - delta;
    audioState.dynamicTimers[key] = timer;
    const driverFn = typeof cfg.driver === 'function' ? cfg.driver : () => 0;
    const drive = clampValue(driverFn(metrics || {}, pulses || {}, playing) || 0, 0, 1.2);
    const jitter = cfg && Number.isFinite(cfg.jitter) ? cfg.jitter : 0;
    const jitterValue = jitter > 0 ? clampValue(randomRange(-jitter, jitter), -jitter, jitter) : 0;
    const pulseKey = cfg && cfg.pulse ? cfg.pulse : 'energy';
    const pulseValue = pulses && Number.isFinite(pulses[pulseKey]) ? Math.max(0, pulses[pulseKey]) : 0;
    const threshold = cfg && Number.isFinite(cfg.pulseThreshold) ? cfg.pulseThreshold : 0.08;
    if (timer <= 0 || pulseValue > threshold) {
      const randomWeight = cfg && Number.isFinite(cfg.randomWeight) ? cfg.randomWeight : 0.3;
      const pulseWeight = cfg && Number.isFinite(cfg.pulseWeight) ? cfg.pulseWeight : 0.5;
      const combined = clampValue(
        drive + jitterValue + pulseValue * pulseWeight + randomRange(0, randomWeight),
        0,
        1.2
      );
      const minVal = cfg && Number.isFinite(cfg.min) ? Math.max(0, cfg.min) : 0.35;
      const maxVal = cfg && Number.isFinite(cfg.max) ? Math.max(minVal + 0.05, cfg.max) : Math.max(minVal + 0.05, 1.5);
      const target = clampValue(minVal + (maxVal - minVal) * Math.min(1, combined), minVal, maxVal);
      audioState.dynamicTargets[key] = target;
      timer = randomRange(holdMin, holdMax);
      audioState.dynamicTimers[key] = timer;
    }
    const targetValue = Number.isFinite(audioState.dynamicTargets[key])
      ? clampValue(audioState.dynamicTargets[key], cfg?.min ?? 0.35, cfg?.max ?? 1.5)
      : 1;
    const damping = cfg && Number.isFinite(cfg.damping) ? cfg.damping : 3;
    const eased = damp(current, targetValue, damping, delta);
    const minClamp = cfg && Number.isFinite(cfg.min) ? cfg.min : 0.3;
    const maxClamp = cfg && Number.isFinite(cfg.max) ? cfg.max : 1.6;
    audioState.dynamicIntensity[key] = clampValue(eased, minClamp, maxClamp);
  });
}

const audioBandVector = new THREE.Vector3();

function applyAudioVisualState(modifiers = audioState.modifiers || {}) {
  const sizeIntensity = modifiers.size ? Math.max(0, getAudioIntensity('size')) : 0;
  const effectiveSizeIntensity = sizeIntensity > 0 ? Math.min(1.5, Math.max(0.35, sizeIntensity)) : 0;
  const rawSize = clampValue(audioState.visual.size, 0.2, 4.5);
  const sizeBoost = modifiers.size
    ? 1 + (rawSize - 1) * effectiveSizeIntensity
    : AUDIO_VISUAL_BASE.size;
  const hueOffset = modifiers.hue ? clampValue(audioState.visual.hue, -540, 540) : AUDIO_VISUAL_BASE.hue;
  const saturationDelta = modifiers.saturation
    ? clampValue(audioState.visual.saturation, -0.35, 0.9)
    : AUDIO_VISUAL_BASE.saturation;
  const brightnessDelta = modifiers.brightness
    ? clampValue(audioState.visual.brightness, -0.35, 1.05)
    : AUDIO_VISUAL_BASE.brightness;
  const hue = ((params.pointHue + hueOffset) % 360 + 360) % 360;
  const baseSaturation = clampValue(params.pointSaturation + saturationDelta, 0.05, 1.4);
  const baseBrightness = clampValue(params.pointValue + brightnessDelta, 0.05, 1.6);
  const saturationIntensity = modifiers.saturation ? Math.max(0, getAudioIntensity('saturation')) : 0;
  const brightnessIntensity = modifiers.brightness ? Math.max(0, getAudioIntensity('brightness')) : 0;
  const effectiveSaturationIntensity = saturationIntensity > 0 ? Math.min(1.6, Math.max(0.25, saturationIntensity)) : 0;
  const effectiveBrightnessIntensity = brightnessIntensity > 0 ? Math.min(1.6, Math.max(0.25, brightnessIntensity)) : 0;
  const saturationBoost = modifiers.saturation
    ? audioState.metrics.treble * 0.22 * effectiveSaturationIntensity
    : 0;
  const brightnessBoost = modifiers.brightness
    ? audioState.metrics.energy * 0.32 * effectiveBrightnessIntensity
    : 0;
  const brightnessAdaptationEnabled = isBrightnessAdaptationEnabled();
  const silenceLevel = clampValue(Number.isFinite(audioState.silenceLevel) ? audioState.silenceLevel : 0, 0, 1);
  const minVisibility = 0.08;
  const visibilityFactor = brightnessAdaptationEnabled
    ? minVisibility + (1 - silenceLevel) * (1 - minVisibility)
    : 1;
  const saturation = clampValue(baseSaturation + saturationBoost * visibilityFactor, 0.05, 1.4);
  const brightness = clampValue((baseBrightness + brightnessBoost) * visibilityFactor, 0.05, 1.6);
  const reactiveColor = hsv2rgb(hue, saturation, brightness);
  audioState.color.copy(reactiveColor);

  const scaleIntensity = modifiers.scale ? Math.max(0, getAudioIntensity('scale')) : 0;
  const effectiveScaleIntensity = scaleIntensity > 0 ? Math.min(1.5, Math.max(0.35, scaleIntensity)) : 0;
  const rawScale = clampValue(audioState.visual.scale, 0.25, 3.5);
  const sphereScale = modifiers.scale
    ? Math.max(0.25, Math.min(3.5, 1 + (rawScale - 1) * effectiveScaleIntensity))
    : AUDIO_VISUAL_BASE.scale;
  if (Number.isFinite(sphereScale)) {
    if (Math.abs(clusterGroup.scale.x - sphereScale) > 1e-4 ||
        Math.abs(clusterGroup.scale.y - sphereScale) > 1e-4 ||
        Math.abs(clusterGroup.scale.z - sphereScale) > 1e-4) {
      clusterGroup.scale.setScalar(sphereScale);
    }
  }

  const bandGain = 0.75 + Math.max(0, getAudioIntensity('scale')) * 0.75;
  const bassValue = Math.min(3, audioState.metrics.bass * bandGain);
  const midValue = Math.min(3, audioState.metrics.mid * bandGain * 0.92);
  const trebleValue = Math.min(3, audioState.metrics.treble * bandGain * 1.08);
  audioBandVector.set(bassValue, midValue, trebleValue);
  const energyUniform = Math.min(3, audioState.metrics.energy * (0.8 + Math.max(0, getAudioIntensity('motion')) * 0.7));
  const waveUniform = Math.min(3, audioState.metrics.wave * (0.8 + Math.max(0, getAudioIntensity('size')) * 0.7));

  const baseAlpha = params.pointAlpha;
  const alphaVisual = modifiers.alpha ? clampValue(audioState.visual.alpha, 0, 1.2) : AUDIO_VISUAL_BASE.alpha;
  const boostedAlpha = Math.max(0.05, Math.min(1, (baseAlpha + alphaVisual) * visibilityFactor));
  const applyAudioToPointMaterial = material => {
    if (!material || !material.uniforms) {
      return;
    }
    const uniforms = material.uniforms;
    if (uniforms.uAudioBands && uniforms.uAudioBands.value) {
      uniforms.uAudioBands.value.copy(audioBandVector);
    }
    if (uniforms.uAudioEnergy) {
      uniforms.uAudioEnergy.value = energyUniform;
    }
    if (uniforms.uAudioWave) {
      uniforms.uAudioWave.value = waveUniform;
    }
    if (uniforms.uSizeFactorSmall) {
      uniforms.uSizeFactorSmall.value = params.sizeFactorSmall * sizeBoost;
    }
    if (uniforms.uSizeFactorMedium) {
      uniforms.uSizeFactorMedium.value = params.sizeFactorMedium * sizeBoost;
    }
    if (uniforms.uSizeFactorLarge) {
      uniforms.uSizeFactorLarge.value = params.sizeFactorLarge * sizeBoost;
    }
    if (uniforms.uAlpha) {
      uniforms.uAlpha.value = boostedAlpha;
    }
    if (uniforms.uColor) {
      uniforms.uColor.value.copy(audioState.color);
    }
    material.needsUpdate = true;
  };
  applyAudioToPointMaterial(starMaterial);
  applyAudioToPointMaterial(stlMaterial);

  if (stlMaterial && stlMaterial.uniforms) {
    if (stlMaterial.uniforms.uAudioBands && stlMaterial.uniforms.uAudioBands.value) {
      stlMaterial.uniforms.uAudioBands.value.copy(audioBandVector);
    }
    if (stlMaterial.uniforms.uAudioEnergy) {
      stlMaterial.uniforms.uAudioEnergy.value = energyUniform;
    }
    if (stlMaterial.uniforms.uAudioWave) {
      stlMaterial.uniforms.uAudioWave.value = waveUniform;
    }
    if (stlMaterial.uniforms.uSizeFactorSmall) {
      stlMaterial.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall * sizeBoost;
    }
    if (stlMaterial.uniforms.uSizeFactorMedium) {
      stlMaterial.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium * sizeBoost;
    }
    if (stlMaterial.uniforms.uSizeFactorLarge) {
      stlMaterial.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge * sizeBoost;
    }
    if (stlMaterial.uniforms.uAlpha) {
      const baseAlpha = params.pointAlpha;
      const alphaVisual = modifiers.alpha ? clampValue(audioState.visual.alpha, 0, 1.2) : AUDIO_VISUAL_BASE.alpha;
      const boostedAlpha = Math.max(0.05, Math.min(1, (baseAlpha + alphaVisual) * visibilityFactor));
      stlMaterial.uniforms.uAlpha.value = boostedAlpha;
    }
    if (stlMaterial.uniforms.uColor) {
      stlMaterial.uniforms.uColor.value.copy(audioState.color);
    }
  }

  if (tinyMaterial && tinyMaterial.uniforms) {
    if (tinyMaterial.uniforms.uAudioBands && tinyMaterial.uniforms.uAudioBands.value) {
      tinyMaterial.uniforms.uAudioBands.value.copy(audioBandVector);
    }
    if (tinyMaterial.uniforms.uAudioEnergy) {
      tinyMaterial.uniforms.uAudioEnergy.value = energyUniform;
    }
    if (tinyMaterial.uniforms.uAudioWave) {
      tinyMaterial.uniforms.uAudioWave.value = waveUniform;
    }
    const waveContribution = modifiers.size ? waveUniform : 0;
    const tinySize = params.sizeFactorTiny * Math.max(0.05, 0.8 + sizeBoost * 0.2 + waveContribution * 0.25);
    if (tinyMaterial.uniforms.uSize) {
      tinyMaterial.uniforms.uSize.value = tinySize;
    }
    if (tinyMaterial.uniforms.uAlpha) {
      const baseTinyAlpha = params.tinyAlpha;
      const alphaVisual = modifiers.alpha ? clampValue(audioState.visual.alpha, 0, 1.2) : AUDIO_VISUAL_BASE.alpha;
      const boostedTinyAlpha = Math.min(1, (baseTinyAlpha + alphaVisual * 0.4) * visibilityFactor);
      tinyMaterial.uniforms.uAlpha.value = boostedTinyAlpha;
    }
    if (tinyMaterial.uniforms.uColor) {
      tinyMaterial.uniforms.uColor.value.copy(audioState.color);
    }
  }
}

function applyAudioMotion(delta, modifiers = audioState.modifiers || {}) {
  if (!modifiers.motion) {
    return;
  }
  const motionIntensity = Math.max(0, getAudioIntensity('motion'));
  const rotationStrength = clampValue(audioState.visual.motion, 0, 4.5);
  if (rotationStrength <= 1e-4 || motionIntensity <= 0) {
    return;
  }
  const effectiveMotion = Math.max(0.4, motionIntensity);
  const yaw = rotationStrength * audioState.motionDirection * delta * (0.75 + effectiveMotion * 1.15);
  const waveTilt = clampValue(audioState.metrics.wave * (0.35 + effectiveMotion * 0.55), -3.5, 3.5);
  const pitch = waveTilt * audioState.pitchDirection * delta * (0.6 + effectiveMotion * 0.4);
  const rollBase = clampValue(audioState.metrics.treble * (0.26 + effectiveMotion * 0.4), 0, 3.2);
  const rollDirection = audioState.motionDirection >= 0 ? 1 : -1;
  const roll = rollBase * rollDirection * delta * (0.4 + effectiveMotion * 0.35);
  if (Number.isFinite(yaw) && Math.abs(yaw) < Math.PI) {
    clusterGroup.rotateY(yaw);
  }
  if (Number.isFinite(pitch) && Math.abs(pitch) < Math.PI) {
    clusterGroup.rotateX(pitch);
  }
  if (Number.isFinite(roll) && Math.abs(roll) < Math.PI) {
    clusterGroup.rotateZ(roll);
  }
}

function resetAudioReactivity() {
  resetAudioMetrics();
  applyAudioVisualState();
}

function isAudioSupported() {
  return !!AudioContextClass;
}

function isMicSupported() {
  return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia);
}

function ensureAudioContext() {
  if (!AudioContextClass) {
    throw new Error('Web Audio API nicht verf√ºgbar');
  }
  if (!audioState.context) {
    audioState.context = new AudioContextClass();
  }
  return audioState.context;
}

function ensureAnalyser(context) {
  if (!audioState.analyser) {
    const analyser = context.createAnalyser();
    analyser.fftSize = 2048;
    analyser.smoothingTimeConstant = 0.85;
    audioState.analyser = analyser;
    audioState.freqData = new Uint8Array(analyser.frequencyBinCount);
    audioState.timeData = new Uint8Array(analyser.fftSize);
  }
  return audioState.analyser;
}

function decodeAudioBuffer(context, arrayBuffer) {
  return new Promise((resolve, reject) => {
    const maybePromise = context.decodeAudioData(arrayBuffer, resolve, reject);
    if (maybePromise && typeof maybePromise.then === 'function') {
      maybePromise.then(resolve, reject);
    }
  });
}

function resetAudioMetrics() {
  audioState.metrics.energy = 0;
  audioState.metrics.bass = 0;
  audioState.metrics.mid = 0;
  audioState.metrics.treble = 0;
  audioState.metrics.wave = 0;
  audioState.visual.motion = 0;
  audioState.visual.size = 1;
  audioState.visual.hue = 0;
  audioState.visual.alpha = 0;
  audioState.visual.scale = 1;
  audioState.visual.saturation = 0;
  audioState.visual.brightness = 0;
  audioState.motionDirection = 1;
  audioState.pitchDirection = 1;
  audioState.motionFlipCooldown = 0;
  audioState.pitchFlipCooldown = 0;
  audioState.previousBass = 0;
  audioState.previousTreble = 0;
  audioState.previousEnergy = 0;
  audioState.previousWave = 0;
  audioState.previousMid = 0;
  audioState.silenceLevel = 1;
  if (!audioState.dynamicIntensity) {
    audioState.dynamicIntensity = { ...AUDIO_INTENSITY_DEFAULTS };
  } else {
    Object.keys(AUDIO_INTENSITY_DEFAULTS).forEach(key => {
      audioState.dynamicIntensity[key] = 1;
    });
  }
  audioState.dynamicTargets = { ...AUDIO_INTENSITY_DEFAULTS };
  audioState.dynamicTimers = {};
}

function disconnectAnalyser() {
  if (audioState.analyser) {
    try { audioState.analyser.disconnect(); } catch (err) { /* ignore */ }
  }
}

function stopAudioPlayback({ suspendContext = false, skipUiUpdates = false, stopYouTube = true, preserveBuffer = false } = {}) {
  const wasActive = audioState.playing || audioState.usingMic || audioState.youtubeActive;
  if (audioState.source) {
    try { audioState.source.disconnect(); } catch (err) { /* ignore */ }
    if (typeof audioState.source.stop === 'function') {
      try { audioState.source.stop(); } catch (err) { /* ignore */ }
    }
  }
  audioState.source = null;
  if (stopYouTube) {
    stopYouTubeStream({ stopPlayback: true });
  } else {
    stopYouTubeStream({ detachOnly: true });
  }
  if (audioState.micStream) {
    audioState.micStream.getTracks().forEach(track => track.stop());
  }
  audioState.micStream = null;
  audioState.playing = false;
  audioState.usingMic = false;
  audioState.youtubeActive = false;
  if (!preserveBuffer) {
    audioState.trackDuration = 0;
    audioState.playbackStartedAt = 0;
    audioState.pausedAt = 0;
    audioState.currentBuffer = null;
  }
  disconnectAnalyser();
  resetAudioReactivity();
  if (!skipUiUpdates && (wasActive || experienceState.panelsHiddenForPlayback)) {
    notifyPlaybackStopped();
  }
  if (audioState.context && suspendContext && typeof audioState.context.suspend === 'function') {
    audioState.context.suspend().catch(() => {});
  }
}

function setAudioStatus(message, state = 'idle') {
  audioState.status = state;
  if (audioUI.statusText) {
    audioUI.statusText.textContent = message;
    audioUI.statusText.dataset.state = state;
  }
  if (audioUI.statusDot) {
    audioUI.statusDot.dataset.state = state;
  }
  updateAudioOverlayVisibility();
}

function setAudioModifier(key, enabled) {
  if (!audioState.modifiers || !(key in audioState.modifiers)) return;
  audioState.modifiers[key] = Boolean(enabled);
  if (!audioState.modifiers[key] && AUDIO_VISUAL_BASE[key] !== undefined && audioState.visual && key in audioState.visual) {
    audioState.visual[key] = AUDIO_VISUAL_BASE[key];
    if (key === 'motion') {
      audioState.motionDirection = 1;
      audioState.pitchDirection = 1;
    }
  }
  refreshAudioUI();
  applyAudioVisualState();
}

function toggleAudioModifier(key) {
  if (!audioState.modifiers || !(key in audioState.modifiers)) return;
  setAudioModifier(key, !audioState.modifiers[key]);
}

function shouldShowAudioOverlay() {
  if (!audioUI.overlay) return false;
  if (!isAudioSupported()) return false;
  if (experienceState.editingMode) return false;
  if (audioState.playing || audioState.usingMic) return false;
  if (audioState.status === 'waiting' || audioState.status === 'error') return false;
  return true;
}

function updateAudioOverlayVisibility() {
  if (!audioUI.overlay) return;
  const visible = shouldShowAudioOverlay();
  audioUI.overlay.dataset.visible = visible ? 'true' : 'false';
  audioUI.overlay.setAttribute('aria-hidden', visible ? 'false' : 'true');
  if (audioUI.overlayButton) {
    if (visible) {
      audioUI.overlayButton.disabled = false;
      audioUI.overlayButton.removeAttribute('aria-busy');
      audioUI.overlayButton.removeAttribute('tabindex');
    } else {
      audioUI.overlayButton.setAttribute('tabindex', '-1');
    }
  }
}

function formatTimeShort(seconds) {
  if (!Number.isFinite(seconds) || seconds < 0) return '‚Äì:‚Äì‚Äì';
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${String(secs).padStart(2, '0')}`;
}

function refreshPlayerTransportUI() {
  if (!playerUI.play) return;
  const hasTrack = getPlaylistLength() > 0 || audioState.youtubeActive;
  const live = audioState.usingMic;
  const playing = audioState.playing;
  playerUI.play.textContent = playing ? '‚è∏Ô∏è' : '‚ñ∂Ô∏è';
  playerUI.play.disabled = live && playing;
  if (playerUI.prev) playerUI.prev.disabled = !hasTrack || audioState.usingMic;
  if (playerUI.next) playerUI.next.disabled = !hasTrack || audioState.usingMic;
  if (playerUI.repeat) {
    const pressed = audioState.repeatMode && audioState.repeatMode !== 'off';
    playerUI.repeat.setAttribute('aria-pressed', pressed ? 'true' : 'false');
  }
  if (playerUI.source) {
    if (live) {
      playerUI.source.textContent = 'Live/Mic';
    } else if (audioState.currentTrack) {
      playerUI.source.textContent = getTrackSourceLabel(audioState.currentTrack);
    } else {
      playerUI.source.textContent = audioState.youtubeActive ? 'YouTube' : 'Lokale Musik';
    }
  }
  updatePlayerTrackMeta();
}

function updatePlayerTrackMeta() {
  if (!playerUI.title) return;
  const hasFiles = getPlaylistLength() > 0;
  const live = audioState.usingMic;
  const track = audioState.currentTrack;
  if (live) {
    playerUI.title.textContent = 'Live-Input';
    playerUI.meta.textContent = 'Visual reagiert auf Mikrofon';
    return;
  }
  if (track && track.source === 'youtube') {
    playerUI.title.textContent = track.title || youtubeState.currentVideoTitle || 'YouTube-Playlist';
    const index = clampTrackIndex(audioState.currentIndex);
    playerUI.meta.textContent = index >= 0 ? `YouTube ¬∑ Titel ${index + 1} von ${getPlaylistLength()}` : 'YouTube';
    return;
  }
  if (hasFiles && track) {
    playerUI.title.textContent = getTrackDisplayName(track);
    const index = clampTrackIndex(audioState.currentIndex);
    playerUI.meta.textContent = index >= 0 ? `Titel ${index + 1} von ${getPlaylistLength()}` : 'Playlist';
  } else {
    playerUI.title.textContent = 'Visual Player';
    playerUI.meta.textContent = 'Bereit';
  }
}

function updatePlayerProgressDisplay() {
  if (!playerUI.progress) return;
  const live = audioState.usingMic;
  const duration = live ? 0 : (audioState.trackDuration || 0);
  const ctx = audioState.context;
  let elapsed = 0;
  if (live) {
    elapsed = 0;
  } else if (audioState.playing && ctx) {
    elapsed = Math.max(0, ctx.currentTime - (audioState.playbackStartedAt || 0));
  } else if (audioState.pausedAt) {
    elapsed = audioState.pausedAt;
  }
  const clampedDuration = Math.max(duration, 0.0001);
  const clampedElapsed = Math.max(0, Math.min(elapsed, duration || clampedDuration));
  playerUI.progress.disabled = live || !duration;
  playerUI.progress.max = duration || clampedDuration;
  playerUI.progress.value = clampedElapsed;
  if (playerUI.time) playerUI.time.textContent = live ? 'Live' : formatTimeShort(clampedElapsed);
  if (playerUI.duration) playerUI.duration.textContent = live ? '‚Äì:‚Äì‚Äì' : formatTimeShort(duration || 0);
}

function refreshAudioUI() {
  if (!audioUI.playBtn) return;
  const supportedAudio = isAudioSupported();
  const supportedMic = isMicSupported();
  if (audioUI.supportNotice) {
    let noticeText = 'Nutze eine Datei oder das Mikrofon, um die Punktfarben an Audio zu koppeln.';
    let noticeState = 'info';
    if (!supportedAudio) {
      noticeText = 'Audio-Reaktivit√§t wird in diesem Browser nicht unterst√ºtzt.';
      noticeState = 'error';
    } else if (!supportedMic) {
      noticeText = 'Mikrofonzugriff nicht verf√ºgbar ‚Äì nutze eine Datei.';
      noticeState = 'warning';
    }
    audioUI.supportNotice.textContent = noticeText;
    audioUI.supportNotice.dataset.state = noticeState;
  }
  if (audioUI.fileInput) {
    audioUI.fileInput.disabled = !supportedAudio;
  }
  const playlistLength = getPlaylistLength();
  const hasFiles = playlistLength > 0;
  const usingMic = audioState.usingMic;
  const activeTrack = audioState.currentTrack;
  const hasTrack = hasFiles && Boolean(activeTrack);
  const playable = hasTrack && (activeTrack.source === 'youtube' || Boolean(audioState.selectedFile));
  audioUI.playBtn.disabled = !supportedAudio || !playable || audioState.playing;
  if (audioUI.stopBtn) {
    audioUI.stopBtn.disabled = !supportedAudio || (!audioState.playing && !audioState.usingMic);
  }
  if (audioUI.prevBtn) {
    audioUI.prevBtn.disabled = !supportedAudio || !hasFiles || playlistLength <= 1 || usingMic;
  }
  if (audioUI.nextBtn) {
    audioUI.nextBtn.disabled = !supportedAudio || !hasFiles || playlistLength <= 1 || usingMic;
  }
  updateRepeatButton(!supportedAudio || !hasFiles);
  if (audioUI.micStartBtn) {
    audioUI.micStartBtn.disabled = !supportedAudio || !supportedMic || audioState.playing;
  }
  if (audioUI.micStopBtn) {
    audioUI.micStopBtn.disabled = !supportedAudio || !audioState.playing || !audioState.usingMic;
  }
  if (!supportedAudio) {
    setAudioStatus('Web Audio API wird nicht unterst√ºtzt.', 'error');
  } else if (!supportedMic) {
    // only show info if mic UI exists and audio supported
    if (audioUI.micStartBtn) {
      audioUI.micStartBtn.title = 'Kein Mikrofonzugriff verf√ºgbar';
    }
  } else if (audioUI.micStartBtn) {
    audioUI.micStartBtn.removeAttribute('title');
  }
  if (audioUI.modifierButtons && audioUI.modifierButtons.length) {
    audioUI.modifierButtons.forEach(button => {
      const key = button.dataset.modifier;
      const active = key && audioState.modifiers ? Boolean(audioState.modifiers[key]) : false;
      button.setAttribute('aria-pressed', active ? 'true' : 'false');
    });
  }
  const youtubeActive = audioState.youtubeActive;
  const youtubeTracks = getYoutubeTrackIndices();
  const hasYoutubeTracks = youtubeTracks.length > 0;
  if (youtubeUI.loadBtn) {
    youtubeUI.loadBtn.disabled = youtubeState.loading;
  }
  if (youtubeUI.playBtn) {
    youtubeUI.playBtn.disabled = !hasYoutubeTracks || youtubeState.loading || youtubeActive;
  }
  if (youtubeUI.pauseBtn) {
    youtubeUI.pauseBtn.disabled = !youtubeActive;
  }
  if (youtubeUI.prevBtn) {
    youtubeUI.prevBtn.disabled = youtubeTracks.length <= 1;
  }
  if (youtubeUI.nextBtn) {
    youtubeUI.nextBtn.disabled = youtubeTracks.length <= 1;
  }
  if (youtubeUI.playlistInput) {
    youtubeUI.playlistInput.disabled = youtubeState.loading;
  }
  updateAudioFileMeta(audioState.selectedFile);
  syncAudioIntensityControls();
  if (audioUI.autoRandomBtn) {
    if (!supportedAudio && autoRandomState.enabled) {
      setAutoRandomEnabled(false);
    }
    updateAutoRandomButton(!supportedAudio);
  }
  updateAudioOverlayVisibility();
}

function getPlaylistLength() {
  return Array.isArray(audioState.playlist) ? audioState.playlist.length : 0;
}

function clampTrackIndex(index) {
  const total = getPlaylistLength();
  if (total <= 0) {
    audioState.currentIndex = -1;
    return -1;
  }
  const clamped = Math.max(0, Math.min(total - 1, Number(index) || 0));
  if (audioState.currentIndex !== clamped) {
    audioState.currentIndex = clamped;
  }
  return clamped;
}

function formatFileSize(bytes = 0) {
  const size = Number(bytes) || 0;
  if (size <= 0) return '';
  if (size < 1024 * 1024) {
    return `${(size / 1024).toFixed(1)} KB`;
  }
  return `${(size / (1024 * 1024)).toFixed(2)} MB`;
}

function formatRepeatMode(mode) {
  switch (mode) {
    case 'one':
      return 'Repeat: Track';
    case 'all':
      return 'Repeat: Alle';
    default:
      return 'Repeat aus';
  }
}

function updateRepeatButton(disabled = false) {
  if (!audioUI.repeatBtn) return;
  const mode = audioState.repeatMode || 'off';
  let label = 'üîÅ Repeat aus';
  if (mode === 'all') {
    label = 'üîÅ Repeat alle';
  } else if (mode === 'one') {
    label = 'üîÇ Repeat Track';
  }
  audioUI.repeatBtn.textContent = label;
  audioUI.repeatBtn.setAttribute('aria-pressed', mode === 'off' ? 'false' : 'true');
  audioUI.repeatBtn.disabled = disabled;
  if (disabled) {
    audioUI.repeatBtn.setAttribute('aria-disabled', 'true');
  } else {
    audioUI.repeatBtn.removeAttribute('aria-disabled');
  }
}

function updateAudioFileMeta(file) {
  const total = getPlaylistLength();
  const hasFiles = total > 0;
  const youtubeTitle = youtubeState.currentVideoTitle || '';
  const hasYouTube = Boolean(audioState.youtubeActive || youtubeState.playlistId);
  const currentIndex = hasFiles ? clampTrackIndex(audioState.currentIndex) : -1;
  const activeTrack = hasFiles ? (file || audioState.playlist[currentIndex] || null) : null;
  audioState.currentTrack = activeTrack || audioState.currentTrack;
  if (activeTrack && activeTrack.file !== audioState.selectedFile) {
    audioState.selectedFile = activeTrack.file || null;
    audioState.fileName = getTrackDisplayName(activeTrack);
  } else if (!hasFiles && audioState.selectedFile) {
    audioState.selectedFile = null;
    audioState.fileName = '';
    audioState.currentTrack = null;
  }
  if (audioUI.fileMeta) {
    if (!activeTrack && hasYouTube) {
      audioUI.fileMeta.textContent = youtubeTitle || 'YouTube';
    } else if (!activeTrack) {
      audioUI.fileMeta.textContent = hasFiles ? 'Datei nicht verf√ºgbar' : 'Keine Auswahl';
    } else {
      const name = getTrackDisplayName(activeTrack);
      const sizeLabel = activeTrack.file ? formatFileSize(activeTrack.file.size) : '';
      const sourceLabel = getTrackSourceLabel(activeTrack);
      audioUI.fileMeta.textContent = sizeLabel
        ? `${name} ¬∑ ${sourceLabel} ¬∑ ${sizeLabel}`
        : `${name} ¬∑ ${sourceLabel}`;
    }
  }
  if (audioUI.playlistMeta) {
    if (!hasFiles && hasYouTube) {
      audioUI.playlistMeta.textContent = youtubeTitle ? `YouTube ¬∑ ${youtubeTitle}` : 'YouTube-Playlist';
    } else if (!hasFiles) {
      audioUI.playlistMeta.textContent = 'Keine Playlist geladen';
    } else {
      const displayIndex = currentIndex >= 0 ? currentIndex + 1 : 1;
      audioUI.playlistMeta.textContent = `Titel ${displayIndex} von ${total} ¬∑ ${formatRepeatMode(audioState.repeatMode)}`;
    }
  }
  refreshPlayerTransportUI();
  updatePlayerProgressDisplay();
}

function updateQueueMeta() {
  if (!queueUI.meta) return;
  const total = getPlaylistLength();
  if (!total) {
    queueUI.meta.textContent = 'Keine Titel';
    return;
  }
  const index = clampTrackIndex(audioState.currentIndex);
  const prefix = index >= 0 ? `Titel ${index + 1} von ${total}` : `${total} Titel`;
  queueUI.meta.textContent = `${prefix} ¬∑ ${formatRepeatMode(audioState.repeatMode)}`;
}

function renderQueueList() {
  if (!queueUI.list || !queueUI.empty) return;
  const tracks = Array.isArray(audioState.playlist) ? audioState.playlist : [];
  queueUI.list.innerHTML = '';
  queueUI.list.hidden = tracks.length === 0;
  queueUI.empty.hidden = tracks.length > 0;
  tracks.forEach((track, index) => {
    if (!track) return;
    const li = document.createElement('li');
    li.className = 'queue-item';
    li.dataset.id = track.id;
    const info = document.createElement('div');
    const titleEl = document.createElement('div');
    titleEl.className = 'queue-item-title';
    titleEl.textContent = getTrackDisplayName(track);
    const meta = document.createElement('div');
    meta.className = 'queue-item-meta';
    const source = document.createElement('span');
    source.className = 'queue-source';
    source.textContent = `${getTrackSourceIcon(track)} ${getTrackSourceLabel(track)}`;
    const position = document.createElement('span');
    position.textContent = `${index + 1}/${tracks.length}`;
    meta.appendChild(source);
    meta.appendChild(position);
    info.appendChild(titleEl);
    info.appendChild(meta);
    const actions = document.createElement('div');
    actions.className = 'queue-actions';
    const playBtn = document.createElement('button');
    playBtn.type = 'button';
    playBtn.textContent = '‚ñ∂Ô∏è';
    playBtn.addEventListener('click', event => {
      event.stopPropagation();
      if (setCurrentTrack(index, { updateMeta: true })) {
        playCurrentTrack();
        setQueueOpen(false);
      }
    });
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.textContent = '‚úñÔ∏è';
    removeBtn.addEventListener('click', event => {
      event.stopPropagation();
      removeTrackById(track.id);
    });
    actions.appendChild(playBtn);
    actions.appendChild(removeBtn);
    li.appendChild(info);
    li.appendChild(actions);
    li.addEventListener('click', () => {
      if (setCurrentTrack(index, { updateMeta: true })) {
        playCurrentTrack();
        setQueueOpen(false);
      }
    });
    queueUI.list.appendChild(li);
  });
  updateQueueMeta();
}

function setQueueOpen(open) {
  if (!queueUI.sheet) return;
  const next = Boolean(open);
  queueUI.sheet.dataset.open = next ? 'true' : 'false';
  queueUI.sheet.setAttribute('aria-hidden', next ? 'false' : 'true');
}

function setPlaylist(items, { append = false } = {}) {
  const list = Array.from(items || [])
    .map(entry => mapItemToTrack(entry))
    .filter(Boolean);
  if (!append) {
    audioState.playlist = list;
  } else {
    audioState.playlist = [...audioState.playlist, ...list];
  }
  if (audioState.playlist.length) {
    audioState.currentIndex = append && audioState.currentIndex >= 0 ? audioState.currentIndex : 0;
    audioState.currentTrack = audioState.playlist[audioState.currentIndex] || null;
    audioState.selectedFile = audioState.currentTrack ? (audioState.currentTrack.file || null) : null;
    audioState.fileName = getTrackDisplayName(audioState.currentTrack);
  } else {
    audioState.currentIndex = -1;
    audioState.currentTrack = null;
    audioState.selectedFile = null;
    audioState.fileName = '';
  }
  updateAudioFileMeta(audioState.currentTrack);
  renderQueueList();
  updateQueueMeta();
}

function removeTrackById(id) {
  if (!id || !Array.isArray(audioState.playlist)) return;
  const index = audioState.playlist.findIndex(track => track && track.id === id);
  if (index === -1) return;
  const wasCurrent = index === audioState.currentIndex;
  audioState.playlist.splice(index, 1);
  if (!audioState.playlist.length) {
    stopAudioPlayback({ stopYouTube: true });
    audioState.currentIndex = -1;
    audioState.currentTrack = null;
    audioState.selectedFile = null;
  } else {
    const nextIndex = wasCurrent ? Math.min(index, audioState.playlist.length - 1) : audioState.currentIndex;
    setCurrentTrack(nextIndex, { updateMeta: true });
  }
  renderQueueList();
  updateQueueMeta();
  refreshAudioUI();
}

function parseYouTubePlaylistId(value) {
  if (!value) return '';
  const trimmed = value.trim();
  const listMatch = trimmed.match(/[?&#]list=([a-zA-Z0-9_-]+)/i);
  if (listMatch && listMatch[1]) {
    return listMatch[1];
  }
  if (/^PL|^LL|^OL|^UU/.test(trimmed)) {
    return trimmed;
  }
  return '';
}

function parseYouTubeVideoId(value) {
  if (!value) return '';
  const trimmed = value.trim();
  const urlMatch = trimmed.match(/[?&#]v=([a-zA-Z0-9_-]{6,})/i);
  if (urlMatch && urlMatch[1]) return urlMatch[1];
  if (/^[a-zA-Z0-9_-]{6,}$/.test(trimmed)) return trimmed;
  return '';
}

async function fetchYouTubeTitle(videoId) {
  try {
    const response = await fetch(`https://noembed.com/embed?url=https://www.youtube.com/watch?v=${encodeURIComponent(videoId)}`);
    if (!response.ok) return '';
    const payload = await response.json();
    return payload && payload.title ? payload.title : '';
  } catch (error) {
    console.warn('YouTube-Titel konnte nicht geladen werden:', error);
    return '';
  }
}

async function fetchPlaylistVideoIds(playlistId, { timeoutMs = 8000 } = {}) {
  await ensureYouTubeApiReady();
  const player = createYouTubePlayer();
  youtubeState.loading = true;
  refreshAudioUI();
  player.cuePlaylist({ listType: 'playlist', list: playlistId, index: 0 });
  const start = performance.now();
  return new Promise((resolve, reject) => {
    function check() {
      const list = player.getPlaylist ? player.getPlaylist() : [];
      if (Array.isArray(list) && list.length) {
        youtubeState.loading = false;
        refreshAudioUI();
        resolve(list);
        return;
      }
      if (performance.now() - start > timeoutMs) {
        youtubeState.loading = false;
        refreshAudioUI();
        reject(new Error('YouTube-Playlist konnte nicht geladen werden.'));
        return;
      }
      setTimeout(check, 180);
    }
    check();
  });
}

async function resolveYouTubeTracksFromInput(inputValue) {
  const playlistId = parseYouTubePlaylistId(inputValue);
  if (playlistId) {
    const ids = await fetchPlaylistVideoIds(playlistId);
    const tracks = [];
    for (const id of ids) {
      const title = await fetchYouTubeTitle(id);
      const track = buildYouTubeTrack(id, title, playlistId);
      if (track) tracks.push(track);
    }
    return tracks;
  }
  const videoId = parseYouTubeVideoId(inputValue);
  if (videoId) {
    const title = await fetchYouTubeTitle(videoId);
    const track = buildYouTubeTrack(videoId, title);
    return track ? [track] : [];
  }
  throw new Error('Ung√ºltige Playlist- oder Video-URL.');
}

function setYouTubeStatus(message, state = 'idle') {
  if (youtubeUI.status) {
    youtubeUI.status.textContent = message;
    youtubeUI.status.dataset.state = state;
  }
}

function ensureYouTubeApiReady() {
  if (youtubeState.apiPromise) {
    return youtubeState.apiPromise;
  }
  youtubeState.apiPromise = new Promise((resolve, reject) => {
    if (window.YT && window.YT.Player) {
      youtubeState.ready = true;
      resolve(window.YT);
      return;
    }
    const previousCallback = window.onYouTubeIframeAPIReady;
    window.onYouTubeIframeAPIReady = () => {
      youtubeState.ready = true;
      if (typeof previousCallback === 'function') {
        previousCallback();
      }
      resolve(window.YT);
    };
    const script = document.createElement('script');
    script.src = 'https://www.youtube.com/iframe_api';
    script.async = true;
    script.onerror = () => reject(new Error('YouTube API konnte nicht geladen werden.'));
    document.head.appendChild(script);
  });
  return youtubeState.apiPromise;
}

function createYouTubePlayer() {
  if (youtubeState.player || !window.YT || !window.YT.Player) {
    return youtubeState.player;
  }
  youtubeState.player = new YT.Player('youtubePlayer', {
    height: '0',
    width: '0',
    playerVars: {
      playsinline: 1,
      rel: 0,
      controls: 0,
      origin: window.location.origin,
      enablejsapi: 1
    },
    events: {
      onReady: () => {
        youtubeState.ready = true;
        setYouTubeStatus('YouTube-Player bereit ‚Äì Playlist laden, um zu starten.', 'info');
        refreshAudioUI();
      },
      onStateChange: handleYouTubeStateChange
    }
  });
  return youtubeState.player;
}

function stopYouTubeStream({ stopPlayback = false, detachOnly = false } = {}) {
  if (youtubeState.streamSource) {
    try { youtubeState.streamSource.disconnect(); } catch (err) { /* ignore */ }
  }
  youtubeState.streamSource = null;
  if (youtubeState.stream && !detachOnly) {
    try {
      youtubeState.stream.getTracks().forEach(track => track.stop());
    } catch (err) {
      /* ignore */
    }
  }
  if (stopPlayback && youtubeState.player && typeof youtubeState.player.stopVideo === 'function') {
    youtubeState.player.stopVideo();
  }
  youtubeState.stream = null;
  audioState.youtubeActive = false;
}

function getYouTubeAudioStream(player) {
  const iframe = player && typeof player.getIframe === 'function' ? player.getIframe() : null;
  if (!iframe) return null;
  try {
    if (typeof iframe.captureStream === 'function') {
      return iframe.captureStream();
    }
    if (typeof iframe.mozCaptureStream === 'function') {
      return iframe.mozCaptureStream();
    }
  } catch (error) {
    console.warn('YouTube captureStream fehlgeschlagen:', error);
  }
  return null;
}

function waitMs(ms = 0) {
  return new Promise(resolve => setTimeout(resolve, Math.max(0, ms)));
}

async function connectYouTubeAudio() {
  const player = youtubeState.player;
  const stream = getYouTubeAudioStream(player);
  if (!stream) {
    throw new Error('Audio-Stream kann nicht aus dem YouTube-Player abgegriffen werden.');
  }
  const hasTrack = () => stream.getAudioTracks().some(track => track.readyState !== 'ended');
  if (!hasTrack()) {
    await new Promise((resolve, reject) => {
      const timeout = window.setTimeout(() => {
        stream.removeEventListener?.('addtrack', onAddTrack);
        reject(new Error('YouTube liefert keinen Audiotrack.'));
      }, 1800);
      function onAddTrack() {
        if (hasTrack()) {
          window.clearTimeout(timeout);
          stream.removeEventListener?.('addtrack', onAddTrack);
          resolve();
        }
      }
      stream.addEventListener?.('addtrack', onAddTrack);
      if (hasTrack()) {
        window.clearTimeout(timeout);
        stream.removeEventListener?.('addtrack', onAddTrack);
        resolve();
      }
    });
  }
  const context = ensureAudioContext();
  await context.resume();
  const analyser = ensureAnalyser(context);
  if (youtubeState.streamSource && youtubeState.stream === stream) {
    disconnectAnalyser();
    try { youtubeState.streamSource.disconnect(); } catch (err) { /* ignore */ }
    youtubeState.streamSource.connect(analyser);
    analyser.connect(context.destination);
    audioState.source = youtubeState.streamSource;
  } else {
    stopAudioPlayback({ skipUiUpdates: true, stopYouTube: false });
    disconnectAnalyser();
    const source = context.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.connect(context.destination);
    youtubeState.stream = stream;
    youtubeState.streamSource = source;
    audioState.source = source;
  }
  audioState.playing = true;
  audioState.usingMic = false;
  audioState.youtubeActive = true;
  audioState.fileName = youtubeState.currentVideoTitle || 'YouTube';
  updateAudioFileMeta({ name: audioState.fileName });
  setAudioStatus(`YouTube: ${audioState.fileName}`, 'active');
  refreshAudioUI();
  notifyPlaybackStarted();
}

async function bindYouTubeAudioWithRetry({ attempts = 3, delayMs = 220 } = {}) {
  let lastError = null;
  for (let i = 0; i < attempts; i++) {
    try {
      await connectYouTubeAudio();
      return true;
    } catch (error) {
      lastError = error;
      await waitMs(delayMs);
    }
  }
  if (lastError) {
    throw lastError;
  }
  return false;
}

async function playYouTubeTrack(track) {
  if (!track || !track.youtubeId) {
    setAudioStatus('YouTube-Track fehlt.', 'error');
    return;
  }
  try {
    await ensureYouTubeApiReady();
    const player = createYouTubePlayer();
    stopAudioPlayback({ stopYouTube: true });
    youtubeState.playlistId = track.playlistId || '';
    youtubeState.currentVideoTitle = track.title || 'YouTube';
    setYouTubeStatus('Lade YouTube-Track‚Ä¶', 'waiting');
    audioState.currentTrack = track;
    if (typeof player.loadVideoById === 'function') {
      player.loadVideoById(track.youtubeId);
    }
    bindYouTubeAudioWithRetry({ attempts: 4, delayMs: 260 }).catch(error => {
      console.warn('Initiale YouTube-Audio-Verbindung fehlgeschlagen:', error);
    });
    audioState.youtubeActive = true;
    updateAudioFileMeta(track);
    refreshAudioUI();
  } catch (error) {
    console.error('YouTube-Track konnte nicht gestartet werden:', error);
    setYouTubeStatus('Fehler beim Starten des YouTube-Tracks.', 'error');
    setAudioStatus('YouTube konnte nicht gestartet werden.', 'error');
  }
}

function handleYouTubeStateChange(event) {
  if (!event || !youtubeState.player || typeof YT === 'undefined') return;
  const videoData = youtubeState.player.getVideoData ? youtubeState.player.getVideoData() : {};
  youtubeState.currentVideoTitle = videoData && videoData.title ? videoData.title : 'YouTube';
  if (event.data === YT.PlayerState.PLAYING) {
    setYouTubeStatus(`Spielt: ${youtubeState.currentVideoTitle}`, 'active');
    bindYouTubeAudioWithRetry({ attempts: 4, delayMs: 260 }).catch(error => {
      console.error('YouTube-Audio konnte nicht verbunden werden:', error);
      setAudioStatus('YouTube-Audio konnte nicht verbunden werden.', 'error');
      setYouTubeStatus('Audio-Visualisierung nicht m√∂glich (Browser-Einschr√§nkung).', 'error');
      refreshAudioUI();
    });
    return;
  }
  if (event.data === YT.PlayerState.PAUSED) {
    stopYouTubeStream({ detachOnly: true });
    audioState.playing = false;
    audioState.youtubeActive = false;
    setAudioStatus('YouTube pausiert.', 'idle');
    refreshAudioUI();
    return;
  }
  if (event.data === YT.PlayerState.ENDED) {
    stopYouTubeStream();
    audioState.playing = false;
    audioState.youtubeActive = false;
    setAudioStatus('YouTube-Track beendet.', 'idle');
    refreshAudioUI();
    handleTrackEnded();
  }
}

async function loadYouTubePlaylistFromInput(valueOverride = '') {
  const value = (valueOverride || (youtubeUI.playlistInput ? youtubeUI.playlistInput.value : '')).trim();
  if (!value) {
    setYouTubeStatus('Bitte eine YouTube-URL einf√ºgen.', 'error');
    return false;
  }
  youtubeState.loading = true;
  setYouTubeStatus('YouTube wird geladen‚Ä¶', 'waiting');
  refreshAudioUI();
  let success = false;
  try {
    const tracks = await resolveYouTubeTracksFromInput(value);
    if (!tracks.length) {
      setYouTubeStatus('Keine Titel gefunden.', 'error');
      return false;
    }
    const playlistId = parseYouTubePlaylistId(value);
    if (playlistId) {
      youtubeState.playlistId = playlistId;
    }
    setPlaylist(tracks, { append: true });
    rememberRecentPlaylist({
      inputValue: value,
      playlistId,
      title: tracks[0]?.title || youtubeState.currentVideoTitle || 'Playlist',
      trackCount: tracks.length
    });
    setYouTubeStatus(`${tracks.length} YouTube-Titel importiert.`, 'info');
    success = true;
  } catch (error) {
    console.error('YouTube-Import fehlgeschlagen:', error);
    setYouTubeStatus('Fehler beim Laden der YouTube-URL.', 'error');
    success = false;
  } finally {
    youtubeState.loading = false;
    refreshAudioUI();
  }
  return success;
}

class PresetAudioFile {
  constructor({ src, name, size, type }) {
    this.src = src;
    this.name = name || extractFileName(src);
    this.size = Number.isFinite(size) ? size : 0;
    this.type = type || guessMimeTypeFromPath(src);
    this.lastModified = Date.now();
    this._arrayBufferPromise = null;
  }

  async arrayBuffer() {
    if (!this._arrayBufferPromise) {
      this._arrayBufferPromise = fetch(this.src, { cache: 'force-cache' })
        .then(response => {
          if (!response.ok) {
            throw new Error(`HTTP ${response.status} beim Laden von ${this.src}`);
          }
          const length = response.headers.get('content-length');
          if (length && !this.size) {
            const parsed = Number(length);
            if (Number.isFinite(parsed)) {
              this.size = parsed;
            }
          }
          return response.arrayBuffer();
        })
        .catch(error => {
          this._arrayBufferPromise = null;
          throw error;
        });
    }
    return this._arrayBufferPromise;
  }
}

function extractFileName(pathname) {
  if (!pathname) return 'Audio';
  try {
    const url = new URL(pathname, window.location.href);
    const segments = url.pathname.split('/').filter(Boolean);
    return decodeURIComponent(segments.pop() || 'Audio');
  } catch (error) {
    const parts = pathname.split(/[\\/]/).filter(Boolean);
    return decodeURIComponent(parts.pop() || 'Audio');
  }
}

function guessMimeTypeFromPath(pathname) {
  const ext = (pathname || '').toLowerCase().split('.').pop();
  switch (ext) {
    case 'mp3': return 'audio/mpeg';
    case 'wav': return 'audio/wav';
    case 'ogg': return 'audio/ogg';
    case 'flac': return 'audio/flac';
    case 'm4a': return 'audio/mp4';
    case 'aac': return 'audio/aac';
    default: return 'audio/mpeg';
  }
}

async function fetchPresetTrackDescriptors() {
  const descriptorsFromManifest = await loadPresetManifest();
  if (descriptorsFromManifest.length) {
    return descriptorsFromManifest;
  }
  const descriptorsFromListing = await scrapePresetDirectory();
  return descriptorsFromListing;
}

async function loadPresetManifest() {
  try {
    const response = await fetch(PRESET_PLAYLIST_MANIFEST, { cache: 'no-cache' });
    if (!response.ok) {
      return [];
    }
    const payload = await response.json();
    const tracks = Array.isArray(payload?.tracks) ? payload.tracks : Array.isArray(payload) ? payload : [];
    return tracks
      .map(normalizePresetDescriptor)
      .filter(Boolean);
  } catch (error) {
    console.warn('Preset-Playlist konnte nicht √ºber Manifest geladen werden:', error);
    return [];
  }
}

async function scrapePresetDirectory() {
  try {
    const response = await fetch(PRESET_AUDIO_DIRECTORY, { cache: 'no-cache' });
    if (!response.ok) {
      return [];
    }
    const contentType = response.headers.get('content-type') || '';
    if (!contentType.includes('text/html')) {
      return [];
    }
    const html = await response.text();
    const parser = new DOMParser();
    const doc = parser.parseFromString(html, 'text/html');
    const anchors = Array.from(doc.querySelectorAll('a[href]'));
    const baseHref = new URL(PRESET_AUDIO_DIRECTORY, window.location.href).href;
    const seen = new Set();
    const descriptors = [];
    anchors.forEach(anchor => {
      const href = anchor.getAttribute('href') || '';
      if (!href || href === '../') {
        return;
      }
      try {
        const url = new URL(href, baseHref);
        if (url.pathname.endsWith('/')) {
          return;
        }
        if (!/\.(mp3|wav|ogg|flac|m4a|aac)$/i.test(url.pathname)) {
          return;
        }
        const relative = `${decodeURI(url.pathname.startsWith('/') ? url.pathname.slice(1) : url.pathname)}`;
        if (seen.has(relative)) {
          return;
        }
        seen.add(relative);
        descriptors.push(normalizePresetDescriptor({ src: relative }));
      } catch (error) {
        // ignore malformed hrefs
      }
    });
    return descriptors.filter(Boolean);
  } catch (error) {
    console.warn('Preset-Playlist konnte nicht aus dem Verzeichnis gelesen werden:', error);
    return [];
  }
}

function joinPresetPath(segment) {
  if (!segment) {
    return PRESET_AUDIO_DIRECTORY;
  }
  if (/^https?:/i.test(segment)) {
    return segment;
  }
  const trimmedBase = PRESET_AUDIO_DIRECTORY.endsWith('/')
    ? PRESET_AUDIO_DIRECTORY.slice(0, -1)
    : PRESET_AUDIO_DIRECTORY;
  const cleanSegment = segment.startsWith('/') ? segment.slice(1) : segment;
  return `${trimmedBase}/${cleanSegment}`;
}

function normalizePresetDescriptor(entry) {
  if (!entry) {
    return null;
  }
  const src = entry.src || entry.url || entry.path;
  if (!src) {
    return null;
  }
  const normalizedSrc = src.startsWith('http') ? src : (src.startsWith('/') ? src.slice(1) : src);
  const resolvedSrc = normalizedSrc.startsWith(PRESET_AUDIO_DIRECTORY)
    ? normalizedSrc
    : joinPresetPath(normalizedSrc);
  const sizeValue = Number(entry.size);
  return {
    src: resolvedSrc,
    name: entry.name || extractFileName(resolvedSrc),
    size: Number.isFinite(sizeValue) ? sizeValue : undefined,
    type: entry.type || guessMimeTypeFromPath(resolvedSrc)
  };
}

function ensurePresetPlaylistInitialized() {
  if (!presetPlaylistPromise) {
    presetPlaylistPromise = initializePresetPlaylist();
  }
  return presetPlaylistPromise;
}

async function initializePresetPlaylist() {
  const descriptors = await fetchPresetTrackDescriptors();
  if (getPlaylistLength() > 0) {
    return;
  }
  if (!descriptors.length) {
    setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
    refreshAudioUI();
    return;
  }
  const files = descriptors.map(descriptor => new PresetAudioFile(descriptor));
  setPlaylist(files);
  const label = files.length === 1 ? (files[0].name || 'Audio-Datei') : `${files.length} Titel`;
  setAudioStatus(`Preset-Playlist geladen ‚Äì ${label}`, 'idle');
  refreshAudioUI();
}

async function appendPresetTracksToPlaylist() {
  const descriptors = await fetchPresetTrackDescriptors();
  if (!descriptors.length) {
    setAudioStatus('Keine Beispielmusik gefunden.', 'warning');
    return;
  }
  const files = descriptors.map(descriptor => new PresetAudioFile(descriptor));
  setPlaylist(files, { append: true });
  const label = files.length === 1 ? (files[0].name || 'Audio-Datei') : `${files.length} Titel`;
  setAudioStatus(`Beispielmusik hinzugef√ºgt ‚Äì ${label}`, 'info');
  refreshAudioUI();
}

function setCurrentTrack(index, { updateMeta = true } = {}) {
  const total = getPlaylistLength();
  if (total <= 0) {
    audioState.currentIndex = -1;
    audioState.selectedFile = null;
    audioState.fileName = '';
    if (updateMeta) {
      updateAudioFileMeta(null);
    }
    return false;
  }
  if (!Number.isFinite(index) || index < 0 || index >= total) {
    return false;
  }
  audioState.currentIndex = index;
  audioState.currentTrack = audioState.playlist[index] || null;
  audioState.selectedFile = audioState.currentTrack ? (audioState.currentTrack.file || null) : null;
  audioState.fileName = getTrackDisplayName(audioState.currentTrack);
  if (updateMeta) {
    updateAudioFileMeta(audioState.currentTrack);
  }
  updateQueueMeta();
  return Boolean(audioState.currentTrack);
}

function playCurrentTrack() {
  const track = audioState.currentTrack;
  if (!track) {
    setAudioStatus('Keine Playlist geladen.', 'warning');
    refreshAudioUI();
    return false;
  }
  prepareExperienceForPlayback();
  if (track.source === 'youtube') {
    playYouTubeTrack(track);
    return true;
  }
  audioState.selectedFile = track.file || null;
  playSelectedFile();
  return true;
}

async function requestPlaybackStart({ preferCurrent = true } = {}) {
  if (audioState.playing || audioState.usingMic) {
    return true;
  }
  if (experienceState.editingMode) {
    setEditingMode(false, { skipStop: true, skipPanelRestore: true });
  }
  if (preferCurrent && audioState.currentTrack) {
    prepareExperienceForPlayback();
    await playCurrentTrack();
    return true;
  }
  return startFirstPlaylistPlayback();
}

async function startFirstPlaylistPlayback() {
  try {
    await ensurePresetPlaylistInitialized();
  } catch (error) {
    console.warn('Preset-Playlist konnte nicht initialisiert werden:', error);
  }
  const total = getPlaylistLength();
  if (total <= 0) {
    setAudioStatus('Keine Musikdateien verf√ºgbar.', 'warning');
    refreshAudioUI();
    return false;
  }
  const randomIndex = Math.floor(Math.random() * total);
  if (!setCurrentTrack(randomIndex)) {
    return false;
  }
  prepareExperienceForPlayback();
  await playCurrentTrack();
  return true;
}

function playNextTrack({ wrap = false } = {}) {
  const total = getPlaylistLength();
  if (total <= 0) {
    return false;
  }
  let nextIndex = audioState.currentIndex + 1;
  if (nextIndex >= total) {
    if (!wrap) {
      return false;
    }
    nextIndex = 0;
  }
  if (!setCurrentTrack(nextIndex)) {
    return false;
  }
  playCurrentTrack();
  return true;
}

function playPreviousTrack({ wrap = true } = {}) {
  const total = getPlaylistLength();
  if (total <= 0) {
    return false;
  }
  let prevIndex = audioState.currentIndex - 1;
  if (prevIndex < 0) {
    if (!wrap) {
      return false;
    }
    prevIndex = total - 1;
  }
  if (!setCurrentTrack(prevIndex)) {
    return false;
  }
  playCurrentTrack();
  return true;
}

function cycleRepeatMode() {
  const modes = ['off', 'all', 'one'];
  const idx = modes.indexOf(audioState.repeatMode);
  const nextMode = modes[(idx + 1) % modes.length];
  audioState.repeatMode = nextMode;
  updateRepeatButton(audioUI.repeatBtn ? audioUI.repeatBtn.disabled : false);
  updateAudioFileMeta(audioState.selectedFile);
  updateQueueMeta();
}

function handleTrackEnded() {
  if (audioState.usingMic) {
    setAudioStatus('Mikrofon aktiv ‚Äì Live-Reaktion', 'active');
    refreshAudioUI();
    return;
  }
  const total = getPlaylistLength();
  if (total <= 0) {
    stopAudioPlayback();
    setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
    refreshAudioUI();
    return;
  }
  if (audioState.repeatMode === 'one') {
    playCurrentTrack();
    return;
  }
  const advanced = playNextTrack({ wrap: audioState.repeatMode === 'all' });
  if (!advanced) {
    stopAudioPlayback();
    setAudioStatus('Wiedergabe beendet', 'idle');
    refreshAudioUI();
  }
}

function pauseAudioPlayback() {
  if (!audioState.playing || audioState.usingMic || audioState.youtubeActive) {
    return false;
  }
  const ctx = audioState.context;
  if (ctx) {
    audioState.pausedAt = Math.max(0, ctx.currentTime - (audioState.playbackStartedAt || 0));
  }
  if (audioState.source && typeof audioState.source.stop === 'function') {
    try { audioState.source.stop(); } catch (err) { /* ignore */ }
  }
  audioState.source = null;
  audioState.playing = false;
  setAudioStatus('Pausiert', 'idle');
  refreshAudioUI();
  return true;
}

function resumePausedTrack() {
  if (!audioState.currentBuffer || audioState.pausedAt < 0) {
    playSelectedFile();
    return;
  }
  const context = ensureAudioContext();
  if (!context) return;
  const analyser = ensureAnalyser(context);
  stopAudioPlayback({ skipUiUpdates: true, preserveBuffer: true, stopYouTube: false });
  disconnectAnalyser();
  const source = context.createBufferSource();
  source.buffer = audioState.currentBuffer;
  const offset = Math.max(0, Math.min(audioState.pausedAt, audioState.currentBuffer.duration || 0));
  source.onended = () => {
    if (audioState.source === source) {
      audioState.source = null;
      audioState.playing = false;
      handleTrackEnded();
    }
  };
  source.connect(analyser);
  analyser.connect(context.destination);
  source.start(0, offset);
  audioState.source = source;
  audioState.playing = true;
  audioState.playbackStartedAt = context.currentTime - offset;
  setAudioStatus('Wiedergabe l√§uft', 'active');
  refreshAudioUI();
  notifyPlaybackStarted();
}

async function playSelectedFile() {
  const track = audioState.currentTrack;
  if (!track) {
    setAudioStatus('Bitte eine Audio-Datei ausw√§hlen.', 'waiting');
    return;
  }
  if (track.source === 'youtube') {
    playYouTubeTrack(track);
    return;
  }
  if (!audioState.selectedFile) {
    setAudioStatus('Titel kann nicht geladen werden.', 'error');
    return;
  }
  if (!isAudioSupported()) {
    setAudioStatus('Web Audio API wird nicht unterst√ºtzt.', 'error');
    return;
  }
  stopYouTubeStream({ stopPlayback: true });
  try {
    const playlistIndex = clampTrackIndex(audioState.currentIndex);
    const total = getPlaylistLength();
    const trackName = getTrackDisplayName(track);
    const trackDescriptor = total > 0 && playlistIndex >= 0
      ? `${trackName} (${playlistIndex + 1}/${total})`
      : trackName;
    setAudioStatus(`Lade ${trackDescriptor}...`, 'waiting');
    updateAudioFileMeta(track);
    if (audioUI.playBtn) {
      audioUI.playBtn.disabled = true;
    }
    const context = ensureAudioContext();
    await context.resume();
    const analyser = ensureAnalyser(context);
    stopAudioPlayback({ skipUiUpdates: true });
    disconnectAnalyser();
    const arrayBuffer = await audioState.selectedFile.arrayBuffer();
    const buffer = await decodeAudioBuffer(context, arrayBuffer);
    const source = context.createBufferSource();
    source.buffer = buffer;
    source.onended = () => {
      if (audioState.source === source) {
        audioState.source = null;
        audioState.playing = false;
        handleTrackEnded();
      }
    };
    source.connect(analyser);
    analyser.connect(context.destination);
    source.start();
    audioState.source = source;
    audioState.playing = true;
    audioState.currentBuffer = buffer;
    audioState.trackDuration = buffer.duration || 0;
    audioState.playbackStartedAt = context.currentTime;
    audioState.pausedAt = 0;
    audioState.usingMic = false;
    audioState.fileName = audioState.selectedFile.name || 'Audio';
    setAudioStatus(`Wiedergabe l√§uft ‚Äì ${trackDescriptor}`, 'active');
    refreshAudioUI();
    notifyPlaybackStarted();
  } catch (error) {
    console.error('Audio playback failed:', error);
    setAudioStatus('Fehler beim Laden der Datei.', 'error');
    stopAudioPlayback();
    refreshAudioUI();
  }
}

async function startMicrophone() {
  if (!isAudioSupported()) {
    setAudioStatus('Web Audio API wird nicht unterst√ºtzt.', 'error');
    return;
  }
  if (!isMicSupported()) {
    setAudioStatus('Mikrofon wird nicht unterst√ºtzt.', 'error');
    return;
  }
  stopYouTubeStream({ stopPlayback: true });
  try {
    setAudioStatus('Mikrofon wird gestartet‚Ä¶', 'waiting');
    if (audioUI.micStartBtn) {
      audioUI.micStartBtn.disabled = true;
    }
    const context = ensureAudioContext();
    await context.resume();
    const analyser = ensureAnalyser(context);
    stopAudioPlayback({ skipUiUpdates: true });
    disconnectAnalyser();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
    const source = context.createMediaStreamSource(stream);
    source.connect(analyser);
    audioState.source = source;
    audioState.micStream = stream;
    audioState.playing = true;
    audioState.usingMic = true;
    setAudioStatus('Mikrofon aktiv ‚Äì Live-Reaktion', 'active');
    refreshAudioUI();
    notifyPlaybackStarted();
  } catch (error) {
    console.error('Microphone start failed:', error);
    const denied = error && (error.name === 'NotAllowedError' || error.name === 'SecurityError');
    const msg = denied ? 'Mikrofon erfordert Freigabe.' : 'Mikrofon konnte nicht gestartet werden.';
    setAudioStatus(msg, 'error');
    stopAudioPlayback();
    refreshAudioUI();
  }
}

function stopAudioFromUser() {
  if (!audioState.playing && !audioState.micStream) {
    setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
    refreshAudioUI();
    return;
  }
  stopAudioPlayback();
  setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
  refreshAudioUI();
}

function updateAudioReactive(delta) {
  if (experienceState.editingMode) {
    return;
  }
  let energyTarget = 0;
  let bassTarget = 0;
  let midTarget = 0;
  let trebleTarget = 0;
  let waveTarget = 0;

  if (audioState.analyser && audioState.freqData) {
    audioState.analyser.getByteFrequencyData(audioState.freqData);
  }

  if (audioState.analyser && audioState.timeData) {
    audioState.analyser.getByteTimeDomainData(audioState.timeData);
  }

  if (audioState.freqData) {
    const freqData = audioState.freqData;
    const len = freqData.length;
    if (len > 0) {
      let energySum = 0;
      for (let i = 0; i < len; i++) {
        const norm = freqData[i] / 255;
        energySum += norm * norm;
      }
      energyTarget = Math.min(1, Math.sqrt(energySum / len));
      const bassBins = Math.max(1, Math.round(len * 0.08));
      const midBins = Math.max(1, Math.round(len * 0.32));
      const trebleBins = Math.max(1, len - bassBins - midBins);
      const avgRange = (start, count) => {
        const available = Math.max(0, Math.min(len - start, count));
        if (available <= 0) return 0;
        let sum = 0;
        for (let i = 0; i < available; i++) {
          sum += freqData[start + i];
        }
        return (sum / (available * 255)) || 0;
      };
      bassTarget = avgRange(0, bassBins);
      midTarget = avgRange(bassBins, midBins);
      trebleTarget = avgRange(bassBins + midBins, trebleBins);
    }
  }

  if (audioState.timeData) {
    const timeData = audioState.timeData;
    const tLen = timeData.length;
    if (tLen > 0) {
      let waveSum = 0;
      for (let i = 0; i < tLen; i++) {
        const centered = (timeData[i] - 128) / 128;
        waveSum += Math.abs(centered);
      }
      waveTarget = Math.min(1, waveSum / tLen);
    }
  }

  const metricRate = audioState.playing ? 14 : 6;
  audioState.metrics.energy = damp(audioState.metrics.energy, energyTarget, metricRate, delta);
  audioState.metrics.bass = damp(audioState.metrics.bass, bassTarget, metricRate, delta);
  audioState.metrics.mid = damp(audioState.metrics.mid, midTarget, metricRate, delta);
  audioState.metrics.treble = damp(audioState.metrics.treble, trebleTarget, metricRate, delta);
  audioState.metrics.wave = damp(audioState.metrics.wave, waveTarget, metricRate, delta);

  const modifiers = audioState.modifiers || {};
  const playing = audioState.playing || audioState.usingMic;
  const activityMix = (
    (audioState.metrics.energy * 0.9) +
    ((audioState.metrics.bass + audioState.metrics.mid + audioState.metrics.treble) / 3) * 0.6 +
    audioState.metrics.wave * 0.7
  ) / 2.2;
  const clampedActivity = clampValue(Number.isFinite(activityMix) ? activityMix : 0, 0, 1);
  const silenceTarget = playing ? 1 - clampedActivity : 1;
  const silenceRate = playing ? 2.8 : 1.6;
  audioState.silenceLevel = damp(
    Number.isFinite(audioState.silenceLevel) ? audioState.silenceLevel : 1,
    clampValue(silenceTarget, 0, 1),
    silenceRate,
    delta
  );
  const bassPulse = Math.max(0, bassTarget - audioState.previousBass);
  const energyPulse = Math.max(0, energyTarget - audioState.previousEnergy);
  const wavePulse = Math.max(0, waveTarget - audioState.previousWave);
  const treblePulse = Math.max(0, trebleTarget - audioState.previousTreble);
  const midPulse = Math.max(0, midTarget - audioState.previousMid);

  updateAudioIntensityDynamics(
    delta,
    {
      energy: audioState.metrics.energy,
      bass: audioState.metrics.bass,
      mid: audioState.metrics.mid,
      treble: audioState.metrics.treble,
      wave: audioState.metrics.wave
    },
    { energy: energyPulse, bass: bassPulse, mid: midPulse, treble: treblePulse, wave: wavePulse },
    playing
  );

  const motionIntensity = Math.max(0, getAudioIntensity('motion'));
  audioState.motionFlipCooldown = Math.max(0, audioState.motionFlipCooldown - delta);
  audioState.pitchFlipCooldown = Math.max(0, audioState.pitchFlipCooldown - delta);

  const motionActive = modifiers.motion && motionIntensity > 0;

  if (motionActive) {
    if (audioState.motionFlipCooldown <= 0) {
      const beatPulse = bassPulse * 0.7 + energyPulse * 0.4;
      if (beatPulse > 0.12 && (bassTarget > 0.38 || energyTarget > 0.52)) {
        audioState.motionDirection = (audioState.motionDirection || 1) * -1;
        const cooldownBase = 0.3 + (1 - Math.min(1, motionIntensity)) * 0.4;
        audioState.motionFlipCooldown = cooldownBase + Math.random() * 0.25;
      }
    }
    if (audioState.pitchFlipCooldown <= 0) {
      const tiltPulse = treblePulse * 0.6 + wavePulse * 0.8;
      if (tiltPulse > 0.16) {
        audioState.pitchDirection = (audioState.pitchDirection || 1) * -1;
        const pitchCooldownBase = 0.45 + (1 - Math.min(1, motionIntensity)) * 0.35;
        audioState.pitchFlipCooldown = pitchCooldownBase + Math.random() * 0.2;
      }
    }
  } else {
    audioState.motionDirection = 1;
    audioState.pitchDirection = 1;
  }

  const rawMotion = Math.min(3.2, audioState.metrics.energy * 1.6 + audioState.metrics.bass * 2.5);
  const baseSize = Math.min(2.6, 1 + audioState.metrics.mid * 1.45 + audioState.metrics.wave * 0.6);
  const baseScale = Math.min(2.6, 1 + audioState.metrics.energy * 0.65 + audioState.metrics.wave * 0.5 + audioState.metrics.bass * 0.45);
  const hueBase = audioState.metrics.treble * 160 + audioState.metrics.energy * 20;
  const alphaBase = Math.min(0.7, audioState.metrics.energy * 0.45 + audioState.metrics.wave * 0.3 + audioState.metrics.mid * 0.2);
  const saturationBase = audioState.metrics.treble * 0.6 + audioState.metrics.wave * 0.28;
  const brightnessBase = audioState.metrics.energy * 0.75 + audioState.metrics.mid * 0.35;

  const targetMotion = applyIntensityToTarget(rawMotion, 'motion', 0, { min: 0, max: 3.8 });
  const targetSize = applyIntensityToTarget(baseSize, 'size', 1, { min: 0.4, max: 3.4 });
  const targetScale = applyIntensityToTarget(baseScale, 'scale', 1, { min: 0.4, max: 3.4 });
  const targetHue = applyIntensityToTarget(hueBase, 'hue', 0, { min: -720, max: 720 });
  const targetAlpha = applyIntensityToTarget(alphaBase, 'alpha', 0, { min: 0, max: 0.9 });
  const targetSaturation = applyIntensityToTarget(saturationBase, 'saturation', 0, { min: -0.4, max: 1 });
  const targetBrightness = applyIntensityToTarget(brightnessBase, 'brightness', 0, { min: -0.4, max: 1.1 });

  audioState.visual.motion = damp(audioState.visual.motion, modifiers.motion ? targetMotion : AUDIO_VISUAL_BASE.motion, 6, delta);
  audioState.visual.size = damp(audioState.visual.size, modifiers.size ? targetSize : AUDIO_VISUAL_BASE.size, 7, delta);
  audioState.visual.scale = damp(audioState.visual.scale, modifiers.scale ? targetScale : AUDIO_VISUAL_BASE.scale, 5, delta);
  audioState.visual.hue = damp(audioState.visual.hue, modifiers.hue ? targetHue : AUDIO_VISUAL_BASE.hue, 3, delta);
  audioState.visual.alpha = damp(audioState.visual.alpha, modifiers.alpha ? targetAlpha : AUDIO_VISUAL_BASE.alpha, 6, delta);
  audioState.visual.saturation = damp(
    audioState.visual.saturation,
    modifiers.saturation ? targetSaturation : AUDIO_VISUAL_BASE.saturation,
    5,
    delta
  );
  audioState.visual.brightness = damp(
    audioState.visual.brightness,
    modifiers.brightness ? targetBrightness : AUDIO_VISUAL_BASE.brightness,
    5,
    delta
  );

  audioState.previousBass = bassTarget;
  audioState.previousEnergy = energyTarget;
  audioState.previousTreble = trebleTarget;
  audioState.previousWave = waveTarget;
  audioState.previousMid = midTarget;
}

function applyAudioVisuals(delta, skipReactive = false) {
  if (experienceState.editingMode) {
    return;
  }
  if (!skipReactive) {
    updateAudioReactive(delta);
  }
  const modifiers = audioState.modifiers || {};
  applyAudioVisualState(modifiers);
  applyAudioMotion(delta, modifiers);
}

/* Globals for stars and tiny connections */
let starPoints, starGeometry, starMaterial;
let tinyPoints, tinyGeometry, tinyMaterial;

function disposeTinyResources() {
  if (tinyPoints) {
    clusterGroup.remove(tinyPoints);
    tinyPoints = undefined;
  }
  if (tinyGeometry) {
    tinyGeometry.dispose();
    tinyGeometry = undefined;
  }
  if (tinyMaterial) {
    tinyMaterial.dispose();
    tinyMaterial = undefined;
  }
}

function updatePointColor(applyUniforms = true) {
  const hue = ((params.pointHue % 360) + 360) % 360;
  const saturation = Math.max(0, Math.min(1, params.pointSaturation));
  const value = Math.max(0, Math.min(1, params.pointValue));
  const next = hsv2rgb(hue, saturation, value);
  colorState.point.copy(next);
  const accent = next.clone();
  accent.offsetHSL(0.02, 0.05, 0.08);
  const dim = next.clone();
  dim.offsetHSL(0, -0.12, -0.18);
  clampColor(colorState.point);
  colorState.accent.copy(clampColor(accent));
  colorState.dim.copy(clampColor(dim));
  if (!applyUniforms) return;
  if (starMaterial && starMaterial.uniforms && starMaterial.uniforms.uColor) {
    starMaterial.uniforms.uColor.value.copy(colorState.point);
    if (starMaterial.uniforms.uColorAccent) {
      starMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
    }
    if (starMaterial.uniforms.uColorDim) {
      starMaterial.uniforms.uColorDim.value.copy(colorState.dim);
    }
    starMaterial.needsUpdate = true;
  }
  if (stlMaterial && stlMaterial.uniforms && stlMaterial.uniforms.uColor) {
    stlMaterial.uniforms.uColor.value.copy(colorState.point);
    if (stlMaterial.uniforms.uColorAccent) {
      stlMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
    }
    if (stlMaterial.uniforms.uColorDim) {
      stlMaterial.uniforms.uColorDim.value.copy(colorState.dim);
    }
    stlMaterial.needsUpdate = true;
  }
  if (tinyMaterial && tinyMaterial.uniforms && tinyMaterial.uniforms.uColor) {
    tinyMaterial.uniforms.uColor.value.copy(colorState.point);
    if (tinyMaterial.uniforms.uColorAccent) {
      tinyMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
    }
    if (tinyMaterial.uniforms.uColorDim) {
      tinyMaterial.uniforms.uColorDim.value.copy(colorState.dim);
    }
    tinyMaterial.needsUpdate = true;
  }
}

const POINT_VERTEX_SHADER = `
  attribute float aSize;
  attribute float aCat;
  attribute vec3 aBase;
  attribute float aPhase;
  varying float vDepth;
  varying vec3 vBase;
  varying float vPhase;
  varying float vRadius;
  uniform float uSizeFactorSmall;
  uniform float uSizeFactorMedium;
  uniform float uSizeFactorLarge;
  uniform float uTime;
  uniform float uMotionMode;
  uniform float uMotionSpeed;
  uniform float uMotionAmplitude;
  uniform float uNoiseStrength;
  uniform float uNoiseScale;
  uniform vec3 uAudioBands;
  uniform float uAudioEnergy;
  uniform float uAudioWave;

  float hash3(vec3 p) {
    return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
  }

  float valueNoise(vec3 p) {
    vec3 i = floor(p);
    vec3 f = fract(p);
    float n000 = hash3(i + vec3(0.0, 0.0, 0.0));
    float n100 = hash3(i + vec3(1.0, 0.0, 0.0));
    float n010 = hash3(i + vec3(0.0, 1.0, 0.0));
    float n110 = hash3(i + vec3(1.0, 1.0, 0.0));
    float n001 = hash3(i + vec3(0.0, 0.0, 1.0));
    float n101 = hash3(i + vec3(1.0, 0.0, 1.0));
    float n011 = hash3(i + vec3(0.0, 1.0, 1.0));
    float n111 = hash3(i + vec3(1.0, 1.0, 1.0));
    vec3 u = f * f * (3.0 - 2.0 * f);
    float nx00 = mix(n000, n100, u.x);
    float nx10 = mix(n010, n110, u.x);
    float nx01 = mix(n001, n101, u.x);
    float nx11 = mix(n011, n111, u.x);
    float nxy0 = mix(nx00, nx10, u.y);
    float nxy1 = mix(nx01, nx11, u.y);
    return mix(nxy0, nxy1, u.z);
  }

  vec3 applyAudioReactive(vec3 pos) {
    float radius = length(pos);
    if (radius < 1e-4) {
      return pos;
    }
    float bandMix = dot(uAudioBands, vec3(0.65, 0.28, 0.12));
    float wavePulse = uAudioWave * 0.7;
    float energyPulse = uAudioEnergy * 0.45;
    float ripple = sin(uTime * 4.0 + aPhase * 12.5663706) * (0.2 + wavePulse * 0.6);
    float scale = 1.0 + bandMix * 0.3 + energyPulse * 0.25 + wavePulse * 0.25;
    float newRadius = max(0.05, radius * scale + ripple * 10.0);
    vec3 radial = normalize(pos);
    return radial * newRadius;
  }

  vec3 applyMotion(vec3 base) {
    float mode = uMotionMode;
    float time = uTime * uMotionSpeed;
    if (mode < 0.5) {
      return base;
    } else if (mode < 1.5) {
      float phase = aPhase * 6.2831853;
      vec3 offset = vec3(
        sin(time + phase + base.x * 0.015),
        sin(time * 0.8 + phase * 1.3 + base.y * 0.02),
        sin(time * 1.2 + phase * 0.7 + base.z * 0.017)
      );
      return base + offset * uMotionAmplitude;
    } else if (mode < 2.5) {
      float scale = max(0.0001, uNoiseScale);
      vec3 samplePos = base * (0.01 * scale);
      float tx = valueNoise(vec3(samplePos.xy, time * 0.35 + aPhase));
      float ty = valueNoise(vec3(samplePos.yz, time * 0.35 + aPhase * 1.7));
      float tz = valueNoise(vec3(samplePos.zx, time * 0.35 + aPhase * 2.3));
      vec3 offset = vec3(tx, ty, tz) * 2.0 - 1.0;
      offset *= uMotionAmplitude * uNoiseStrength;
      return base + offset;
    } else {
      float phase = aPhase * 6.2831853;
      float angle = time * 0.6 + phase * 0.25;
      vec2 xz = base.xz;
      float radius = length(xz);
      float radial = max(0.0, radius + sin(time * 0.4 + phase) * uMotionAmplitude * 0.25);
      float c = cos(angle);
      float s = sin(angle);
      vec2 rotated = vec2(
        xz.x * c - xz.y * s,
        xz.x * s + xz.y * c
      );
      if (radial > 1e-4 && length(rotated) > 1e-5) {
        rotated = normalize(rotated) * radial;
      } else {
        rotated = vec2(radial * cos(angle), radial * sin(angle));
      }
      float yOffset = sin(time * 0.5 + phase * 0.5) * uMotionAmplitude * 0.3;
      return vec3(rotated.x, base.y + yOffset, rotated.y);
    }
  }

  void main() {
    vec3 animated = applyMotion(aBase);
    vec3 audioDriven = applyAudioReactive(animated);
    vBase = aBase;
    vPhase = aPhase;
    vRadius = length(aBase);
    vec4 mv = modelViewMatrix * vec4(audioDriven, 1.0);
    vDepth = -mv.z;
    float cat = clamp(aCat, 0.0, 2.0);
    float sizeFactor = cat < 0.5 ? uSizeFactorSmall : (cat < 1.5 ? uSizeFactorMedium : uSizeFactorLarge);
    float size = max(0.01, aSize * sizeFactor);
    float px = max(1.0, size * 12.0);
    gl_PointSize = px * (300.0 / max(1.0, vDepth));
    gl_Position = projectionMatrix * mv;
  }
`;

const POINT_FRAGMENT_SHADER = `
  precision highp float;
  uniform float uAlpha;
  uniform float uEdgeSoftness;
  uniform vec3 uColor;
  uniform vec3 uColorAccent;
  uniform vec3 uColorDim;
  uniform float uColorMode;
  uniform float uColorRadius;
  uniform float uColorIntensity;
  uniform float uColorSpeed;
  uniform float uColorPropagationDistance;
  uniform float uColorPropagationDuration;
  uniform float uColorToneCount;
  uniform float uHueSpread;
  uniform float uTime;
  varying vec3 vBase;
  varying float vPhase;
  varying float vRadius;

  vec3 rgb2hsv(vec3 c) {
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
  }

  vec3 hsv2rgb(vec3 c) {
    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
    return c.z * mix(vec3(1.0), rgb, c.y);
  }

  vec3 computeColor() {
    float intensity = clamp(uColorIntensity, 0.0, 1.0);
    float hueSpreadNorm = uHueSpread / 360.0;
    float baseSpeed = max(uColorSpeed, 0.0);
    float colorTime = uTime * baseSpeed;
    float propagationOffset = 0.0;
    if (uColorPropagationDistance > 1e-4 && uColorPropagationDuration > 1e-4) {
      float normRadius = clamp(vRadius / uColorPropagationDistance, 0.0, 1.0);
      propagationOffset = normRadius * uColorPropagationDuration;
    }
    colorTime -= propagationOffset;
    vec3 baseHSVOriginal = rgb2hsv(uColor);
    vec3 accentHSVOriginal = rgb2hsv(uColorAccent);
    vec3 dimHSVOriginal = rgb2hsv(uColorDim);
    float hueShift = 0.0;
    if (hueSpreadNorm > 1e-6) {
      hueShift = sin(colorTime + vPhase * 6.2831853) * hueSpreadNorm;
    }
    vec3 baseHSV = baseHSVOriginal;
    baseHSV.x = fract(baseHSV.x + hueShift);
    vec3 accentHSV = accentHSVOriginal;
    accentHSV.x = fract(accentHSV.x + hueShift);
    vec3 dimHSV = dimHSVOriginal;
    dimHSV.x = fract(dimHSV.x + hueShift);
    vec3 baseColor = hsv2rgb(baseHSV);
    vec3 accentColor = hsv2rgb(accentHSV);
    vec3 dimColor = hsv2rgb(dimHSV);

    if (uColorMode < 0.5) {
      return baseColor;
    } else if (uColorMode < 1.5) {
      float norm = uColorRadius > 1e-4 ? clamp(vRadius / uColorRadius, 0.0, 1.0) : 0.0;
      float pulse = 0.5 + 0.5 * sin(colorTime * 2.2 + norm * 6.2831853 + vPhase * 3.1415926);
      vec3 effect = mix(baseColor, accentColor, pulse);
      return mix(baseColor, effect, intensity);
    } else if (uColorMode < 2.5) {
      float axis = clamp((vBase.y / max(uColorRadius, 1e-4)) * 0.5 + 0.5, 0.0, 1.0);
      float sweep = 0.5 + 0.5 * sin(colorTime * 1.4 + axis * 6.2831853);
      vec3 effect = mix(dimColor, accentColor, sweep);
      return mix(baseColor, effect, intensity);
    } else if (uColorMode < 3.5) {
      float flicker = fract(sin(vPhase * 43758.5453 + colorTime * 0.45) * 43758.5453);
      float mixAmt = smoothstep(0.2, 0.8, flicker);
      vec3 effect = mix(dimColor, accentColor, mixAmt);
      return mix(baseColor, effect, intensity);
    } else {
      float hueRange = hueSpreadNorm;
      float randA = sin(vPhase * 213.135 + colorTime * 1.27);
      float randB = sin(vPhase * 97.531 + colorTime * 0.93);
      float randC = sin(vPhase * 47.853 + colorTime * 1.61);
      float randomShift = (randA * 0.6 + randB * 0.4) * hueRange;
      vec3 rndHSV = baseHSVOriginal;
      rndHSV.x = fract(rndHSV.x + randomShift);
      rndHSV.y = clamp(rndHSV.y * (0.7 + 0.3 * (randB * 0.5 + 0.5)), 0.0, 1.0);
      rndHSV.z = clamp(rndHSV.z * (0.7 + 0.3 * (randC * 0.5 + 0.5)), 0.0, 1.2);
      vec3 randomColor = hsv2rgb(rndHSV);
      return mix(baseColor, randomColor, intensity);
    }
  }

  void main() {
    vec2 uv = gl_PointCoord * 2.0 - 1.0;
    float d = dot(uv, uv);
    if (d > 1.0) discard;
    float inner = 1.0 - uEdgeSoftness;
    float edge = 1.0 - smoothstep(inner, 1.0, d);
    vec3 color = computeColor();
    float toneCount = max(uColorToneCount, 1.0);
    if (toneCount > 1.01) {
      vec3 quantized = rgb2hsv(color);
      quantized.x = floor(quantized.x * toneCount + 1e-4) / toneCount;
      color = hsv2rgb(quantized);
    }
    gl_FragColor = vec4(color, edge * uAlpha);
  }
`;

function createPointShaderMaterial() {
  const material = new THREE.ShaderMaterial({
    vertexShader: POINT_VERTEX_SHADER,
    fragmentShader: POINT_FRAGMENT_SHADER,
    transparent: true,
    depthTest: true,
    depthWrite: false,
    uniforms: {
      uAlpha: { value: params.pointAlpha },
      uEdgeSoftness: { value: params.filled ? 0.0 : params.edgeSoftness },
      uSizeFactorSmall: { value: params.sizeFactorSmall },
      uSizeFactorMedium: { value: params.sizeFactorMedium },
      uSizeFactorLarge: { value: params.sizeFactorLarge },
      uTime: { value: motionState.time },
      uMotionMode: { value: getMotionModeIndex() },
      uMotionSpeed: { value: params.motionSpeed },
      uMotionAmplitude: { value: params.motionAmplitude },
      uNoiseStrength: { value: params.motionNoiseStrength },
      uNoiseScale: { value: params.motionNoiseScale },
      uAudioBands: { value: new THREE.Vector3() },
      uAudioEnergy: { value: 0 },
      uAudioWave: { value: 0 },
      uColor: { value: colorState.point.clone() },
      uColorAccent: { value: colorState.accent.clone() },
      uColorDim: { value: colorState.dim.clone() },
      uColorMode: { value: getColorModeIndex() },
      uColorRadius: { value: Math.max(1, colorState.radius) },
      uColorIntensity: { value: params.colorIntensity },
      uColorSpeed: { value: params.colorSpeed },
      uColorPropagationDistance: { value: params.colorPropagationDistance },
      uColorPropagationDuration: { value: params.colorPropagationDuration },
      uColorToneCount: { value: params.colorToneCount },
      uHueSpread: { value: params.hueSpread },
    }
  });
  material.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  return material;
}

function updatePointMaterialUniforms(material, { radiusOverride } = {}) {
  if (!material || !material.uniforms) return;
  if (material.uniforms.uAlpha) {
    material.uniforms.uAlpha.value = params.pointAlpha;
  }
  if (material.uniforms.uEdgeSoftness) {
    material.uniforms.uEdgeSoftness.value = params.filled ? 0.0 : params.edgeSoftness;
  }
  if (material.uniforms.uSizeFactorSmall) {
    material.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall;
  }
  if (material.uniforms.uSizeFactorMedium) {
    material.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium;
  }
  if (material.uniforms.uSizeFactorLarge) {
    material.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge;
  }
  if (material.uniforms.uTime) {
    material.uniforms.uTime.value = motionState.time;
  }
  if (material.uniforms.uMotionMode) {
    material.uniforms.uMotionMode.value = getMotionModeIndex();
  }
  if (material.uniforms.uMotionSpeed) {
    material.uniforms.uMotionSpeed.value = params.motionSpeed;
  }
  if (material.uniforms.uMotionAmplitude) {
    material.uniforms.uMotionAmplitude.value = params.motionAmplitude;
  }
  if (material.uniforms.uNoiseStrength) {
    material.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
  }
  if (material.uniforms.uNoiseScale) {
    material.uniforms.uNoiseScale.value = params.motionNoiseScale;
  }
  if (material.uniforms.uColor) {
    material.uniforms.uColor.value.copy(colorState.point);
  }
  if (material.uniforms.uColorAccent) {
    material.uniforms.uColorAccent.value.copy(colorState.accent);
  }
  if (material.uniforms.uColorDim) {
    material.uniforms.uColorDim.value.copy(colorState.dim);
  }
  if (material.uniforms.uColorMode) {
    material.uniforms.uColorMode.value = getColorModeIndex();
  }
  if (material.uniforms.uColorRadius) {
    const baseRadius = Math.max(1, colorState.radius);
    const override = Number.isFinite(radiusOverride) ? Math.max(1, radiusOverride) : baseRadius;
    material.uniforms.uColorRadius.value = override;
  }
  if (material.uniforms.uColorIntensity) {
    const intensity = Math.max(0, Math.min(1, Number(params.colorIntensity) || 0));
    material.uniforms.uColorIntensity.value = intensity;
  }
  if (material.uniforms.uColorSpeed) {
    const speed = Math.max(0, Number(params.colorSpeed) || 0);
    material.uniforms.uColorSpeed.value = speed;
  }
  if (material.uniforms.uColorPropagationDistance) {
    const distance = Math.max(0, Number(params.colorPropagationDistance) || 0);
    material.uniforms.uColorPropagationDistance.value = distance;
  }
  if (material.uniforms.uColorPropagationDuration) {
    const duration = Math.max(0, Number(params.colorPropagationDuration) || 0);
    material.uniforms.uColorPropagationDuration.value = duration;
  }
  if (material.uniforms.uColorToneCount) {
    const tones = Math.max(1, Math.round(Number(params.colorToneCount) || 1));
    params.colorToneCount = tones;
    material.uniforms.uColorToneCount.value = tones;
  }
  if (material.uniforms.uHueSpread) {
    const spread = Math.max(0, Math.min(360, Number(params.hueSpread) || 0));
    material.uniforms.uHueSpread.value = spread;
  }
  material.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  material.needsUpdate = true;
}

if (!stlMaterial) {
  stlMaterial = createPointShaderMaterial();
}

/* Create stars geometry and material */
function makeStars() {
  if (starPoints) {
    starGeometry.dispose();
    starMaterial.dispose();
    clusterGroup.remove(starPoints);
  }
  const smallCount = Math.max(0, Math.floor(Number(params.catSmallCount) || 0));
  const mediumCount = Math.max(0, Math.floor(Number(params.catMediumCount) || 0));
  const largeCount = Math.max(0, Math.floor(Number(params.catLargeCount) || 0));
  const total = clampTotalCount(smallCount + mediumCount + largeCount);
  params.count = total;
  if (total <= 0) {
    starGeometry = new THREE.BufferGeometry();
    starMaterial = null;
    starPoints = null;
    colorState.radius = Math.max(1, params.radius);
    return;
  }
  starGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(total * 3);
  const basePositions = new Float32Array(total * 3);
  const phases = new Float32Array(total);
  const sizes = new Float32Array(total);
  const cats  = new Float32Array(total);
  // thresholds for categories based on counts
  const smallShare = total > 0 ? smallCount / total : 0;
  const mediumShare = total > 0 ? mediumCount / total : 0;
  const mediumThreshold = Math.min(1, smallShare + mediumShare);
  const minSize = Math.max(0.05, 1 - params.sizeVar * 0.5);
  const maxSize = 1 + params.sizeVar * 0.5;
  const span = Math.max(0.0001, maxSize - minSize);
  const smallEnd = minSize + span * smallShare;
  const mediumEnd = minSize + span * mediumThreshold;
  // seeded random for star distribution
  const rand = mulberry32(params.seedStars);
  const phaseRand = mulberry32((params.seedStars ^ 0x51f32a95) >>> 0);
  const catRand = mulberry32(params.seedStars + 0x9e3779b9);
  const categoryPool = [];
  for (let i = 0; i < smallCount; i++) categoryPool.push(0);
  for (let i = 0; i < mediumCount; i++) categoryPool.push(1);
  for (let i = 0; i < largeCount; i++) categoryPool.push(2);
  for (let i = categoryPool.length - 1; i > 0; i--) {
    const j = Math.floor(catRand() * (i + 1));
    const tmp = categoryPool[i];
    categoryPool[i] = categoryPool[j];
    categoryPool[j] = tmp;
  }
  const orientation = new THREE.Matrix4();
  const orientEuler = new THREE.Euler(rand() * Math.PI * 2, rand() * Math.PI * 2, rand() * Math.PI * 2);
  orientation.makeRotationFromEuler(orientEuler);
  const tmpVec = new THREE.Vector3();
  const stlSamples = stlState.samples;
  const stlSampleCount = stlState.sampleCount || 0;
  const desiredRadius = Math.max(1e-3, Number(params.radius) || stlState.boundingRadius || 1);
  const stlRadius = Math.max(1e-3, stlState.boundingRadius || desiredRadius);
  const stlScale = params.distribution === 'stl' ? desiredRadius / stlRadius : 1;
  const stlIndexRand = params.distribution === 'stl'
    ? mulberry32((params.seedStars ^ 0x7f4a7c15) >>> 0)
    : null;
  const stlJitterStrength = params.distribution === 'stl'
    ? Math.max(0, params.cluster) * desiredRadius * 0.04
    : 0;
  const fibOffset = (params.distribution === 'fibonacci' && total > 0) ? (2 / total) : 0;
  const fibIncrement = Math.PI * (3 - Math.sqrt(5));
  const spiralArms = 4;
  const radius = params.radius;
  for (let i = 0; i < total; i++) {
    tmpVec.set(0, 0, 0);
    if (params.distribution === 'fibonacci') {
      const yv = ((i + 0.5) * fibOffset) - 1;
      const clampedY = Math.max(-1, Math.min(1, yv));
      const rCircle = Math.sqrt(Math.max(0, 1 - clampedY * clampedY));
      const phi = i * fibIncrement;
      const bias = params.cluster > 0 ? Math.pow(rand(), 1 + params.cluster * 2.2) : rand();
      const radial = radius * (0.35 + 0.65 * bias);
      let x = Math.cos(phi) * rCircle * radial;
      let y = clampedY * radial;
      let z = Math.sin(phi) * rCircle * radial;
      x += (rand() - 0.5) * radius * 0.04;
      y += (rand() - 0.5) * radius * 0.04;
      z += (rand() - 0.5) * radius * 0.04;
      tmpVec.set(x, y, z).applyMatrix4(orientation);
    } else if (params.distribution === 'spiral') {
      const t = total > 0 ? (i / total) : 0;
      const arm = i % spiralArms;
      const baseAngle = t * Math.PI * 6 + arm * (Math.PI * 2 / spiralArms);
      const spread = radius * Math.pow(rand(), 0.55 + params.cluster * 0.9);
      let x = Math.cos(baseAngle) * spread;
      let z = Math.sin(baseAngle) * spread;
      let y = (rand() - 0.5) * radius * (0.2 + 0.4 * (1 - params.cluster));
      x += (rand() - 0.5) * radius * 0.08;
      y += (rand() - 0.5) * radius * 0.08;
      z += (rand() - 0.5) * radius * 0.08;
      tmpVec.set(x, y, z).applyMatrix4(orientation);
    } else if (params.distribution === 'cube') {
      const shrink = params.cluster > 0 ? Math.pow(rand(), 1 + params.cluster * 1.8) : 1;
      tmpVec.set(
        (rand() * 2 - 1) * radius * shrink,
        (rand() * 2 - 1) * radius * shrink,
        (rand() * 2 - 1) * radius * shrink
      ).applyMatrix4(orientation);
    } else if (params.distribution === 'cylinder') {
      const radialBias = params.cluster > 0 ? Math.pow(rand(), 1 + params.cluster * 1.5) : rand();
      const r = radius * Math.sqrt(radialBias);
      const theta = rand() * Math.PI * 2;
      const heightRand = rand();
      const heightScale = params.cluster > 0 ? Math.pow(heightRand, 1 + params.cluster * 1.3) : heightRand;
      const y = (rand() < 0.5 ? -1 : 1) * radius * heightScale;
      tmpVec.set(
        Math.cos(theta) * r,
        y,
        Math.sin(theta) * r
      ).applyMatrix4(orientation);
    } else if (params.distribution === 'octahedron') {
      let accepted = false;
      for (let attempt = 0; attempt < 12 && !accepted; attempt++) {
        const px = rand() * 2 - 1;
        const py = rand() * 2 - 1;
        const pz = rand() * 2 - 1;
        const sum = Math.abs(px) + Math.abs(py) + Math.abs(pz);
        if (sum <= 1) {
          const bias = params.cluster > 0 ? Math.pow(rand(), 1 + params.cluster * 2.0) : 1;
          tmpVec.set(px * radius * bias, py * radius * bias, pz * radius * bias);
          accepted = true;
        }
      }
      if (!accepted) {
        tmpVec.set((rand() * 2 - 1) * radius, (rand() * 2 - 1) * radius, (rand() * 2 - 1) * radius);
      }
      tmpVec.applyMatrix4(orientation);
    } else if (params.distribution === 'stl') {
      if (stlSamples && stlSampleCount > 0 && stlIndexRand) {
        const idx = Math.floor(stlIndexRand() * stlSampleCount) % stlSampleCount;
        const baseIndex = idx * 3;
        let x = stlSamples[baseIndex];
        let y = stlSamples[baseIndex + 1];
        let z = stlSamples[baseIndex + 2];
        if (stlScale !== 1) {
          x *= stlScale;
          y *= stlScale;
          z *= stlScale;
        }
        if (stlJitterStrength > 0) {
          x += (rand() - 0.5) * stlJitterStrength;
          y += (rand() - 0.5) * stlJitterStrength;
          z += (rand() - 0.5) * stlJitterStrength;
        }
        tmpVec.set(x, y, z);
      } else {
        tmpVec.set((rand() * 2 - 1) * radius, (rand() * 2 - 1) * radius, (rand() * 2 - 1) * radius);
      }
    } else {
      const u = rand();
      const v = rand();
      const theta = 2 * Math.PI * u;
      const phi = Math.acos(2 * v - 1);
      let r = radius;
      if (rand() < params.cluster) {
        r *= rand();
      }
      tmpVec.set(
        r * Math.sin(phi) * Math.cos(theta),
        r * Math.sin(phi) * Math.sin(theta),
        r * Math.cos(phi)
      );
    }
    const x = tmpVec.x;
    const y = tmpVec.y;
    const z = tmpVec.z;
    positions.set([x, y, z], i * 3);
    basePositions.set([x, y, z], i * 3);
    const cat = categoryPool[i] !== undefined ? categoryPool[i] : 2;
    cats[i] = cat;
    let lower = mediumEnd;
    let upper = maxSize;
    if (cat === 0) {
      lower = minSize;
      upper = smallEnd;
    } else if (cat === 1) {
      lower = smallEnd;
      upper = mediumEnd;
    }
    if (upper - lower < 0.001) {
      sizes[i] = lower;
    } else {
      sizes[i] = lower + rand() * (upper - lower);
    }
    phases[i] = phaseRand();
  }
  const positionAttr = new THREE.BufferAttribute(positions, 3);
  const baseAttr = new THREE.BufferAttribute(basePositions, 3);
  const phaseAttr = new THREE.BufferAttribute(phases, 1);
  starGeometry.setAttribute('position', positionAttr);
  starGeometry.setAttribute('aBase', baseAttr);
  starGeometry.setAttribute('aPhase', phaseAttr);
  starGeometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
  starGeometry.setAttribute('aCat', new THREE.BufferAttribute(cats, 1));
  starGeometry.computeBoundingSphere();
  if (starGeometry.boundingSphere) {
    const center = starGeometry.boundingSphere.center.clone();
    if (center.lengthSq() > 1e-6) {
      for (let i = 0; i < positionAttr.count; i++) {
        positionAttr.setXYZ(
          i,
          positionAttr.getX(i) - center.x,
          positionAttr.getY(i) - center.y,
          positionAttr.getZ(i) - center.z
        );
        baseAttr.setXYZ(
          i,
          baseAttr.getX(i) - center.x,
          baseAttr.getY(i) - center.y,
          baseAttr.getZ(i) - center.z
        );
      }
      positionAttr.needsUpdate = true;
      baseAttr.needsUpdate = true;
      starGeometry.boundingSphere.center.set(0, 0, 0);
      controls.target.copy(clusterGroup.position);
    }
  }
  const sphere = starGeometry.boundingSphere;
  colorState.radius = sphere ? Math.max(1, sphere.radius) : Math.max(1, params.radius);
  starMaterial = createPointShaderMaterial();
  updatePointMaterialUniforms(starMaterial);
  starPoints = new THREE.Points(starGeometry, starMaterial);
  clusterGroup.add(starPoints);
  const existingStlPoints = stlState.points;
  if (stlMaterial) {
    stlMaterial.dispose();
    stlMaterial = null;
  }
  ensureStlMaterial();
  if (existingStlPoints && stlMaterial) {
    existingStlPoints.material = stlMaterial;
  }
}

/* Create tiny connection points */
function makeTiny() {
  disposeTinyResources();
  // Determine number of tiny points based on connPercent
  const nTiny = Math.round(params.tinyCount * params.connPercent);
  // Access star positions for connections
  const starPos = (starGeometry && starGeometry.getAttribute) ? starGeometry.getAttribute('position') : null;
  const nStars = starPos ? starPos.count : 0;
  if (!starPos || nStars === 0 || nTiny <= 0) {
    tinyPoints = undefined;
    return;
  }

  tinyGeometry = new THREE.BufferGeometry();
  const positions = new Float32Array(Math.max(0, nTiny * 3));
  const basePositions = new Float32Array(Math.max(0, nTiny * 3));
  const phases = new Float32Array(Math.max(0, nTiny));
  if (nTiny > 0 && nStars > 0) {
    const rand = mulberry32(params.seedTiny);
    const phaseRand = mulberry32((params.seedTiny ^ 0x9e3779b9) >>> 0);
    for (let i = 0; i < nTiny; i++) {
      // pick two random stars
      const idxA = Math.floor(rand() * nStars);
      const idxB = Math.floor(rand() * nStars);
      const ax = starPos.getX(idxA), ay = starPos.getY(idxA), az = starPos.getZ(idxA);
      const bx = starPos.getX(idxB), by = starPos.getY(idxB), bz = starPos.getZ(idxB);
      const t = rand();
      // linear interpolation between stars
      const x = ax + (bx - ax) * t;
      const y = ay + (by - ay) * t;
      const z = az + (bz - az) * t;
      positions.set([x, y, z], i * 3);
      basePositions.set([x, y, z], i * 3);
      phases[i] = phaseRand();
    }
  }
  tinyGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  tinyGeometry.setAttribute('aBase', new THREE.BufferAttribute(basePositions, 3));
  tinyGeometry.setAttribute('aPhase', new THREE.BufferAttribute(phases, 1));
  const tinyVert = `
    attribute vec3 aBase;
    attribute float aPhase;
    uniform float uSize;
    uniform float uTime;
    uniform float uMotionMode;
    uniform float uMotionSpeed;
    uniform float uMotionAmplitude;
    uniform float uNoiseStrength;
    uniform float uNoiseScale;
    uniform vec3 uAudioBands;
    uniform float uAudioEnergy;
    uniform float uAudioWave;
    varying float vDepth;
    varying vec3 vBase;
    varying float vPhase;
    varying float vRadius;

    float hash3(vec3 p) {
      return fract(sin(dot(p, vec3(127.1, 311.7, 74.7))) * 43758.5453123);
    }

    float valueNoise(vec3 p) {
      vec3 i = floor(p);
      vec3 f = fract(p);
      float n000 = hash3(i + vec3(0.0, 0.0, 0.0));
      float n100 = hash3(i + vec3(1.0, 0.0, 0.0));
      float n010 = hash3(i + vec3(0.0, 1.0, 0.0));
      float n110 = hash3(i + vec3(1.0, 1.0, 0.0));
      float n001 = hash3(i + vec3(0.0, 0.0, 1.0));
      float n101 = hash3(i + vec3(1.0, 0.0, 1.0));
      float n011 = hash3(i + vec3(0.0, 1.0, 1.0));
      float n111 = hash3(i + vec3(1.0, 1.0, 1.0));
      vec3 u = f * f * (3.0 - 2.0 * f);
      float nx00 = mix(n000, n100, u.x);
      float nx10 = mix(n010, n110, u.x);
      float nx01 = mix(n001, n101, u.x);
      float nx11 = mix(n011, n111, u.x);
      float nxy0 = mix(nx00, nx10, u.y);
      float nxy1 = mix(nx01, nx11, u.y);
      return mix(nxy0, nxy1, u.z);
    }

    vec3 applyAudioReactive(vec3 pos) {
      float radius = length(pos);
      if (radius < 1e-4) {
        return pos;
      }
      float bandMix = dot(uAudioBands, vec3(0.6, 0.3, 0.15));
      float wavePulse = uAudioWave * 0.6;
      float energyPulse = uAudioEnergy * 0.35;
      float ripple = sin(uTime * 4.2 + aPhase * 12.5663706) * (0.15 + wavePulse * 0.55);
      float scale = 1.0 + bandMix * 0.25 + energyPulse * 0.2 + wavePulse * 0.25;
      float newRadius = max(0.02, radius * scale + ripple * 6.0);
      vec3 radial = normalize(pos);
      return radial * newRadius;
    }

    vec3 applyMotion(vec3 base) {
      float mode = uMotionMode;
      float time = uTime * uMotionSpeed;
      if (mode < 0.5) {
        return base;
      } else if (mode < 1.5) {
        float phase = aPhase * 6.2831853;
        vec3 offset = vec3(
          sin(time + phase + base.x * 0.015),
          sin(time * 0.8 + phase * 1.3 + base.y * 0.02),
          sin(time * 1.2 + phase * 0.7 + base.z * 0.017)
        );
        return base + offset * uMotionAmplitude;
      } else if (mode < 2.5) {
        float scale = max(0.0001, uNoiseScale);
        vec3 samplePos = base * (0.01 * scale);
        float tx = valueNoise(vec3(samplePos.xy, time * 0.35 + aPhase));
        float ty = valueNoise(vec3(samplePos.yz, time * 0.35 + aPhase * 1.7));
        float tz = valueNoise(vec3(samplePos.zx, time * 0.35 + aPhase * 2.3));
        vec3 offset = vec3(tx, ty, tz) * 2.0 - 1.0;
        offset *= uMotionAmplitude * uNoiseStrength;
        return base + offset;
      } else {
        float phase = aPhase * 6.2831853;
        float angle = time * 0.6 + phase * 0.25;
        vec2 xz = base.xz;
        float radius = length(xz);
        float radial = max(0.0, radius + sin(time * 0.4 + phase) * uMotionAmplitude * 0.25);
        float c = cos(angle);
        float s = sin(angle);
        vec2 rotated = vec2(
          xz.x * c - xz.y * s,
          xz.x * s + xz.y * c
        );
        if (radial > 1e-4 && length(rotated) > 1e-5) {
          rotated = normalize(rotated) * radial;
        } else {
          rotated = vec2(radial * cos(angle), radial * sin(angle));
        }
        float yOffset = sin(time * 0.5 + phase * 0.5) * uMotionAmplitude * 0.3;
        return vec3(rotated.x, base.y + yOffset, rotated.y);
      }
    }

    void main() {
      vec3 animated = applyMotion(aBase);
      vec3 audioDriven = applyAudioReactive(animated);
      vBase = aBase;
      vPhase = aPhase;
      vRadius = length(aBase);
      vec4 mv = modelViewMatrix * vec4(audioDriven, 1.0);
      vDepth = -mv.z;
      float px = max(1.0, uSize * 6.0);
      gl_PointSize = px * (300.0 / max(1.0, vDepth));
      gl_Position = projectionMatrix * mv;
    }
  `;
  const tinyFrag = `
    precision highp float;
    uniform float uAlpha;
    uniform vec3 uColor;
    uniform vec3 uColorAccent;
    uniform vec3 uColorDim;
    uniform float uColorMode;
    uniform float uColorRadius;
    uniform float uColorIntensity;
    uniform float uColorSpeed;
    uniform float uColorPropagationDistance;
    uniform float uColorPropagationDuration;
    uniform float uColorToneCount;
    uniform float uHueSpread;
    uniform float uTime;
    varying vec3 vBase;
    varying float vPhase;
    varying float vRadius;

    vec3 rgb2hsv(vec3 c) {
      vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
      vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
      vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
      float d = q.x - min(q.w, q.y);
      float e = 1.0e-10;
      return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
    }

    vec3 hsv2rgb(vec3 c) {
      vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
      return c.z * mix(vec3(1.0), rgb, c.y);
    }

    vec3 computeColor() {
      float intensity = clamp(uColorIntensity, 0.0, 1.0);
      float hueSpreadNorm = uHueSpread / 360.0;
      float baseSpeed = max(uColorSpeed, 0.0);
      float colorTime = uTime * baseSpeed;
      float propagationOffset = 0.0;
      if (uColorPropagationDistance > 1e-4 && uColorPropagationDuration > 1e-4) {
        float normRadius = clamp(vRadius / uColorPropagationDistance, 0.0, 1.0);
        propagationOffset = normRadius * uColorPropagationDuration;
      }
      colorTime -= propagationOffset;
      vec3 baseHSVOriginal = rgb2hsv(uColor);
      vec3 accentHSVOriginal = rgb2hsv(uColorAccent);
      vec3 dimHSVOriginal = rgb2hsv(uColorDim);
      float hueShift = 0.0;
      if (hueSpreadNorm > 1e-6) {
        hueShift = sin(colorTime + vPhase * 6.2831853) * hueSpreadNorm;
      }
      vec3 baseHSV = baseHSVOriginal;
      baseHSV.x = fract(baseHSV.x + hueShift);
      vec3 accentHSV = accentHSVOriginal;
      accentHSV.x = fract(accentHSV.x + hueShift);
      vec3 dimHSV = dimHSVOriginal;
      dimHSV.x = fract(dimHSV.x + hueShift);
      vec3 baseColor = hsv2rgb(baseHSV);
      vec3 accentColor = hsv2rgb(accentHSV);
      vec3 dimColor = hsv2rgb(dimHSV);

      if (uColorMode < 0.5) {
        return baseColor;
      } else if (uColorMode < 1.5) {
        float norm = uColorRadius > 1e-4 ? clamp(vRadius / uColorRadius, 0.0, 1.0) : 0.0;
        float pulse = 0.5 + 0.5 * sin(colorTime * 2.8 + norm * 6.2831853 + vPhase * 4.7123889);
        vec3 effect = mix(baseColor, accentColor, pulse);
        return mix(baseColor, effect, intensity);
      } else if (uColorMode < 2.5) {
        float axis = clamp((vBase.y / max(uColorRadius, 1e-4)) * 0.5 + 0.5, 0.0, 1.0);
        float sweep = 0.5 + 0.5 * sin(colorTime * 1.8 + axis * 6.2831853);
        vec3 effect = mix(dimColor, accentColor, sweep);
        return mix(baseColor, effect, intensity);
      } else if (uColorMode < 3.5) {
        float flicker = fract(sin(vPhase * 43758.5453 + colorTime * 0.6) * 43758.5453);
        float mixAmt = smoothstep(0.15, 0.85, flicker);
        vec3 effect = mix(dimColor, accentColor, mixAmt);
        return mix(baseColor, effect, intensity);
      } else {
        float hueRange = hueSpreadNorm;
        float randA = sin(vPhase * 213.135 + colorTime * 1.47);
        float randB = sin(vPhase * 97.531 + colorTime * 1.03);
        float randC = sin(vPhase * 47.853 + colorTime * 1.71);
        float randomShift = (randA * 0.6 + randB * 0.4) * hueRange;
        vec3 rndHSV = baseHSVOriginal;
        rndHSV.x = fract(rndHSV.x + randomShift);
        rndHSV.y = clamp(rndHSV.y * (0.7 + 0.3 * (randB * 0.5 + 0.5)), 0.0, 1.0);
        rndHSV.z = clamp(rndHSV.z * (0.7 + 0.3 * (randC * 0.5 + 0.5)), 0.0, 1.2);
        vec3 randomColor = hsv2rgb(rndHSV);
        return mix(baseColor, randomColor, intensity);
      }
    }

    void main() {
      vec2 uv = gl_PointCoord * 2.0 - 1.0;
      float d = dot(uv, uv);
      if (d > 1.0) discard;
      float fade = 1.0 - smoothstep(0.6, 1.0, d);
      vec3 color = computeColor();
      float toneCount = max(uColorToneCount, 1.0);
      if (toneCount > 1.01) {
        vec3 quantized = rgb2hsv(color);
        quantized.x = floor(quantized.x * toneCount + 1e-4) / toneCount;
        color = hsv2rgb(quantized);
      }
      gl_FragColor = vec4(color, fade * uAlpha);
    }
  `;
  tinyMaterial = new THREE.ShaderMaterial({
    vertexShader: tinyVert,
    fragmentShader: tinyFrag,
    transparent: true,
    depthTest: true,
    depthWrite: false,
    uniforms: {
      uAlpha: { value: params.tinyAlpha },
      uSize: { value: params.sizeFactorTiny },
      uTime: { value: motionState.time },
      uMotionMode: { value: getMotionModeIndex() },
      uMotionSpeed: { value: params.motionSpeed },
      uMotionAmplitude: { value: params.motionAmplitude },
      uNoiseStrength: { value: params.motionNoiseStrength },
      uNoiseScale: { value: params.motionNoiseScale },
      uAudioBands: { value: new THREE.Vector3() },
      uAudioEnergy: { value: 0 },
      uAudioWave: { value: 0 },
      uColor: { value: colorState.point.clone() },
      uColorAccent: { value: colorState.accent.clone() },
      uColorDim: { value: colorState.dim.clone() },
      uColorMode: { value: getColorModeIndex() },
      uColorRadius: { value: colorState.radius },
      uColorIntensity: { value: params.colorIntensity },
      uColorSpeed: { value: params.colorSpeed },
      uColorPropagationDistance: { value: params.colorPropagationDistance },
      uColorPropagationDuration: { value: params.colorPropagationDuration },
      uColorToneCount: { value: params.colorToneCount },
      uHueSpread: { value: params.hueSpread },
    }
  });
  tinyMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  tinyPoints = new THREE.Points(tinyGeometry, tinyMaterial);
  clusterGroup.add(tinyPoints);
}

/* Update uniforms and materials when parameters change */
function updateStarUniforms() {
  if (!starMaterial) return;
  starMaterial.uniforms.uAlpha.value = params.pointAlpha;
  starMaterial.uniforms.uEdgeSoftness.value = params.filled ? 0.0 : params.edgeSoftness;
  starMaterial.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall;
  starMaterial.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium;
  starMaterial.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge;
  if (starMaterial.uniforms.uTime) {
    starMaterial.uniforms.uTime.value = motionState.time;
  }
  if (starMaterial.uniforms.uMotionMode) {
    starMaterial.uniforms.uMotionMode.value = getMotionModeIndex();
  }
  if (starMaterial.uniforms.uMotionSpeed) {
    starMaterial.uniforms.uMotionSpeed.value = params.motionSpeed;
  }
  if (starMaterial.uniforms.uMotionAmplitude) {
    starMaterial.uniforms.uMotionAmplitude.value = params.motionAmplitude;
  }
  if (starMaterial.uniforms.uNoiseStrength) {
    starMaterial.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
  }
  if (starMaterial.uniforms.uNoiseScale) {
    starMaterial.uniforms.uNoiseScale.value = params.motionNoiseScale;
  }
  if (starMaterial.uniforms.uColor) {
    starMaterial.uniforms.uColor.value.copy(colorState.point);
  }
  if (starMaterial.uniforms.uColorAccent) {
    starMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
  }
  if (starMaterial.uniforms.uColorDim) {
    starMaterial.uniforms.uColorDim.value.copy(colorState.dim);
  }
  if (starMaterial.uniforms.uColorMode) {
    starMaterial.uniforms.uColorMode.value = getColorModeIndex();
  }
  if (starMaterial.uniforms.uColorRadius) {
    starMaterial.uniforms.uColorRadius.value = Math.max(1, colorState.radius);
  }
  if (starMaterial.uniforms.uColorIntensity) {
    const intensity = Math.max(0, Math.min(1, Number(params.colorIntensity) || 0));
    starMaterial.uniforms.uColorIntensity.value = intensity;
  }
  if (starMaterial.uniforms.uColorSpeed) {
    const speed = Math.max(0, Number(params.colorSpeed) || 0);
    starMaterial.uniforms.uColorSpeed.value = speed;
  }
  if (starMaterial.uniforms.uColorPropagationDistance) {
    const distance = Math.max(0, Number(params.colorPropagationDistance) || 0);
    starMaterial.uniforms.uColorPropagationDistance.value = distance;
  }
  if (starMaterial.uniforms.uColorPropagationDuration) {
    const duration = Math.max(0, Number(params.colorPropagationDuration) || 0);
    starMaterial.uniforms.uColorPropagationDuration.value = duration;
  }
  if (starMaterial.uniforms.uColorToneCount) {
    const tones = Math.max(1, Math.round(Number(params.colorToneCount) || 1));
    params.colorToneCount = tones;
    starMaterial.uniforms.uColorToneCount.value = tones;
  }
  if (starMaterial.uniforms.uHueSpread) {
    const spread = Math.max(0, Math.min(360, Number(params.hueSpread) || 0));
    starMaterial.uniforms.uHueSpread.value = spread;
  }
  starMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  starMaterial.needsUpdate = true;
  if (stlMaterial && stlMaterial.uniforms) {
    if (stlMaterial.uniforms.uAlpha) {
      stlMaterial.uniforms.uAlpha.value = params.pointAlpha;
    }
    if (stlMaterial.uniforms.uEdgeSoftness) {
      stlMaterial.uniforms.uEdgeSoftness.value = params.filled ? 0.0 : params.edgeSoftness;
    }
    if (stlMaterial.uniforms.uSizeFactorSmall) {
      stlMaterial.uniforms.uSizeFactorSmall.value = params.sizeFactorSmall;
    }
    if (stlMaterial.uniforms.uSizeFactorMedium) {
      stlMaterial.uniforms.uSizeFactorMedium.value = params.sizeFactorMedium;
    }
    if (stlMaterial.uniforms.uSizeFactorLarge) {
      stlMaterial.uniforms.uSizeFactorLarge.value = params.sizeFactorLarge;
    }
    if (stlMaterial.uniforms.uTime) {
      stlMaterial.uniforms.uTime.value = motionState.time;
    }
    if (stlMaterial.uniforms.uMotionMode) {
      stlMaterial.uniforms.uMotionMode.value = getMotionModeIndex();
    }
    if (stlMaterial.uniforms.uMotionSpeed) {
      stlMaterial.uniforms.uMotionSpeed.value = params.motionSpeed;
    }
    if (stlMaterial.uniforms.uMotionAmplitude) {
      stlMaterial.uniforms.uMotionAmplitude.value = params.motionAmplitude;
    }
    if (stlMaterial.uniforms.uNoiseStrength) {
      stlMaterial.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
    }
    if (stlMaterial.uniforms.uNoiseScale) {
      stlMaterial.uniforms.uNoiseScale.value = params.motionNoiseScale;
    }
    if (stlMaterial.uniforms.uColor) {
      stlMaterial.uniforms.uColor.value.copy(colorState.point);
    }
    if (stlMaterial.uniforms.uColorAccent) {
      stlMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
    }
    if (stlMaterial.uniforms.uColorDim) {
      stlMaterial.uniforms.uColorDim.value.copy(colorState.dim);
    }
    if (stlMaterial.uniforms.uColorMode) {
      stlMaterial.uniforms.uColorMode.value = getColorModeIndex();
    }
    if (stlMaterial.uniforms.uColorRadius) {
      const radius = Math.max(1, Math.max(colorState.radius, stlState.boundingRadius || 0));
      stlMaterial.uniforms.uColorRadius.value = radius;
    }
    if (stlMaterial.uniforms.uColorIntensity) {
      const intensity = Math.max(0, Math.min(1, Number(params.colorIntensity) || 0));
      stlMaterial.uniforms.uColorIntensity.value = intensity;
    }
    if (stlMaterial.uniforms.uColorSpeed) {
      const speed = Math.max(0, Number(params.colorSpeed) || 0);
      stlMaterial.uniforms.uColorSpeed.value = speed;
    }
    if (stlMaterial.uniforms.uColorPropagationDistance) {
      const distance = Math.max(0, Number(params.colorPropagationDistance) || 0);
      stlMaterial.uniforms.uColorPropagationDistance.value = distance;
    }
    if (stlMaterial.uniforms.uColorPropagationDuration) {
      const duration = Math.max(0, Number(params.colorPropagationDuration) || 0);
      stlMaterial.uniforms.uColorPropagationDuration.value = duration;
    }
    if (stlMaterial.uniforms.uColorToneCount) {
      const tones = Math.max(1, Math.round(Number(params.colorToneCount) || 1));
      stlMaterial.uniforms.uColorToneCount.value = tones;
    }
    if (stlMaterial.uniforms.uHueSpread) {
      const spread = Math.max(0, Math.min(360, Number(params.hueSpread) || 0));
      stlMaterial.uniforms.uHueSpread.value = spread;
    }
    stlMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
    stlMaterial.needsUpdate = true;
  }
  updatePointMaterialUniforms(starMaterial);
  const radius = Math.max(colorState.radius, stlState.boundingRadius || 0);
  updatePointMaterialUniforms(stlMaterial, { radiusOverride: radius });
}

function updateTinyMaterial() {
  if (!tinyMaterial) return;
  tinyMaterial.uniforms.uAlpha.value = params.tinyAlpha;
  tinyMaterial.uniforms.uSize.value = params.sizeFactorTiny;
  if (tinyMaterial.uniforms.uTime) {
    tinyMaterial.uniforms.uTime.value = motionState.time;
  }
  if (tinyMaterial.uniforms.uMotionMode) {
    tinyMaterial.uniforms.uMotionMode.value = getMotionModeIndex();
  }
  if (tinyMaterial.uniforms.uMotionSpeed) {
    tinyMaterial.uniforms.uMotionSpeed.value = params.motionSpeed;
  }
  if (tinyMaterial.uniforms.uMotionAmplitude) {
    tinyMaterial.uniforms.uMotionAmplitude.value = params.motionAmplitude;
  }
  if (tinyMaterial.uniforms.uNoiseStrength) {
    tinyMaterial.uniforms.uNoiseStrength.value = params.motionNoiseStrength;
  }
  if (tinyMaterial.uniforms.uNoiseScale) {
    tinyMaterial.uniforms.uNoiseScale.value = params.motionNoiseScale;
  }
  if (tinyMaterial.uniforms.uColor) {
    tinyMaterial.uniforms.uColor.value.copy(colorState.point);
  }
  if (tinyMaterial.uniforms.uColorAccent) {
    tinyMaterial.uniforms.uColorAccent.value.copy(colorState.accent);
  }
  if (tinyMaterial.uniforms.uColorDim) {
    tinyMaterial.uniforms.uColorDim.value.copy(colorState.dim);
  }
  if (tinyMaterial.uniforms.uColorMode) {
    tinyMaterial.uniforms.uColorMode.value = getColorModeIndex();
  }
  if (tinyMaterial.uniforms.uColorRadius) {
    tinyMaterial.uniforms.uColorRadius.value = Math.max(1, colorState.radius);
  }
  if (tinyMaterial.uniforms.uColorIntensity) {
    const intensity = Math.max(0, Math.min(1, Number(params.colorIntensity) || 0));
    tinyMaterial.uniforms.uColorIntensity.value = intensity;
  }
  if (tinyMaterial.uniforms.uColorSpeed) {
    const speed = Math.max(0, Number(params.colorSpeed) || 0);
    tinyMaterial.uniforms.uColorSpeed.value = speed;
  }
  if (tinyMaterial.uniforms.uColorPropagationDistance) {
    const distance = Math.max(0, Number(params.colorPropagationDistance) || 0);
    tinyMaterial.uniforms.uColorPropagationDistance.value = distance;
  }
  if (tinyMaterial.uniforms.uColorPropagationDuration) {
    const duration = Math.max(0, Number(params.colorPropagationDuration) || 0);
    tinyMaterial.uniforms.uColorPropagationDuration.value = duration;
  }
  if (tinyMaterial.uniforms.uColorToneCount) {
    const tones = Math.max(1, Math.round(Number(params.colorToneCount) || 1));
    params.colorToneCount = tones;
    tinyMaterial.uniforms.uColorToneCount.value = tones;
  }
  if (tinyMaterial.uniforms.uHueSpread) {
    const spread = Math.max(0, Math.min(360, Number(params.hueSpread) || 0));
    tinyMaterial.uniforms.uHueSpread.value = spread;
  }
  tinyMaterial.blending = (params.blending === 'Additive') ? THREE.AdditiveBlending : THREE.NormalBlending;
  tinyMaterial.needsUpdate = true;
}

/* Rebuild functions */
function rebuildStars() {
  makeStars();
  updateStarUniforms();
  // regenerate tiny connections as they depend on star positions
  makeTiny();
  updateTinyMaterial();
}
function rebuildTiny() {
  makeTiny();
  updateTinyMaterial();
}

/* Bind UI elements */
const $ = id => document.getElementById(id);
const panel = $('panel');
const toggleBtn = $('toggle');
const editModeBtn = $('editMode');
const lockBtn = $('lock');
const sheetHandleBtn = $('sheetHandle');
const bar = $('bar');
const barHotspot = $('barHotspot');
const barButtons = bar ? Array.from(bar.querySelectorAll('button')) : [];
const startInEditingMode = (() => {
  const params = new URLSearchParams(window.location.search);
  return params.get('edit') === '1' || window.location.hash.includes('edit');
})();
const mobileSheetQuery = window.matchMedia('(max-width: 768px)');
const sheetState = {
  mode: 'compact',
  expandedHeight: 0,
  compactHeight: 0,
  pointerId: null,
  startY: 0,
  startOffset: 0,
  lastOffset: 0,
  moved: false,
  preventClick: false,
};

audioUI.panel = $('audioPanel');
audioUI.body = $('audioPanelBody');
audioUI.toggle = $('audioPanelToggle');
audioUI.fileInput = $('audioFile');
audioUI.fileMeta = $('audioFileMeta');
audioUI.playlistMeta = $('audioPlaylistMeta');
audioUI.playBtn = $('audioPlay');
audioUI.stopBtn = $('audioStop');
audioUI.prevBtn = $('audioPrev');
audioUI.nextBtn = $('audioNext');
audioUI.repeatBtn = $('audioRepeat');
audioUI.micStartBtn = $('audioMicStart');
audioUI.micStopBtn = $('audioMicStop');
audioUI.statusText = $('audioStatus');
audioUI.statusDot = $('audioStatusDot');
audioUI.modifierButtons = Array.from(document.querySelectorAll('#audioModifierGrid [data-modifier]'));
youtubeUI.playlistInput = $('youtubePlaylistUrl');
youtubeUI.loadBtn = $('youtubeLoad');
youtubeUI.playBtn = $('youtubePlay');
youtubeUI.pauseBtn = $('youtubePause');
youtubeUI.prevBtn = $('youtubePrev');
youtubeUI.nextBtn = $('youtubeNext');
youtubeUI.status = $('youtubeStatus');
youtubeUI.recentContainer = $('recentPlaylists');
youtubeUI.recentList = $('recentPlaylistList');
youtubeUI.recentNewBtn = $('recentPlaylistNew');
queueUI.sheet = $('playerQueueSheet');
queueUI.list = $('queueList');
queueUI.meta = $('queueMeta');
queueUI.empty = $('queueEmpty');
queueUI.addLocal = $('queueAddLocal');
queueUI.addPreset = $('queueAddPreset');
queueUI.fileInput = $('queueFileInput');
queueUI.addYoutube = $('queueAddYoutube');
queueUI.youtubeInput = $('queueYoutubeInput');
queueUI.close = $('queueClose');
queueUI.recentContainer = $('queueRecentPlaylists');
queueUI.recentList = $('queueRecentList');
queueUI.recentNewBtn = $('queueRecentNew');

recentYouTubePlaylists = loadRecentYouTubePlaylists();

const barState = {
  visible: bar ? bar.classList.contains('is-visible') : false,
  hideTimeout: null,
};

let panelVisible = false;
let audioPanelVisible = false;
let cameraLocked = false;
const experienceState = {
  started: false,
  panelsHiddenForPlayback: false,
  previousPanelVisible: null,
  previousBarVisible: null,
  pendingOverlayStart: false,
  editingMode: false,
  editingPreviousPanel: null,
  editingPreviousBar: null
};

if (barButtons.length) {
  barButtons.forEach(button => {
    const existing = button.getAttribute('tabindex');
    button.dataset.barDefaultTabindex = existing === null ? '' : existing;
  });
  if (!barState.visible) {
    barButtons.forEach(button => {
      button.setAttribute('tabindex', '-1');
    });
  }
}

function setBarFocusability(hidden) {
  if (!barButtons.length) return;
  barButtons.forEach(button => {
    if (hidden) {
      button.setAttribute('tabindex', '-1');
    } else {
      const stored = button.dataset.barDefaultTabindex;
      if (typeof stored === 'string') {
        if (stored.length) {
          button.setAttribute('tabindex', stored);
        } else {
          button.removeAttribute('tabindex');
        }
      }
    }
  });
}

function setBarVisible(show) {
  if (!bar) return;
  const next = !!show;
  if (barState.visible === next) return;
  barState.visible = next;
  bar.classList.toggle('is-visible', next);
  bar.setAttribute('aria-hidden', next ? 'false' : 'true');
  setBarFocusability(!next);
}

function scheduleBarHide(delay) {
  if (!bar) return;
  if (barState.hideTimeout !== null) {
    clearTimeout(barState.hideTimeout);
    barState.hideTimeout = null;
  }
  if (delay == null) return;
  const timeout = Math.max(0, Number(delay) || 0);
  barState.hideTimeout = window.setTimeout(() => {
    barState.hideTimeout = null;
    if (bar && bar.contains(document.activeElement)) {
      scheduleBarHide(timeout);
      return;
    }
    setBarVisible(false);
  }, timeout);
}

function showBar(options = {}) {
  if (!bar) return;
  const { autoHideDelay = null } = options;
  setBarVisible(true);
  if (autoHideDelay !== undefined) {
    scheduleBarHide(autoHideDelay);
  }
}

function hideBar(options = {}) {
  if (!bar) return;
  const { immediate = false, delay = 900 } = options;
  if (immediate) {
    scheduleBarHide(null);
    setBarVisible(false);
    return;
  }
  scheduleBarHide(delay);
}

function initializeBarReveal({ initialReveal = true } = {}) {
  if (!bar) return;
  if (initialReveal) {
    showBar({ autoHideDelay: 2800 });
  } else {
    setBarVisible(false);
    scheduleBarHide(null);
  }
  const reveal = () => showBar({ autoHideDelay: 4200 });
  const deferHide = () => hideBar({ delay: 1000 });
  if (barHotspot) {
    const pointerEvents = ['pointerenter', 'pointerdown', 'pointermove'];
    pointerEvents.forEach(eventName => {
      barHotspot.addEventListener(eventName, reveal, { passive: true });
    });
    barHotspot.addEventListener('touchstart', reveal, { passive: true });
    barHotspot.addEventListener('pointerleave', deferHide);
    barHotspot.addEventListener('touchend', deferHide);
    barHotspot.addEventListener('touchcancel', deferHide);
  }
  bar.addEventListener('pointerenter', () => showBar({ autoHideDelay: null }));
  bar.addEventListener('pointerleave', () => hideBar({ delay: 1000 }));
  bar.addEventListener('focusin', () => showBar({ autoHideDelay: null }));
  bar.addEventListener('focusout', () => {
    window.requestAnimationFrame(() => {
      if (!bar.contains(document.activeElement)) {
        hideBar({ delay: 800 });
      }
    });
  });
  document.addEventListener('keydown', event => {
    if (event.key === 'Escape') {
      hideBar({ immediate: true });
    }
  });
}

initializeBarReveal({ initialReveal: !startInEditingMode });
audioUI.intensityControls = new Map();
audioUI.supportNotice = $('audioSupportNotice');
audioUI.autoRandomBtn = $('audioRandomMode');
audioUI.overlay = $('audioOverlay');
audioUI.overlayButton = $('audioOverlayButton');
audioUI.brightnessAdaptationBtn = $('brightnessAdaptationToggle');

stlUI.input = $('stlFiles');
stlUI.meta = $('stlFileMeta');
stlUI.clearBtn = $('stlClear');
stlDistributionOption = document.querySelector('#pDistribution option[value="stl"]');
updateStlOptionAvailability();

playerUI.shell = $('playerShell');
playerUI.source = $('playerSource');
playerUI.title = $('playerTitle');
playerUI.meta = $('playerMeta');
playerUI.studioToggle = $('studioToggle');
playerUI.sourceCycle = $('playerSourceCycle');
playerUI.prev = $('playerPrev');
playerUI.play = $('playerPlay');
playerUI.next = $('playerNext');
playerUI.repeat = $('playerRepeat');
playerUI.queue = $('playerQueue');
playerUI.random = $('playerRandomStyle');
playerUI.styles = $('playerStyles');
playerUI.moods = $('playerMoods');
playerUI.complexity = $('playerComplexity');
playerUI.motion = $('playerMotion');
playerUI.reactivity = $('playerReactivity');
playerUI.progress = $('playerProgress');
playerUI.time = $('playerTime');
playerUI.duration = $('playerDuration');

if (stlUI.input) {
  stlUI.input.addEventListener('change', event => {
    const files = event.target.files ? Array.from(event.target.files).filter(Boolean) : [];
    loadStlFilesFromInput(files).catch(error => {
      console.error('Fehler beim Verarbeiten der STL-Auswahl:', error);
      updateStlMeta([], { error: 'Fehler beim Laden der STL-Dateien.' });
    });
  });
}
if (stlUI.clearBtn) {
  stlUI.clearBtn.addEventListener('click', () => {
    clearStlModels();
  });
}

updateStlMeta([]);

if (audioUI.toggle && audioUI.body) {
  audioUI.toggle.addEventListener('click', () => {
    const expanded = audioUI.toggle.getAttribute('aria-expanded') === 'true';
    const next = !expanded;
    audioUI.toggle.setAttribute('aria-expanded', String(next));
    if (next) {
      audioUI.body.hidden = false;
      if (audioUI.panel) audioUI.panel.classList.remove('is-collapsed');
    } else {
      audioUI.body.hidden = true;
      if (audioUI.panel) audioUI.panel.classList.add('is-collapsed');
    }
  });
}

document.querySelectorAll('[data-intensity-target]').forEach(input => {
  const key = input.dataset.intensityTarget;
  if (!key || !(key in AUDIO_INTENSITY_DEFAULTS)) return;
  const container = input.closest('[data-intensity-row]') || input.parentElement;
  const valueEl = document.querySelector(`[data-intensity-value="${key}"]`);
  const limitInput = container ? container.querySelector(`[data-intensity-limit="${key}"]`) : null;
  audioUI.intensityControls.set(key, { input, valueEl, container, limitInput });
  const limit = getAudioIntensityLimit(key);
  const baseValue = audioState.intensity && key in audioState.intensity
    ? audioState.intensity[key]
    : (AUDIO_INTENSITY_BASE_DEFAULTS[key] || limit || 1);
  const limitPercent = clampIntensityPercent(limit * 100, (AUDIO_INTENSITY_LIMIT_DEFAULTS[key] || 1) * 100, 200);
  const initialPercent = limit > 0
    ? clampIntensityPercent((Number.isFinite(baseValue) ? baseValue : limit) / limit * 100, 0, 100)
    : 0;
  input.value = String(initialPercent);
  input.setAttribute('aria-valuemin', '0');
  input.setAttribute('aria-valuemax', '100');
  if (valueEl) {
    valueEl.textContent = `${initialPercent}% (Max ${limitPercent}%)`;
    valueEl.setAttribute('title', `Aktuell ${initialPercent}% von ${limitPercent}%`);
  }
  if (limitInput) {
    limitInput.value = String(limitPercent);
    limitInput.addEventListener('input', event => {
      setAudioIntensityLimit(key, event.target.value);
    });
    limitInput.addEventListener('change', event => {
      setAudioIntensityLimit(key, event.target.value);
    });
  }
  input.addEventListener('input', event => {
    setAudioIntensity(key, event.target.value);
  });
});
syncAudioIntensityControls();

function updateAutoRandomButton(forceDisabled = false) {
  if (!audioUI.autoRandomBtn) return;
  const disabled = Boolean(forceDisabled || experienceState.editingMode);
  if (disabled) {
    audioUI.autoRandomBtn.disabled = true;
    audioUI.autoRandomBtn.setAttribute('aria-disabled', 'true');
  } else {
    audioUI.autoRandomBtn.disabled = false;
    audioUI.autoRandomBtn.removeAttribute('aria-disabled');
  }
  audioUI.autoRandomBtn.setAttribute('aria-pressed', autoRandomState.enabled ? 'true' : 'false');
  audioUI.autoRandomBtn.textContent = autoRandomState.enabled ? 'üîÄ Random-Modus an' : 'üîÄ Random-Modus aus';
}

function scheduleNextAutoRandom() {
  const min = autoRandomState.minInterval;
  const max = autoRandomState.maxInterval;
  const playing = audioState.playing || audioState.usingMic;
  const drive = playing ? Math.max(audioState.metrics.energy, audioState.metrics.bass, audioState.metrics.wave) : 0;
  const baseInterval = min + Math.random() * Math.max(0, max - min);
  const modulation = playing ? Math.max(0.45, 1 - Math.min(0.65, drive * 0.8)) : 1;
  const interval = Math.max(6, baseInterval * modulation);
  autoRandomState.nextTrigger = autoRandomState.elapsed + interval;
}

function setAutoRandomEnabled(enabled) {
  const next = experienceState.editingMode ? false : Boolean(enabled);
  if (autoRandomState.enabled === next) {
    updateAutoRandomButton();
    return;
  }
  autoRandomState.enabled = next;
  autoRandomState.nudgeAccumulator = 0;
  if (autoRandomState.enabled) {
    autoRandomState.elapsed = 0;
    scheduleNextAutoRandom();
  } else {
    autoRandomState.nextTrigger = Infinity;
  }
  updateAutoRandomButton();
}

function isUserInteractingWithControls() {
  const active = document.activeElement;
  if (!active || active === document.body) return false;
  if (panel && panel.contains(active)) return true;
  if (audioUI.panel && audioUI.panel.contains(active)) return true;
  return false;
}

function nudgeSliderValue(id, delta) {
  const handler = sliderHandlers[id];
  const getter = sliderValueGetters[id];
  if (typeof handler !== 'function' || typeof getter !== 'function') {
    return false;
  }
  const current = Number(getter());
  const change = Number(delta);
  if (!Number.isFinite(current) || !Number.isFinite(change) || Math.abs(change) < 1e-4) {
    return false;
  }
  const next = clampToSliderBounds(id, current + change);
  if (!Number.isFinite(next) || Math.abs(next - current) < 1e-4) {
    return false;
  }
  handler(next);
  return true;
}

function applyAudioDrivenTweaks(delta, playing) {
  if (!playing) {
    autoRandomState.nudgeAccumulator = 0;
    return false;
  }
  if (isUserInteractingWithControls()) {
    autoRandomState.nudgeAccumulator = 0;
    return false;
  }
  autoRandomState.nudgeAccumulator += delta;
  const dynamicInterval = Math.max(0.18, autoRandomState.nudgeInterval - audioState.metrics.wave * 0.2);
  if (autoRandomState.nudgeAccumulator < dynamicInterval) {
    return false;
  }
  autoRandomState.nudgeAccumulator = 0;

  const bass = audioState.metrics.bass;
  const energy = audioState.metrics.energy;
  const wave = audioState.metrics.wave;
  const treble = audioState.metrics.treble;
  const drive = Math.max(bass * 1.15 + energy * 0.75, wave * 0.9 + treble * 0.7);
  const gain = Math.max(0, Math.min(1.6, drive * (0.6 + getAudioIntensity('scale') * 0.4)));
  if (gain < 0.18) {
    return false;
  }

  const operations = [
    () => nudgeSliderValue('pMotionSpeed', randomRange(-0.32, 0.52) * gain),
    () => nudgeSliderValue('pMotionAmplitude', randomRange(-4.5, 5.5) * gain),
    () => nudgeSliderValue('pMotionNoiseStrength', randomRange(-0.38, 0.6) * gain),
    () => nudgeSliderValue('pMotionNoiseScale', randomRange(-0.38, 0.42) * gain),
    () => nudgeSliderValue('pColorSpeed', randomRange(-0.45, 0.65) * gain),
    () => nudgeSliderValue('pColorIntensity', randomRange(-0.35, 0.35) * gain),
    () => nudgeSliderValue('pHueSpread', randomRange(-16, 18) * gain),
    () => nudgeSliderValue('pHue', (treble * 35 - 17) * gain + randomRange(-8, 8) * gain),
    () => nudgeSliderValue('pSaturation', randomRange(-0.18, 0.22) * gain),
    () => nudgeSliderValue('pValue', randomRange(-0.15, 0.2) * gain),
    () => nudgeSliderValue('pPointAlpha', randomRange(-0.12, 0.15) * gain),
    () => nudgeSliderValue('pSizeVar', randomRange(-0.42, 0.5) * gain),
    () => nudgeSliderValue('pSizeSmall', randomRange(-0.24, 0.28) * gain * 0.6),
    () => nudgeSliderValue('pSizeMedium', randomRange(-0.24, 0.28) * gain * 0.6),
    () => nudgeSliderValue('pSizeLarge', randomRange(-0.24, 0.28) * gain * 0.6)
  ];
  const attempts = Math.max(1, Math.min(operations.length, Math.round(2 + drive * 4)));
  let changed = false;
  for (let i = 0; i < attempts && operations.length; i++) {
    const index = Math.floor(Math.random() * operations.length);
    const op = operations.splice(index, 1)[0];
    if (op && op()) {
      changed = true;
    }
  }
  return changed;
}

function updateAutoRandom(delta) {
  if (experienceState.editingMode) {
    autoRandomState.elapsed = 0;
    autoRandomState.nextTrigger = Infinity;
    return;
  }
  autoRandomState.elapsed += delta;
  if (!autoRandomState.enabled) {
    return;
  }
  const playing = audioState.playing || audioState.usingMic;
  if (autoRandomState.elapsed >= autoRandomState.nextTrigger) {
    if (playing) {
      randomizeParameters({ syncUI: true });
    }
    scheduleNextAutoRandom();
  }
  const nudged = applyAudioDrivenTweaks(delta, playing);
  if (nudged) {
    setSliders();
  }
}

if (audioUI.modifierButtons.length) {
  audioUI.modifierButtons.forEach(button => {
    button.addEventListener('click', () => {
      const key = button.dataset.modifier;
      if (key) {
        toggleAudioModifier(key);
      }
    });
  });
}

if (audioUI.autoRandomBtn) {
  audioUI.autoRandomBtn.addEventListener('click', () => {
    setAutoRandomEnabled(!autoRandomState.enabled);
  });
  updateAutoRandomButton(false);
}

if (audioUI.overlayButton) {
  audioUI.overlayButton.addEventListener('click', async () => {
    if (audioUI.overlayButton.disabled) return;
    audioUI.overlayButton.disabled = true;
    audioUI.overlayButton.setAttribute('aria-busy', 'true');
    const started = await requestPlaybackStart({ preferCurrent: false });
    if (!started && shouldShowAudioOverlay()) {
      audioUI.overlayButton.disabled = false;
    }
    audioUI.overlayButton.removeAttribute('aria-busy');
    updateAudioOverlayVisibility();
  });
}

setAutoRandomEnabled(false);
updateAudioOverlayVisibility();
renderRecentPlaylists();

if (youtubeUI.recentNewBtn) {
  youtubeUI.recentNewBtn.addEventListener('click', () => {
    focusNewPlaylistInput();
  });
}

if (queueUI.recentNewBtn) {
  queueUI.recentNewBtn.addEventListener('click', () => {
    focusNewPlaylistInput();
  });
}

document.addEventListener('keydown', event => {
  if ((event.code !== 'Space' && event.key !== ' ') || event.defaultPrevented) {
    return;
  }
  if (event.repeat) {
    return;
  }
  const target = event.target;
  if (target && (target.isContentEditable || /^(INPUT|TEXTAREA|SELECT)$/i.test(target.tagName))) {
    return;
  }
  event.preventDefault();
  if (audioState.playing || audioState.usingMic) {
    stopAudioFromUser();
    setEditingMode(true, { skipStop: true });
  } else {
    requestPlaybackStart({ preferCurrent: true });
  }
});

if (audioUI.brightnessAdaptationBtn) {
  audioUI.brightnessAdaptationBtn.addEventListener('click', () => {
    setBrightnessAdaptationEnabled(!isBrightnessAdaptationEnabled());
  });
  updateBrightnessAdaptationButton();
}

if (audioUI.fileInput) {
  audioUI.fileInput.addEventListener('change', event => {
    const files = event.target.files ? Array.from(event.target.files).filter(Boolean) : [];
    if (audioState.playing || audioState.usingMic) {
      stopAudioPlayback();
    }
    setPlaylist(files);
    if (files.length) {
      const label = files.length === 1
        ? (files[0].name || 'Audio-Datei')
        : `${files.length} Titel`;
      setAudioStatus(`Playlist geladen ‚Äì ${label}`, 'idle');
    } else if (!audioState.playing) {
      setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
    }
    refreshAudioUI();
    event.target.value = '';
  });
}

if (queueUI.close) {
  queueUI.close.addEventListener('click', () => setQueueOpen(false));
}

if (queueUI.addLocal && queueUI.fileInput) {
  queueUI.addLocal.addEventListener('click', () => {
    queueUI.fileInput.click();
  });
}

if (queueUI.fileInput) {
  queueUI.fileInput.addEventListener('change', event => {
    const files = event.target.files ? Array.from(event.target.files).filter(Boolean) : [];
    if (!files.length) return;
    if (audioState.playing || audioState.usingMic) {
      stopAudioPlayback();
    }
    setPlaylist(files, { append: true });
    const label = files.length === 1
      ? (files[0].name || 'Audio-Datei')
      : `${files.length} Titel`;
    setAudioStatus(`Hinzugef√ºgt: ${label}`, 'info');
    refreshAudioUI();
    event.target.value = '';
  });
}

if (queueUI.addPreset) {
  queueUI.addPreset.addEventListener('click', () => {
    appendPresetTracksToPlaylist();
  });
}

if (queueUI.addYoutube) {
  queueUI.addYoutube.addEventListener('click', async () => {
    const value = (queueUI.youtubeInput && queueUI.youtubeInput.value) || (youtubeUI.playlistInput && youtubeUI.playlistInput.value) || '';
    const imported = await loadYouTubePlaylistFromInput(value);
    if (imported && queueUI.youtubeInput) {
      queueUI.youtubeInput.value = '';
    }
  });
}

if (audioUI.playBtn) {
  audioUI.playBtn.addEventListener('click', () => {
    requestPlaybackStart({ preferCurrent: true });
  });
}

if (audioUI.stopBtn) {
  audioUI.stopBtn.addEventListener('click', () => {
    stopAudioFromUser();
  });
}

if (audioUI.prevBtn) {
  audioUI.prevBtn.addEventListener('click', () => {
    playPreviousTrack({ wrap: true });
  });
}

if (audioUI.nextBtn) {
  audioUI.nextBtn.addEventListener('click', () => {
    playNextTrack({ wrap: true });
  });
}

if (playerUI.play) {
  playerUI.play.addEventListener('click', () => {
    if (audioState.playing && !audioState.usingMic && !audioState.youtubeActive) {
      pauseAudioPlayback();
    } else if (audioState.pausedAt > 0 && audioState.currentBuffer) {
      resumePausedTrack();
    } else {
      requestPlaybackStart({ preferCurrent: true });
    }
  });
}
if (playerUI.prev) {
  playerUI.prev.addEventListener('click', () => playPreviousTrack({ wrap: true }));
}
if (playerUI.next) {
  playerUI.next.addEventListener('click', () => playNextTrack({ wrap: true }));
}
if (playerUI.repeat) {
  playerUI.repeat.addEventListener('click', () => {
    cycleRepeatMode();
    refreshAudioUI();
  });
}
if (playerUI.queue) {
  playerUI.queue.addEventListener('click', () => {
    setPanelVisible(true);
    setAudioPanelVisible(true);
    showBar({ autoHideDelay: 2400 });
  });
}
if (playerUI.random) {
  playerUI.random.addEventListener('click', () => {
    generateRandomBiome({ syncUI: true, repositionCamera: true });
  });
}
if (playerUI.styles) {
  playerUI.styles.addEventListener('click', event => {
    const btn = event.target.closest('[data-style]');
    if (!btn) return;
    applyPlayerStyle(btn.dataset.style);
  });
}
if (playerUI.moods) {
  playerUI.moods.addEventListener('click', event => {
    const btn = event.target.closest('[data-mood]');
    if (!btn) return;
    applyPlayerMood(btn.dataset.mood);
  });
}
if (playerUI.complexity) {
  playerUI.complexity.addEventListener('input', event => {
    applyPlayerComplexityMacro(event.target.value);
  });
}
if (playerUI.motion) {
  playerUI.motion.addEventListener('input', event => {
    applyPlayerMotionMacro(event.target.value);
  });
}
if (playerUI.reactivity) {
  playerUI.reactivity.addEventListener('input', event => {
    applyPlayerReactivityMacro(event.target.value);
  });
}
if (playerUI.progress) {
  playerUI.progress.addEventListener('input', event => {
    const target = Number(event.target.value);
    if (!audioState.currentBuffer || audioState.usingMic || audioState.youtubeActive) return;
    audioState.pausedAt = Math.max(0, Math.min(target, audioState.trackDuration || target));
    if (audioState.playing) {
      resumePausedTrack();
    }
    updatePlayerProgressDisplay();
  });
}
if (playerUI.studioToggle) {
  playerUI.studioToggle.addEventListener('click', () => {
    setEditingMode(!experienceState.editingMode);
  });
}
if (playerUI.sourceCycle) {
  playerUI.sourceCycle.addEventListener('click', () => {
    if (audioState.usingMic) {
      stopAudioFromUser();
      setAudioStatus('Mikrofon pausiert', 'idle');
    } else if (isMicSupported()) {
      startMicrophone();
    } else {
      setPanelVisible(true);
      setAudioPanelVisible(true);
    }
  });
}

if (playerUI.queue) {
  playerUI.queue.addEventListener('click', () => {
    setQueueOpen(true);
  });
}

if (audioUI.repeatBtn) {
  audioUI.repeatBtn.addEventListener('click', () => {
    cycleRepeatMode();
  });
}

if (audioUI.micStartBtn) {
  audioUI.micStartBtn.addEventListener('click', () => {
    startMicrophone();
  });
}

if (audioUI.micStopBtn) {
  audioUI.micStopBtn.addEventListener('click', () => {
    stopAudioFromUser();
  });
}

if (youtubeUI.loadBtn) {
  youtubeUI.loadBtn.addEventListener('click', () => {
    loadYouTubePlaylistFromInput();
  });
}

if (youtubeUI.playBtn) {
  youtubeUI.playBtn.addEventListener('click', () => {
    const alreadyYoutube = audioState.currentTrack && audioState.currentTrack.source === 'youtube';
    const focused = alreadyYoutube ? true : focusYoutubeTrack('first');
    if (!focused) {
      setYouTubeStatus('Keine YouTube-Titel in der Playlist.', 'error');
      return;
    }
    prepareExperienceForPlayback();
    playCurrentTrack();
    setQueueOpen(false);
    setYouTubeStatus('YouTube-Track aus Playlist gestartet.', 'info');
  });
}

if (youtubeUI.pauseBtn) {
  youtubeUI.pauseBtn.addEventListener('click', () => {
    if (audioState.youtubeActive) {
      stopAudioPlayback({ stopYouTube: true });
      setAudioStatus('YouTube pausiert.', 'idle');
      refreshAudioUI();
      return;
    }
    setYouTubeStatus('Kein YouTube-Track aktiv.', 'error');
  });
}

if (youtubeUI.prevBtn) {
  youtubeUI.prevBtn.addEventListener('click', () => {
    if (focusYoutubeTrack('prev')) {
      playCurrentTrack();
      setYouTubeStatus('Vorheriger YouTube-Titel gestartet.', 'info');
      return;
    }
    setYouTubeStatus('Keine vorherigen YouTube-Titel gefunden.', 'error');
  });
}

if (youtubeUI.nextBtn) {
  youtubeUI.nextBtn.addEventListener('click', () => {
    if (focusYoutubeTrack('next')) {
      playCurrentTrack();
      setYouTubeStatus('N√§chster YouTube-Titel gestartet.', 'info');
      return;
    }
    setYouTubeStatus('Keine weiteren YouTube-Titel gefunden.', 'error');
  });
}

if (audioUI.fileMeta || audioUI.playlistMeta) {
  updateAudioFileMeta(audioState.currentTrack);
}
setAudioStatus('Audio-Reaktivit√§t inaktiv', 'idle');
refreshAudioUI();
refreshPlayerTransportUI();
updatePlayerProgressDisplay();
renderQueueList();
setQueueOpen(false);
setPlayerChipState(playerUI.styles, 'nebula');
setPlayerChipState(playerUI.moods, 'auto');
presetPlaylistPromise = ensurePresetPlaylistInitialized();

function isMobileSheetActive() {
  return mobileSheetQuery.matches;
}

function getSheetCompactOffset() {
  return Math.max(0, sheetState.expandedHeight - sheetState.compactHeight);
}

function setAudioPanelVisible(show) {
  audioPanelVisible = !!show;
  if (audioUI.panel) {
    audioUI.panel.classList.toggle('is-hidden', !audioPanelVisible);
    audioUI.panel.setAttribute('aria-hidden', audioPanelVisible ? 'false' : 'true');
  }
}

function updateSheetHandleAria() {
  if (!sheetHandleBtn) return;
  if (!isMobileSheetActive()) {
    sheetHandleBtn.setAttribute('tabindex', '-1');
    sheetHandleBtn.setAttribute('aria-expanded', 'false');
    sheetHandleBtn.setAttribute('aria-hidden', 'true');
    sheetHandleBtn.style.pointerEvents = 'none';
    const label = 'Panel vergr√∂√üern';
    sheetHandleBtn.setAttribute('aria-label', label);
    const labelSpan = sheetHandleBtn.querySelector('.sheet-handle-label');
    if (labelSpan) labelSpan.textContent = label;
    return;
  }
  sheetHandleBtn.style.pointerEvents = '';
  sheetHandleBtn.removeAttribute('aria-hidden');
  sheetHandleBtn.setAttribute('tabindex', '0');
  const expanded = panelVisible && sheetState.mode === 'expanded';
  const label = expanded ? 'Panel verkleinern' : 'Panel vergr√∂√üern';
  sheetHandleBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  sheetHandleBtn.setAttribute('aria-label', label);
  const labelSpan = sheetHandleBtn.querySelector('.sheet-handle-label');
  if (labelSpan) labelSpan.textContent = label;
}

function applySheetOffset() {
  if (!isMobileSheetActive()) {
    panel.style.removeProperty('--sheet-offset');
    sheetState.lastOffset = 0;
    return;
  }
  const compactOffset = getSheetCompactOffset();
  let offset = sheetState.mode === 'expanded' ? 0 : compactOffset;
  if (!panelVisible) {
    offset = compactOffset;
  }
  sheetState.lastOffset = offset;
  panel.style.setProperty('--sheet-offset', `${Math.max(0, Math.round(offset))}px`);
}

function setSheetMode(mode, options = {}) {
  const next = mode === 'expanded' ? 'expanded' : 'compact';
  if (sheetState.mode === next && !options.force) return;
  sheetState.mode = next;
  panel.dataset.sheetState = next;
  applySheetOffset();
  updateSheetHandleAria();
}

function recalculateSheetMetrics() {
  if (!isMobileSheetActive()) {
    sheetState.expandedHeight = 0;
    sheetState.compactHeight = 0;
    panel.style.removeProperty('--sheet-expanded-height');
    panel.style.removeProperty('--sheet-compact-height');
    panel.removeAttribute('data-sheet-state');
    applySheetOffset();
    updateSheetHandleAria();
    return;
  }
  const vh = Math.max(window.innerHeight || 0, 0);
  const minSceneHeight = Math.max(0, Math.round(vh * 0.5));
  const allowed = Math.max(0, vh - minSceneHeight);
  const baseCompact = Math.max(0, Math.round(vh * 0.3));
  let compact = Math.max(baseCompact, 140);
  if (allowed > 0) {
    compact = Math.min(compact, allowed);
  }
  if (allowed < 140) {
    compact = allowed;
  }
  compact = Math.max(0, compact);
  sheetState.compactHeight = Math.round(compact);
  const maxAvailable = Math.max(sheetState.compactHeight, Math.max(0, Math.round(vh - 56)));
  const proposedExpanded = Math.max(sheetState.compactHeight + 80, Math.round(vh * 0.88));
  sheetState.expandedHeight = Math.min(Math.max(proposedExpanded, sheetState.compactHeight), maxAvailable);
  panel.style.setProperty('--sheet-expanded-height', `${sheetState.expandedHeight}px`);
  panel.style.setProperty('--sheet-compact-height', `${sheetState.compactHeight}px`);
  if (sheetState.mode !== 'expanded') {
    sheetState.mode = 'compact';
  } else if (sheetState.expandedHeight <= sheetState.compactHeight) {
    sheetState.mode = 'compact';
  }
  applySheetOffset();
  updateSheetHandleAria();
}

function handleMobileMediaChange() {
  sheetState.pointerId = null;
  sheetState.moved = false;
  sheetState.preventClick = false;
  panel.classList.remove('is-dragging');
  if (!isMobileSheetActive()) {
    sheetState.mode = 'compact';
    panel.removeAttribute('data-sheet-state');
  } else if (panelVisible) {
    setSheetMode('compact', { force: true });
  }
  recalculateSheetMetrics();
}

function setPanelVisible(show) {
  panelVisible = !!show && experienceState.editingMode;
  if (!panel) {
    setAudioPanelVisible(panelVisible);
    return;
  }
  panel.classList.toggle('is-hidden', !panelVisible);
  panel.setAttribute('aria-hidden', panelVisible ? 'false' : 'true');
  if (isMobileSheetActive()) {
    if (panelVisible) {
      setSheetMode('compact', { force: true });
    }
    applySheetOffset();
  } else {
    panel.removeAttribute('data-sheet-state');
  }
  setAudioPanelVisible(panelVisible);
  if (!panelVisible) {
    if (sheetState.pointerId !== null && panel.releasePointerCapture) {
      try { panel.releasePointerCapture(sheetState.pointerId); } catch (err) { /* noop */ }
    }
    sheetState.pointerId = null;
    sheetState.moved = false;
    sheetState.preventClick = false;
    panel.classList.remove('is-dragging');
  }
  if (toggleBtn) {
    toggleBtn.textContent = panelVisible ? '‚Üï Panels ausblenden' : '‚Üï Panels einblenden';
    toggleBtn.setAttribute('aria-expanded', panelVisible ? 'true' : 'false');
  }
  updateSheetHandleAria();
}

function updateEditModeButton() {
  if (!editModeBtn) return;
  const active = experienceState.editingMode;
  editModeBtn.setAttribute('aria-pressed', active ? 'true' : 'false');
  editModeBtn.textContent = active ? 'üõ†Ô∏è Bearbeitungsmodus an' : 'üõ†Ô∏è Bearbeitungsmodus aus';
  const label = active
    ? 'Bearbeitungsmodus aktiv ‚Äì Panels bleiben sichtbar.'
    : 'Bearbeitungsmodus deaktiviert.';
  editModeBtn.setAttribute('aria-label', label);
}

function setEditingMode(enabled, { skipStop = false, skipPanelRestore = false } = {}) {
  const next = Boolean(enabled);
  if (experienceState.editingMode === next) {
    updateEditModeButton();
    return;
  }
  experienceState.editingMode = next;
  updateEditModeButton();
  if (playerUI.shell) {
    playerUI.shell.dataset.mode = next ? 'studio' : 'player';
  }
  if (next) {
    experienceState.editingPreviousPanel = panelVisible;
    experienceState.editingPreviousBar = barState.visible;
    setPanelVisible(true);
    showBar({ autoHideDelay: 4200 });
    setAutoRandomEnabled(false);
    if (!skipStop) {
      stopAudioFromUser();
    } else {
      refreshAudioUI();
    }
    resetAudioReactivity();
    applyAudioVisualState();
    restoreInterfaceAfterPlayback();
    updateAudioOverlayVisibility();
  } else {
    const prevBar = experienceState.editingPreviousBar;
    experienceState.editingPreviousPanel = null;
    experienceState.editingPreviousBar = null;
    setPanelVisible(false);
    if (!skipPanelRestore && typeof prevBar === 'boolean') {
      if (prevBar) {
        showBar({ autoHideDelay: 3200 });
      } else {
        hideBar({ immediate: true });
      }
    }
    updateAudioOverlayVisibility();
  }
}

function getDefaultPanelVisibility() {
  return false;
}

function hideInterfaceForPlayback({ remember = true } = {}) {
  if (experienceState.editingMode) {
    experienceState.panelsHiddenForPlayback = false;
    return;
  }
  if (experienceState.panelsHiddenForPlayback) return;
  if (remember) {
    if (experienceState.previousPanelVisible === null) {
      experienceState.previousPanelVisible = panelVisible;
    }
    if (experienceState.previousBarVisible === null) {
      experienceState.previousBarVisible = barState.visible;
    }
  }
  setPanelVisible(false);
  hideBar({ immediate: true });
  experienceState.panelsHiddenForPlayback = true;
}

function restoreInterfaceAfterPlayback() {
  if (!experienceState.panelsHiddenForPlayback) return;
  if (experienceState.editingMode) {
    setPanelVisible(true);
    showBar({ autoHideDelay: 3200 });
    experienceState.panelsHiddenForPlayback = false;
    experienceState.previousPanelVisible = null;
    experienceState.previousBarVisible = null;
    return;
  }
  const desiredPanel = experienceState.previousPanelVisible;
  const shouldShowPanel = (desiredPanel === null) ? getDefaultPanelVisibility() : desiredPanel;
  setPanelVisible(shouldShowPanel);
  const previousBar = experienceState.previousBarVisible;
  if (previousBar) {
    showBar({ autoHideDelay: 3200 });
  } else {
    hideBar({ immediate: true });
  }
  experienceState.panelsHiddenForPlayback = false;
  experienceState.previousPanelVisible = null;
  experienceState.previousBarVisible = null;
}

function notifyPlaybackStarted() {
  if (experienceState.editingMode) {
    setEditingMode(false, { skipStop: true, skipPanelRestore: true });
  }
  const wasStarted = experienceState.started;
  if (!wasStarted && !audioState.usingMic && !autoRandomState.enabled) {
    setAutoRandomEnabled(true);
  }
  hideInterfaceForPlayback({ remember: true });
  experienceState.started = true;
  experienceState.pendingOverlayStart = false;
}

function notifyPlaybackStopped() {
  experienceState.pendingOverlayStart = false;
  restoreInterfaceAfterPlayback();
}

function prepareExperienceForPlayback() {
  if (experienceState.editingMode) {
    setEditingMode(false, { skipStop: true, skipPanelRestore: true });
  }
  if (!experienceState.started && experienceState.previousPanelVisible === null) {
    experienceState.previousPanelVisible = getDefaultPanelVisibility();
    experienceState.previousBarVisible = barState.visible;
  }
  generateRandomBiome({ syncUI: true, repositionCamera: true });
  setAutoRotation(false);
  experienceState.pendingOverlayStart = true;
  hideInterfaceForPlayback({ remember: true });
}

function setCameraLocked(lock) {
  cameraLocked = lock;
  controls.enabled = !lock;
  controls.enablePan = !lock;
  controls.enableZoom = !lock;
  controls.enableRotate = !lock;
  if (lock) {
    controls.target.copy(clusterGroup.position);
  }
  controls.update();
  lockBtn.textContent = lock ? 'üîí Kamera gesperrt' : 'üîì Kamera frei';
  lockBtn.setAttribute('aria-pressed', lock ? 'true' : 'false');
  renderer.domElement.classList.toggle('locked', lock);
}

function startSheetDrag(event) {
  if (!sheetHandleBtn || !isMobileSheetActive() || !panelVisible) return;
  sheetState.pointerId = event.pointerId;
  sheetState.startY = event.clientY;
  sheetState.startOffset = sheetState.mode === 'expanded' ? 0 : getSheetCompactOffset();
  sheetState.lastOffset = sheetState.startOffset;
  sheetState.moved = false;
  sheetState.preventClick = false;
  panel.classList.add('is-dragging');
  if (panel.setPointerCapture) {
    try { panel.setPointerCapture(event.pointerId); } catch (err) { /* noop */ }
  }
}

function handleSheetDragMove(event) {
  if (sheetState.pointerId === null || event.pointerId !== sheetState.pointerId) return;
  const delta = event.clientY - sheetState.startY;
  const maxOffset = getSheetCompactOffset();
  let next = sheetState.startOffset + delta;
  if (!Number.isFinite(next)) next = 0;
  next = Math.max(0, Math.min(maxOffset, next));
  if (Math.abs(delta) > 6) {
    sheetState.moved = true;
  }
  sheetState.lastOffset = next;
  panel.style.setProperty('--sheet-offset', `${Math.max(0, Math.round(next))}px`);
}

function finishSheetDrag(event) {
  if (sheetState.pointerId === null || event.pointerId !== sheetState.pointerId) return;
  if (panel.releasePointerCapture) {
    try { panel.releasePointerCapture(event.pointerId); } catch (err) { /* noop */ }
  }
  panel.classList.remove('is-dragging');
  const moved = sheetState.moved;
  const lastOffset = sheetState.lastOffset;
  sheetState.pointerId = null;
  sheetState.moved = false;
  const maxOffset = getSheetCompactOffset();
  if (moved) {
    const threshold = maxOffset * 0.45;
    const nextState = lastOffset > threshold ? 'compact' : 'expanded';
    setSheetMode(nextState, { force: true });
    sheetState.preventClick = true;
  } else {
    sheetState.preventClick = false;
    applySheetOffset();
  }
}

/* Rotation dynamics */
const autoSpinBtn = $('autoSpin');
const spinStopBtn = $('spinStop');
const spinInertiaBtn = $('spinInertia');
const spinDecaySlider = $('spinDecay');
const spinDecayValue = $('vSpinDecay');
const spinInertiaValue = $('vInertia');
const spinAxisSliders = {
  x: $('spinVelX'),
  y: $('spinVelY'),
  z: $('spinVelZ'),
};
const spinAxisValues = {
  x: $('vSpinX'),
  y: $('vSpinY'),
  z: $('vSpinZ'),
};
const spinSpeedSlider = $('spinSpeed');
const spinSpeedValue = $('vSpinSpeed');
const spinAxisKeys = ['x', 'y', 'z'];

const spinState = {
  autoEnabled: false,
  inertiaEnabled: true,
  inertiaDuration: 12,
  velocity: new THREE.Vector3(),
  velocityComponents: new THREE.Vector3(),
  speedMultiplier: 1,
  isDragging: false,
  activePointerId: null,
  prevPointerTime: 0,
  decayStartSpeed: 0,
  decayTime: 0,
  controlsSnapshot: null,
};

const spinVectors = {
  prev: new THREE.Vector3(),
  curr: new THREE.Vector3(),
  axis: new THREE.Vector3(),
};

const MAX_AUTO_SPIN_SPEED = 20;
const defaultSpinSpeed = 0.2;
const defaultSpinAxis = new THREE.Vector3(0, 1, 0);
const spinApplyAxis = new THREE.Vector3();

function enforceMaxSpinSpeed(updateComponents = true) {
  const speed = spinState.velocity.length();
  if (speed <= MAX_AUTO_SPIN_SPEED) {
    return false;
  }
  spinState.velocity.setLength(MAX_AUTO_SPIN_SPEED);
  if (updateComponents) {
    if (Math.abs(spinState.speedMultiplier) <= 1e-6) {
      spinState.velocityComponents.copy(spinState.velocity);
    } else {
      spinState.velocityComponents.copy(spinState.velocity).divideScalar(spinState.speedMultiplier);
    }
    spinAxisKeys.forEach(axis => {
      const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
      spinState.velocityComponents[axis] = clampToSliderBounds(id, spinState.velocityComponents[axis]);
    });
    spinState.velocity.set(
      spinState.velocityComponents.x * spinState.speedMultiplier,
      spinState.velocityComponents.y * spinState.speedMultiplier,
      spinState.velocityComponents.z * spinState.speedMultiplier,
    );
  }
  return true;
}

function syncSpinSliderUI() {
  spinAxisKeys.forEach(axis => {
    const slider = spinAxisSliders[axis];
    const valueEl = spinAxisValues[axis];
    const component = spinState.velocityComponents[axis];
    const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
    if (slider) {
      applySliderValue(id, component);
    }
    if (valueEl) {
      valueEl.textContent = formatDisplayNumber(component, 2) + ' rad/s';
    }
  });
  if (spinSpeedSlider) {
    applySliderValue('spinSpeed', spinState.speedMultiplier);
  }
  if (spinSpeedValue) {
    spinSpeedValue.textContent = '√ó' + formatDisplayNumber(spinState.speedMultiplier, 2);
  }
}

function updateVelocityFromComponents() {
  spinState.velocity.set(
    spinState.velocityComponents.x * spinState.speedMultiplier,
    spinState.velocityComponents.y * spinState.speedMultiplier,
    spinState.velocityComponents.z * spinState.speedMultiplier,
  );
  enforceMaxSpinSpeed(true);
}

function updateComponentsFromVelocity(syncUI = true) {
  if (Math.abs(spinState.speedMultiplier) <= 1e-6) {
    spinState.velocityComponents.copy(spinState.velocity);
  } else {
    spinState.velocityComponents.copy(spinState.velocity).divideScalar(spinState.speedMultiplier);
  }
  spinAxisKeys.forEach(axis => {
    const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
    spinState.velocityComponents[axis] = clampToSliderBounds(id, spinState.velocityComponents[axis]);
  });
  if (syncUI) {
    syncSpinSliderUI();
  }
}

function setSpinAxisComponent(axis, value) {
  const numeric = parseFloat(value);
  if (Number.isNaN(numeric)) return;
  const id = axis === 'x' ? 'spinVelX' : axis === 'y' ? 'spinVelY' : 'spinVelZ';
  const clamped = clampToSliderBounds(id, numeric);
  spinState.velocityComponents[axis] = clamped;
  updateVelocityFromComponents();
  handleVelocityChange();
}

function setSpinSpeedMultiplier(value) {
  const numeric = parseFloat(value);
  if (Number.isNaN(numeric)) return;
  const clamped = clampToSliderBounds('spinSpeed', numeric);
  spinState.speedMultiplier = clamped;
  updateVelocityFromComponents();
  handleVelocityChange();
}

function handleVelocityChange(updateUI = true) {
  const speed = spinState.velocity.length();
  spinState.decayTime = 0;
  if (spinState.autoEnabled && spinState.inertiaEnabled && speed > 1e-6) {
    spinState.decayStartSpeed = speed;
  } else if (!spinState.autoEnabled || speed <= 1e-6) {
    spinState.decayStartSpeed = 0;
  } else {
    spinState.decayStartSpeed = 0;
  }
  if (updateUI) {
    updateRotationUI();
  }
}

function clearSpinVelocity({ resetMultiplier = false, updateUI = true } = {}) {
  spinState.velocity.set(0, 0, 0);
  spinState.velocityComponents.set(0, 0, 0);
  if (resetMultiplier) {
    spinState.speedMultiplier = 1;
  }
  spinState.decayStartSpeed = 0;
  spinState.decayTime = 0;
  if (updateUI) {
    updateRotationUI();
  } else {
    syncSpinSliderUI();
  }
}

function hasSpinVelocity() {
  return spinState.velocity.lengthSq() > 1e-8;
}

function updateRotationUI() {
  if (!autoSpinBtn) return;
  autoSpinBtn.setAttribute('aria-pressed', spinState.autoEnabled ? 'true' : 'false');
  autoSpinBtn.textContent = spinState.autoEnabled ? 'üåÄ Auto-Rotation an' : 'üåÄ Auto-Rotation aus';
  spinInertiaBtn.setAttribute('aria-pressed', spinState.inertiaEnabled ? 'true' : 'false');
  spinInertiaBtn.textContent = spinState.inertiaEnabled ? 'ü™Å Tr√§gheit an' : 'ü™Å Tr√§gheit aus';
  if (spinDecaySlider) {
    spinDecaySlider.disabled = !spinState.inertiaEnabled;
    applySliderValue('spinDecay', spinState.inertiaDuration);
  }
  if (spinDecayValue) {
    spinDecayValue.textContent = formatDisplayNumber(spinState.inertiaDuration, 0) + ' s';
  }
  if (spinInertiaValue) {
    spinInertiaValue.textContent = spinState.inertiaEnabled ? 'aktiv' : 'aus';
  }
  const velocityActive = spinState.autoEnabled && hasSpinVelocity();
  if (spinStopBtn) {
    spinStopBtn.disabled = !velocityActive;
    spinStopBtn.setAttribute('aria-disabled', velocityActive ? 'false' : 'true');
  }
  syncSpinSliderUI();
}

function stopRotation(updateUI = true) {
  clearSpinVelocity({ updateUI });
}

function setAutoRotation(enabled) {
  if (!enabled) {
    spinState.autoEnabled = false;
    clearSpinVelocity({ resetMultiplier: true, updateUI: false });
    updateRotationUI();
    return;
  }
  spinState.autoEnabled = true;
  if (!hasSpinVelocity()) {
    spinState.velocityComponents.copy(defaultSpinAxis).multiplyScalar(defaultSpinSpeed);
  } else {
    updateComponentsFromVelocity(false);
  }
  updateVelocityFromComponents();
  spinState.decayStartSpeed = spinState.inertiaEnabled ? spinState.velocity.length() : 0;
  spinState.decayTime = 0;
  updateRotationUI();
}

function setInertiaEnabled(enabled) {
  spinState.inertiaEnabled = enabled;
  if (!enabled) {
    spinState.decayStartSpeed = 0;
    spinState.decayTime = 0;
  } else if (hasSpinVelocity() && !spinState.isDragging) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  }
  updateRotationUI();
}

function setInertiaDuration(seconds) {
  let next = Math.round(Number(seconds));
  if (!Number.isFinite(next)) {
    next = spinState.inertiaDuration;
  }
  const clamped = Math.round(clampToSliderBounds('spinDecay', next));
  spinState.inertiaDuration = clamped;
  if (spinState.inertiaEnabled && !spinState.isDragging && hasSpinVelocity()) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  }
  updateRotationUI();
}

function projectOnTrackball(clientX, clientY, target) {
  const rect = renderer.domElement.getBoundingClientRect();
  const x = ((clientX - rect.left) / rect.width) * 2 - 1;
  const y = ((clientY - rect.top) / rect.height) * -2 + 1;
  target.set(x, y, 0);
  const lengthSq = x * x + y * y;
  if (lengthSq <= 1) {
    target.z = Math.sqrt(1 - lengthSq);
  } else {
    target.normalize();
  }
  return target;
}

function onSpinPointerDown(e) {
  if (!spinState.autoEnabled || e.button !== 0) return;
  spinState.isDragging = true;
  spinState.activePointerId = e.pointerId;
  spinState.decayTime = 0;
  spinState.prevPointerTime = performance.now();
  projectOnTrackball(e.clientX, e.clientY, spinVectors.prev);
  spinState.controlsSnapshot = {
    enabled: controls.enabled,
    enableRotate: controls.enableRotate,
  };
  controls.enabled = false;
  controls.enableRotate = false;
  if (renderer.domElement.setPointerCapture) {
    renderer.domElement.setPointerCapture(e.pointerId);
  }
  e.preventDefault();
}

function onSpinPointerMove(e) {
  if (!spinState.isDragging || e.pointerId !== spinState.activePointerId) return;
  projectOnTrackball(e.clientX, e.clientY, spinVectors.curr);
  const dot = THREE.MathUtils.clamp(spinVectors.prev.dot(spinVectors.curr), -1, 1);
  const angle = Math.acos(dot);
  if (angle > 1e-5) {
    spinVectors.axis.crossVectors(spinVectors.prev, spinVectors.curr);
    if (spinVectors.axis.lengthSq() > 1e-6) {
      spinVectors.axis.normalize();
      clusterGroup.rotateOnAxis(spinVectors.axis, angle);
      const now = performance.now();
      const dt = Math.max((now - spinState.prevPointerTime) / 1000, 1e-3);
      spinState.prevPointerTime = now;
      spinState.velocity.copy(spinVectors.axis).multiplyScalar(angle / dt);
      enforceMaxSpinSpeed(true);
      updateComponentsFromVelocity();
    }
  }
  spinVectors.prev.copy(spinVectors.curr);
}

function onSpinPointerUp(e) {
  if (!spinState.isDragging) return;
  if (typeof e.pointerId === 'number' && spinState.activePointerId !== null && e.pointerId !== spinState.activePointerId) {
    return;
  }
  if (renderer.domElement.releasePointerCapture && spinState.activePointerId !== null) {
    try {
      if (!renderer.domElement.hasPointerCapture || renderer.domElement.hasPointerCapture(spinState.activePointerId)) {
        renderer.domElement.releasePointerCapture(spinState.activePointerId);
      }
    } catch (err) {
      // ignore release errors
    }
  }
  spinState.isDragging = false;
  spinState.activePointerId = null;
  if (!spinState.autoEnabled) {
    stopRotation(false);
  } else if (spinState.inertiaEnabled && hasSpinVelocity()) {
    spinState.decayStartSpeed = spinState.velocity.length();
    spinState.decayTime = 0;
  } else {
    spinState.decayStartSpeed = 0;
    spinState.decayTime = 0;
  }
  if (spinState.controlsSnapshot) {
    controls.enabled = spinState.controlsSnapshot.enabled;
    controls.enableRotate = spinState.controlsSnapshot.enableRotate;
    spinState.controlsSnapshot = null;
    controls.update();
  }
  updateRotationUI();
}

renderer.domElement.addEventListener('pointerdown', onSpinPointerDown);
renderer.domElement.addEventListener('pointermove', onSpinPointerMove);
renderer.domElement.addEventListener('pointerup', onSpinPointerUp);
renderer.domElement.addEventListener('pointercancel', onSpinPointerUp);
renderer.domElement.addEventListener('pointerleave', e => {
  if (spinState.isDragging) {
    onSpinPointerUp(e);
  }
});

if (autoSpinBtn) {
  autoSpinBtn.addEventListener('click', () => {
    setAutoRotation(!spinState.autoEnabled);
  });
}
if (spinStopBtn) {
  spinStopBtn.addEventListener('click', () => {
    stopRotation();
  });
}
if (spinInertiaBtn) {
  spinInertiaBtn.addEventListener('click', () => {
    setInertiaEnabled(!spinState.inertiaEnabled);
  });
}
function setCategoryCount(kind, value) {
  const keyMap = { small: 'catSmallCount', medium: 'catMediumCount', large: 'catLargeCount' };
  const key = keyMap[kind];
  if (!key) return;
  const next = Math.max(0, Math.floor(Number(value) || 0));
  if (params[key] === next) {
    return;
  }
  params[key] = next;
  rebuildStars();
}

function getSizeRange(sizeVar = params.sizeVar) {
  const min = Math.max(0.05, 1 - sizeVar * 0.5);
  const max = 1 + sizeVar * 0.5;
  return { min, max, delta: max - min };
}

function clampValue(value, min, max) {
  let next = Number(value);
  if (!Number.isFinite(next)) return next;
  let minVal = Number.isFinite(min) ? min : Number.NEGATIVE_INFINITY;
  let maxVal = Number.isFinite(max) ? max : Number.POSITIVE_INFINITY;
  if (minVal > maxVal) {
    const tmp = minVal;
    minVal = maxVal;
    maxVal = tmp;
  }
  if (Number.isFinite(minVal)) {
    next = Math.max(next, minVal);
  }
  if (Number.isFinite(maxVal)) {
    next = Math.min(next, maxVal);
  }
  return next;
}

function formatDisplayNumber(value, fractionDigits = 2) {
  if (!Number.isFinite(value)) return '';
  return Number.isInteger(value) ? String(value) : value.toFixed(fractionDigits);
}

const sliderBoundSettings = {};
const sliderBoundInputs = {};

function getSliderBounds(id) {
  const slider = $(id);
  const settings = sliderBoundSettings[id];
  let min = settings ? settings.min : undefined;
  let max = settings ? settings.max : undefined;
  if (!Number.isFinite(min) && slider) {
    const rawMin = parseFloat(slider.getAttribute('min'));
    if (Number.isFinite(rawMin)) {
      min = rawMin;
    }
  }
  if (!Number.isFinite(max) && slider) {
    const rawMax = parseFloat(slider.getAttribute('max'));
    if (Number.isFinite(rawMax)) {
      max = rawMax;
    }
  }
  return { min, max };
}

function clampToSliderBounds(id, value) {
  const bounds = getSliderBounds(id);
  return clampValue(value, bounds.min, bounds.max);
}

function syncSliderUI(id) {
  const slider = $(id);
  const settings = sliderBoundSettings[id];
  if (!slider || !settings) return;
  slider.min = String(settings.min);
  slider.max = String(settings.max);
  const pair = sliderBoundInputs[id];
  if (pair && pair.min && document.activeElement !== pair.min) {
    pair.min.value = settings.min;
  }
  if (pair && pair.max && document.activeElement !== pair.max) {
    pair.max.value = settings.max;
  }
}

function handleBoundInputChange(id, kind, inputEl) {
  const settings = sliderBoundSettings[id];
  if (!settings) return;
  let value = parseFloat(inputEl.value);
  if (!Number.isFinite(value)) {
    inputEl.value = settings[kind];
    return;
  }
  if (kind === 'min') {
    settings.min = value;
    if (value > settings.max) {
      settings.max = value;
      const partner = sliderBoundInputs[id] && sliderBoundInputs[id].max;
      if (partner) {
        partner.value = settings.max;
      }
    }
  } else {
    settings.max = value;
    if (value < settings.min) {
      settings.min = value;
      const partner = sliderBoundInputs[id] && sliderBoundInputs[id].min;
      if (partner) {
        partner.value = settings.min;
      }
    }
  }
  inputEl.value = settings[kind];
  syncSliderUI(id);
  const getter = sliderValueGetters[id];
  const handler = sliderHandlers[id];
  if (getter && handler) {
    const current = getter();
    if (Number.isFinite(current)) {
      const clamped = clampValue(current, settings.min, settings.max);
      if (clamped !== current) {
        handler(String(clamped));
      }
    }
  }
  setSliders();
}

function registerSliderBounds(id) {
  const slider = $(id);
  if (!slider) return;
  let min = parseFloat(slider.getAttribute('min'));
  let max = parseFloat(slider.getAttribute('max'));
  if (!Number.isFinite(min) && Number.isFinite(max)) {
    min = max < 0 ? max : 0;
  }
  if (!Number.isFinite(max) && Number.isFinite(min)) {
    max = min > 0 ? min : 1;
  }
  if (!Number.isFinite(min)) min = 0;
  if (!Number.isFinite(max)) max = min;
  if (min > max) {
    const tmp = min;
    min = max;
    max = tmp;
  }
  sliderBoundSettings[id] = { min, max };
  const wrap = slider.closest('.wrap');
  const labelElement = document.querySelector(`label[for="${id}"]`);
  let descriptor = '';
  if (labelElement && labelElement.textContent) {
    descriptor = labelElement.textContent.replace(/\s+/g, ' ').trim();
  } else if (wrap) {
    const tag = wrap.querySelector('.tag');
    if (tag && tag.textContent) {
      descriptor = tag.textContent.replace(/\s+/g, ' ').trim();
    }
  }
  const minLabel = descriptor ? `${descriptor} ‚Äì Minimum` : 'Minimum';
  const maxLabel = descriptor ? `${descriptor} ‚Äì Maximum` : 'Maximum';
  if (wrap) {
    const minInput = wrap.querySelector(`input[data-target="${id}"][data-bound="min"]`);
    const maxInput = wrap.querySelector(`input[data-target="${id}"][data-bound="max"]`);
    sliderBoundInputs[id] = sliderBoundInputs[id] || {};
    const step = slider.step && slider.step.length ? slider.step : 'any';
    const numericStep = Number(step);
    const hasNumericStep = Number.isFinite(numericStep) && step !== 'any';
    const isIntegerStep = hasNumericStep && Number.isInteger(numericStep);
    const inputMode = isIntegerStep ? 'numeric' : 'decimal';
    if (minInput) {
      sliderBoundInputs[id].min = minInput;
      minInput.value = min;
      minInput.step = step;
      minInput.inputMode = inputMode;
      minInput.setAttribute('aria-label', minLabel);
      minInput.title = minLabel;
      minInput.addEventListener('change', event => handleBoundInputChange(id, 'min', event.target));
    }
    if (maxInput) {
      sliderBoundInputs[id].max = maxInput;
      maxInput.value = max;
      maxInput.step = step;
      maxInput.inputMode = inputMode;
      maxInput.setAttribute('aria-label', maxLabel);
      maxInput.title = maxLabel;
      maxInput.addEventListener('change', event => handleBoundInputChange(id, 'max', event.target));
    }
  }
  syncSliderUI(id);
}

function initializeSliderBounds() {
  for (const id in sliderValueGetters) {
    registerSliderBounds(id);
  }
}

function applySliderValue(id, value) {
  const slider = $(id);
  if (!slider) return value;
  const bounds = getSliderBounds(id);
  const clamped = Number.isFinite(value) ? clampValue(value, bounds.min, bounds.max) : value;
  slider.value = Number.isFinite(clamped) ? clamped : slider.value;
  return Number.isFinite(clamped) ? clamped : value;
}

function enforceBounds() {
  let changed = false;
  for (const id in sliderValueGetters) {
    const getter = sliderValueGetters[id];
    const handler = sliderHandlers[id];
    const settings = sliderBoundSettings[id];
    if (!getter || !handler || !settings) continue;
    const current = getter();
    if (!Number.isFinite(current)) continue;
    const clamped = clampValue(current, settings.min, settings.max);
    if (clamped !== current) {
      handler(String(clamped));
      changed = true;
    }
  }
  return changed;
}

const sliderHandlers = {
  pCount:       val => {
    params.count = clampTotalCount(val);
    rebuildStars();
  },
  pRadius:      val => { params.radius = parseFloat(val); rebuildStars(); },
  pSizeVar:     val => { params.sizeVar = parseFloat(val); rebuildStars(); },
  pCluster:     val => { params.cluster = parseFloat(val); rebuildStars(); },
  pPointAlpha:  val => { params.pointAlpha = parseFloat(val); updateStarUniforms(); },
  pHue:         val => { params.pointHue = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pSaturation:  val => { params.pointSaturation = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pValue:       val => { params.pointValue = parseFloat(val); updatePointColor(); updateStarUniforms(); updateTinyMaterial(); },
  pColorIntensity: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.colorIntensity = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pColorSpeed: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.colorSpeed = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pHueSpread: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.hueSpread = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pColorPropagationDistance: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.colorPropagationDistance = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pColorPropagationDuration: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.colorPropagationDuration = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pColorToneCount: val => {
    const numeric = parseFloat(val);
    if (!Number.isNaN(numeric)) {
      params.colorToneCount = Math.max(1, Math.round(numeric));
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pSeedStars:   val => { params.seedStars = parseInt(val, 10); rebuildStars(); },
  pCatSmallCount:  val => { setCategoryCount('small', val); },
  pCatMediumCount: val => { setCategoryCount('medium', val); },
  pCatLargeCount:  val => { setCategoryCount('large', val); },
  pSizeTiny:    val => { params.sizeFactorTiny = parseFloat(val); updateTinyMaterial(); },
  pSizeSmall:   val => { params.sizeFactorSmall = parseFloat(val); updateStarUniforms(); },
  pSizeMedium:  val => { params.sizeFactorMedium = parseFloat(val); updateStarUniforms(); },
  pSizeLarge:   val => { params.sizeFactorLarge = parseFloat(val); updateStarUniforms(); },
  pTinyCount:   val => { params.tinyCount = parseInt(val, 10); rebuildTiny(); },
  pConnPercent: val => { params.connPercent = parseFloat(val); rebuildTiny(); },
  pTinyAlpha:   val => { params.tinyAlpha = parseFloat(val); updateTinyMaterial(); },
  pSeedTiny:    val => { params.seedTiny = parseInt(val, 10); rebuildTiny(); },
  pEdgeSoft:    val => { params.edgeSoftness = parseFloat(val); updateStarUniforms(); },
  pMotionSpeed: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionSpeed = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionAmplitude: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionAmplitude = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionNoiseStrength: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionNoiseStrength = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  pMotionNoiseScale: val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      params.motionNoiseScale = next;
      updateStarUniforms();
      updateTinyMaterial();
    }
  },
  spinVelX:     val => { setSpinAxisComponent('x', val); },
  spinVelY:     val => { setSpinAxisComponent('y', val); },
  spinVelZ:     val => { setSpinAxisComponent('z', val); },
  spinSpeed:    val => { setSpinSpeedMultiplier(val); },
  spinDecay:    val => {
    const next = parseFloat(val);
    if (!Number.isNaN(next)) {
      setInertiaDuration(next);
    }
  },
};

const sliderValueGetters = {
  pRadius: () => params.radius,
  pSizeVar: () => params.sizeVar,
  pCluster: () => params.cluster,
  pPointAlpha: () => params.pointAlpha,
  pHue: () => params.pointHue,
  pSaturation: () => params.pointSaturation,
  pValue: () => params.pointValue,
  pColorIntensity: () => params.colorIntensity,
  pColorSpeed: () => params.colorSpeed,
  pHueSpread: () => params.hueSpread,
  pColorPropagationDistance: () => params.colorPropagationDistance,
  pColorPropagationDuration: () => params.colorPropagationDuration,
  pColorToneCount: () => params.colorToneCount,
  pSeedStars: () => params.seedStars,
  pSizeTiny: () => params.sizeFactorTiny,
  pSizeSmall: () => params.sizeFactorSmall,
  pSizeMedium: () => params.sizeFactorMedium,
  pSizeLarge: () => params.sizeFactorLarge,
  pTinyCount: () => params.tinyCount,
  pConnPercent: () => params.connPercent,
  pTinyAlpha: () => params.tinyAlpha,
  pSeedTiny: () => params.seedTiny,
  pEdgeSoft: () => params.edgeSoftness,
  pMotionSpeed: () => params.motionSpeed,
  pMotionAmplitude: () => params.motionAmplitude,
  pMotionNoiseStrength: () => params.motionNoiseStrength,
  pMotionNoiseScale: () => params.motionNoiseScale,
  spinVelX: () => spinState.velocityComponents.x,
  spinVelY: () => spinState.velocityComponents.y,
  spinVelZ: () => spinState.velocityComponents.z,
  spinSpeed: () => spinState.speedMultiplier,
  spinDecay: () => spinState.inertiaDuration,
};

const colorPickerInput = $('pHueColor');
const colorSwatchButtons = Array.from(document.querySelectorAll('[data-color-swatch]'));

function updateColorPickerInput() {
  if (!colorPickerInput) return;
  const hex = hsvToHex(params.pointHue, params.pointSaturation, params.pointValue);
  if (hex && colorPickerInput.value.toLowerCase() !== hex) {
    colorPickerInput.value = hex;
  }
}

function updateColorSwatchState() {
  if (!colorSwatchButtons.length) return;
  const hue = normalizeHue(params.pointHue);
  const saturation = clamp01(params.pointSaturation);
  const value = clamp01(params.pointValue);
  colorSwatchButtons.forEach(button => {
    const btnHue = normalizeHue(parseFloat(button.dataset.h));
    const btnSat = clamp01(parseFloat(button.dataset.s));
    const btnVal = clamp01(parseFloat(button.dataset.v));
    const isMatch = hueDifference(hue, btnHue) < 6 &&
      Math.abs(saturation - btnSat) < 0.08 &&
      Math.abs(value - btnVal) < 0.08;
    button.setAttribute('aria-pressed', String(isMatch));
  });
}

function applyBaseColorFromHSV(h, s, v, forceUniform = false) {
  params.pointHue = normalizeHue(h);
  params.pointSaturation = clamp01(s);
  params.pointValue = clamp01(v);
  if (forceUniform && params.colorMode !== 'uniform') {
    params.colorMode = 'uniform';
  }
  updatePointColor();
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
}

if (colorPickerInput) {
  const initialHex = hsvToHex(params.pointHue, params.pointSaturation, params.pointValue);
  if (initialHex) {
    colorPickerInput.value = initialHex;
  }
  colorPickerInput.addEventListener('input', event => {
    const hsv = hexToHsv(event.target.value);
    if (!hsv) return;
    applyBaseColorFromHSV(hsv.h, hsv.s, hsv.v, true);
  });
}

if (colorSwatchButtons.length) {
  colorSwatchButtons.forEach(button => {
    button.addEventListener('click', () => {
      const h = parseFloat(button.dataset.h);
      const s = parseFloat(button.dataset.s);
      const v = parseFloat(button.dataset.v);
      if ([h, s, v].some(val => Number.isNaN(val))) return;
      applyBaseColorFromHSV(h, s, v, true);
    });
  });
}

initializeSliderBounds();
enforceBounds();
// assign input event handlers
for (const id in sliderHandlers) {
  const element = $(id);
  if (!element) continue;
  element.addEventListener('input', e => {
    sliderHandlers[id](e.target.value);
    setSliders();
  });
}
// Blending select
$('pBlending').addEventListener('change', e => {
  params.blending = e.target.value;
  updateStarUniforms();
  updateTinyMaterial();
});
$('pDistribution').addEventListener('change', e => {
  const value = e.target.value;
  if (value === 'stl') {
    const applied = useStlAsDistribution({ rememberPrevious: true });
    if (!applied) {
      stlState.displayMode = 'overlay';
      updateStlOptionAvailability();
      const fallback = stlState.previousDistribution && stlState.previousDistribution !== 'stl'
        ? stlState.previousDistribution
        : 'random';
      params.distribution = fallback;
      e.target.value = fallback;
      setSliders();
      updateStlMeta(stlState.files);
      updateStlVisibility();
      return;
    }
    rebuildStars();
    setSliders();
    updateStlVisibility();
    updateStlMeta(stlState.files);
    return;
  }
  if (params.distribution === 'stl') {
    revertFromStlDistribution({ fallback: value });
    stlState.displayMode = 'overlay';
  }
  params.distribution = value;
  rebuildStars();
  setSliders();
  updateStlVisibility();
  updateStlMeta(stlState.files);
});
$('pColorMode').addEventListener('change', e => {
  params.colorMode = e.target.value;
  updateStarUniforms();
  updateTinyMaterial();
});
$('pMotionMode').addEventListener('change', e => {
  params.motionMode = e.target.value;
  updateStarUniforms();
  updateTinyMaterial();
  setSliders();
});
// Filled checkbox
$('pFilled').addEventListener('change', e => {
  params.filled = e.target.checked;
  updateStarUniforms();
});

/* Accordion controls */
const accordionTriggers = Array.from(document.querySelectorAll('.accordion__trigger'));

function setAccordionState(trigger, expanded) {
  const panelId = trigger.getAttribute('aria-controls');
  const panel = panelId ? document.getElementById(panelId) : null;
  if (!panel) return;
  trigger.setAttribute('aria-expanded', String(expanded));
  panel.hidden = !expanded;
  trigger.classList.toggle('is-open', expanded);
  panel.classList.toggle('is-open', expanded);
}

accordionTriggers.forEach(trigger => {
  const initial = trigger.getAttribute('aria-expanded') === 'true';
  setAccordionState(trigger, initial);
  trigger.addEventListener('click', () => {
    const next = trigger.getAttribute('aria-expanded') !== 'true';
    setAccordionState(trigger, next);
  });
});

/* Toggle panel, lock camera & random button */
toggleBtn.addEventListener('click', () => {
  setPanelVisible(!panelVisible);
});
if (editModeBtn) {
  editModeBtn.addEventListener('click', () => {
    setEditingMode(!experienceState.editingMode);
  });
}

if (sheetHandleBtn) {
  sheetHandleBtn.addEventListener('pointerdown', event => {
    if (!isMobileSheetActive()) return;
    startSheetDrag(event);
  });
  sheetHandleBtn.addEventListener('click', event => {
    if (!isMobileSheetActive()) return;
    if (sheetState.preventClick) {
      sheetState.preventClick = false;
      event.preventDefault();
      return;
    }
    const next = sheetState.mode === 'expanded' ? 'compact' : 'expanded';
    setSheetMode(next, { force: true });
  });
}

panel.addEventListener('pointermove', handleSheetDragMove);
panel.addEventListener('pointerup', finishSheetDrag);
panel.addEventListener('pointercancel', finishSheetDrag);

if (mobileSheetQuery.addEventListener) {
  mobileSheetQuery.addEventListener('change', handleMobileMediaChange);
} else if (mobileSheetQuery.addListener) {
  mobileSheetQuery.addListener(handleMobileMediaChange);
}

lockBtn.addEventListener('click', () => {
  setCameraLocked(!cameraLocked);
});

function randomizeParameters({ syncUI = true } = {}) {
  const totalCount = 500 + Math.floor(Math.random() * 7500);
  params.count = clampTotalCount(totalCount);
  params.radius = 60 + Math.random() * 180;
  params.sizeVar = Math.random() * 9.5;
  params.cluster = Math.random() * 0.95;
  params.pointAlpha = 0.3 + Math.random() * 0.7;
  params.pointHue = Math.random() * 360;
  params.pointSaturation = Math.random();
  params.pointValue = 0.3 + Math.random() * 0.7;
  params.seedStars = 1 + Math.floor(Math.random() * 9999);
  const distributions = getAvailableDistributions();
  params.distribution = distributions[Math.floor(Math.random() * distributions.length)] || 'random';
  params.colorMode = COLOR_MODES[Math.floor(Math.random() * COLOR_MODES.length)];
  params.colorIntensity = Math.random();
  params.colorSpeed = Math.random() * 4.5;
  params.hueSpread = Math.random() * 180;
  params.colorPropagationDistance = 40 + Math.random() * 260;
  params.colorPropagationDuration = 0.5 + Math.random() * 9.5;
  params.colorToneCount = 1 + Math.floor(Math.random() * 6);
  const weights = [Math.random(), Math.random(), Math.random()];
  const weightSum = weights.reduce((sum, value) => sum + value, 0) || 1;
  const provisional = weights.map(value => Math.max(0, Math.floor((value / weightSum) * totalCount)));
  let assigned = provisional.reduce((sum, value) => sum + value, 0);
  let diff = totalCount - assigned;
  let idx = 0;
  const adjustOrder = [0, 1, 2];
  while (diff > 0 && idx < 300) {
    const target = adjustOrder[idx % adjustOrder.length];
    provisional[target] += 1;
    diff -= 1;
    idx += 1;
  }
  params.catSmallCount = provisional[0];
  params.catMediumCount = provisional[1];
  params.catLargeCount = Math.max(0, totalCount - params.catSmallCount - params.catMediumCount);
  params.sizeFactorSmall = 0.5 + Math.random() * 2.5;
  params.sizeFactorMedium = 0.5 + Math.random() * 2.5;
  params.sizeFactorLarge = 0.5 + Math.random() * 2.5;
  params.sizeFactorTiny = 0.05 + Math.random() * 0.6;
  params.tinyCount = Math.floor(Math.random() * 5000);
  params.connPercent = Math.random();
  params.tinyAlpha = Math.random();
  params.seedTiny = 1 + Math.floor(Math.random() * 9999);
  params.edgeSoftness = Math.random();
  params.blending = (Math.random() < 0.5) ? 'Normal' : 'Additive';
  params.filled = Math.random() < 0.3;
  params.motionMode = MOTION_MODES[Math.floor(Math.random() * MOTION_MODES.length)];
  params.motionSpeed = Math.random() * 2.5;
  params.motionAmplitude = Math.random() * 30;
  params.motionNoiseStrength = Math.random() * 2.0;
  params.motionNoiseScale = 0.1 + Math.random() * 3.5;
  enforceBounds();
  updatePointColor();
  rebuildStars();
  if (syncUI) {
    setSliders();
  }
}

$('random').addEventListener('click', () => {
  randomizeParameters({ syncUI: true });
});

/* Update slider displays */
function setSliders() {
  // star params
  params.count = clampTotalCount(params.count);
  params.colorToneCount = Math.max(1, Math.round(Number(params.colorToneCount) || 1));
  if ($('pCount')) {
    $('pCount').value = params.count;
  }
  $('vCount').textContent = params.count;
  const radiusValue = applySliderValue('pRadius', params.radius);
  $('vRadius').textContent = formatDisplayNumber(radiusValue, 2);
  $('pDistribution').value = params.distribution;
  const sizeVarValue = applySliderValue('pSizeVar', params.sizeVar);
  const sizeRange = getSizeRange(sizeVarValue);
  $('vSizeVar').textContent = sizeRange.delta.toFixed(2);
  const clusterValue = applySliderValue('pCluster', params.cluster);
  $('vCluster').textContent = formatDisplayNumber(clusterValue, 2);
  const alphaValue = applySliderValue('pPointAlpha', params.pointAlpha);
  $('vPointAlpha').textContent = alphaValue.toFixed(2);
  const hueValue = applySliderValue('pHue', params.pointHue);
  $('vHue').textContent = formatDisplayNumber(hueValue, 1) + '¬∞';
  const saturationValue = applySliderValue('pSaturation', params.pointSaturation);
  $('vSaturation').textContent = (saturationValue * 100).toFixed(0) + '%';
  const valueValue = applySliderValue('pValue', params.pointValue);
  $('vValue').textContent = (valueValue * 100).toFixed(0) + '%';
  updateColorPickerInput();
  updateColorSwatchState();
  $('pColorMode').value = params.colorMode;
  const colorIntensityValue = applySliderValue('pColorIntensity', params.colorIntensity);
  $('vColorIntensity').textContent = (colorIntensityValue * 100).toFixed(0) + '%';
  const colorSpeedValue = applySliderValue('pColorSpeed', params.colorSpeed);
  $('vColorSpeed').textContent = colorSpeedValue.toFixed(2) + '√ó';
  const hueSpreadValue = applySliderValue('pHueSpread', params.hueSpread);
  $('vHueSpread').textContent = formatDisplayNumber(hueSpreadValue, 1) + '¬∞';
  const colorPropagationDistanceValue = applySliderValue('pColorPropagationDistance', params.colorPropagationDistance);
  $('vColorPropagationDistance').textContent = formatDisplayNumber(colorPropagationDistanceValue, 1) + ' Einheiten';
  const colorPropagationDurationValue = applySliderValue('pColorPropagationDuration', params.colorPropagationDuration);
  $('vColorPropagationDuration').textContent = colorPropagationDurationValue.toFixed(1) + ' s';
  const colorToneCountValue = applySliderValue('pColorToneCount', params.colorToneCount);
  $('vColorToneCount').textContent = formatDisplayNumber(colorToneCountValue, 0) + ' T√∂ne';
  $('pColorMode').value = params.colorMode;
  const seedStarsValue = applySliderValue('pSeedStars', params.seedStars);
  $('vSeedStars').textContent = formatDisplayNumber(seedStarsValue);
  $('pCatSmallCount').value = params.catSmallCount; $('vCatSmallCount').textContent = params.catSmallCount;
  $('pCatMediumCount').value = params.catMediumCount; $('vCatMediumCount').textContent = params.catMediumCount;
  $('pCatLargeCount').value = params.catLargeCount; $('vCatLargeCount').textContent = params.catLargeCount;
  // size factors
  const sizeTinyValue = applySliderValue('pSizeTiny', params.sizeFactorTiny);
  $('vSizeTiny').textContent = sizeTinyValue.toFixed(2);
  const sizeSmallValue = applySliderValue('pSizeSmall', params.sizeFactorSmall);
  $('vSizeSmall').textContent = sizeSmallValue.toFixed(2);
  const sizeMediumValue = applySliderValue('pSizeMedium', params.sizeFactorMedium);
  $('vSizeMedium').textContent = sizeMediumValue.toFixed(2);
  const sizeLargeValue = applySliderValue('pSizeLarge', params.sizeFactorLarge);
  $('vSizeLarge').textContent = sizeLargeValue.toFixed(2);
  // tiny / connection
  const tinyCountValue = applySliderValue('pTinyCount', params.tinyCount);
  $('vTinyCount').textContent = formatDisplayNumber(tinyCountValue);
  const connPercentValue = applySliderValue('pConnPercent', params.connPercent);
  $('vConnPercent').textContent = (connPercentValue * 100).toFixed(0) + '%';
  const tinyAlphaValue = applySliderValue('pTinyAlpha', params.tinyAlpha);
  $('vTinyAlpha').textContent = tinyAlphaValue.toFixed(2);
  const seedTinyValue = applySliderValue('pSeedTiny', params.seedTiny);
  $('vSeedTiny').textContent = formatDisplayNumber(seedTinyValue);
  // motion
  $('pMotionMode').value = params.motionMode;
  const motionSpeedValue = applySliderValue('pMotionSpeed', params.motionSpeed);
  $('vMotionSpeed').textContent = motionSpeedValue.toFixed(2) + '√ó';
  const motionAmplitudeValue = applySliderValue('pMotionAmplitude', params.motionAmplitude);
  $('vMotionAmplitude').textContent = formatDisplayNumber(motionAmplitudeValue, 1);
  const motionNoiseStrengthValue = applySliderValue('pMotionNoiseStrength', params.motionNoiseStrength);
  $('vMotionNoiseStrength').textContent = motionNoiseStrengthValue.toFixed(2);
  const motionNoiseScaleValue = applySliderValue('pMotionNoiseScale', params.motionNoiseScale);
  $('vMotionNoiseScale').textContent = motionNoiseScaleValue.toFixed(2);
  // edge & blending
  const edgeSoftValue = applySliderValue('pEdgeSoft', params.edgeSoftness);
  $('vEdgeSoft').textContent = edgeSoftValue.toFixed(2);
  $('pBlending').value = params.blending;
  $('pFilled').checked = params.filled;
  updateRotationUI();
}

/* Resize handler */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  recalculateSheetMetrics();
  if (isMobileSheetActive()) {
    applySheetOffset();
  }
});

window.addEventListener('orientationchange', () => {
  setTimeout(() => {
    recalculateSheetMetrics();
    if (isMobileSheetActive()) {
      applySheetOffset();
    }
  }, 120);
});

/* Animation loop */
let lastFrameTime = performance.now();

function animate(now) {
  requestAnimationFrame(animate);
  const current = (typeof now === 'number') ? now : performance.now();
  const delta = Math.min(Math.max((current - lastFrameTime) / 1000, 0), 0.25);
  lastFrameTime = current;

  motionState.time += delta;
  if (motionState.time > 1e6) {
    motionState.time = 0;
  }
  if (starMaterial && starMaterial.uniforms && starMaterial.uniforms.uTime) {
    starMaterial.uniforms.uTime.value = motionState.time;
  }
  if (stlMaterial && stlMaterial.uniforms && stlMaterial.uniforms.uTime) {
    stlMaterial.uniforms.uTime.value = motionState.time;
  }
  if (tinyMaterial && tinyMaterial.uniforms && tinyMaterial.uniforms.uTime) {
    tinyMaterial.uniforms.uTime.value = motionState.time;
  }

  if (spinState.autoEnabled && !spinState.isDragging) {
    updateVelocityFromComponents();
    if (spinState.inertiaEnabled && spinState.decayStartSpeed > 0 && hasSpinVelocity()) {
      spinState.decayTime += delta;
      const duration = Math.max(spinState.inertiaDuration, 0.001);
      const progress = Math.min(spinState.decayTime / duration, 1);
      const newSpeed = spinState.decayStartSpeed * (1 - progress);
      if (newSpeed <= 1e-4) {
        stopRotation(false);
        updateRotationUI();
      } else {
        spinState.velocity.setLength(newSpeed);
        updateComponentsFromVelocity();
      }
    }
    const speed = spinState.velocity.length();
    if (speed > 1e-6) {
      spinApplyAxis.copy(spinState.velocity).normalize();
      clusterGroup.rotateOnAxis(spinApplyAxis, speed * delta);
    }
  }

  updateAudioReactive(delta);
  updateAutoRandom(delta);
  applyAudioVisuals(delta, true);
  updatePlayerProgressDisplay();

  if (cameraLocked) {
    controls.target.copy(clusterGroup.position);
  }
  controls.update();
  if (!cameraLocked && !controls.target.equals(clusterGroup.position)) {
    clusterGroup.position.copy(controls.target);
  }
  renderer.render(scene, camera);
}

/* Initialization */
setInertiaDuration(spinState.inertiaDuration);
setInertiaEnabled(spinState.inertiaEnabled);
setAutoRotation(false);
recalculateSheetMetrics();
const initialPanelVisible = false;
setPanelVisible(initialPanelVisible);
if (startInEditingMode) {
  setEditingMode(true, { skipStop: true });
} else {
  updateEditModeButton();
}
setCameraLocked(false);
updatePointColor(false);
setSliders();
rebuildStars();
focusOnFeldappenCenter({ repositionCamera: true });
applyAudioVisualState();
requestAnimationFrame(animate);
</script>
</body>
</html>
